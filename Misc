Excellent plan! Let’s enhance the solution with slide classification and multi-slide labeling. Here’s my implementation strategy:

## Architecture Changes

```
Current: File → Slide 1 → Label text boxes on header
New:     File → All Slides → Label slide type → Label text boxes on each slide
```

## Implementation Plan

### 1. **New Data Models**

```csharp
// Add to your existing classes
public class PowerPointFileInfo
{
    // ... existing properties ...
    public List<SlideInfo> Slides { get; set; } = new List<SlideInfo>();
}

public class SlideInfo
{
    public int SlideNumber { get; set; }
    public string SlideType { get; set; }  // "TitlePage", "Procedure", etc.
    public List<LabeledTextBox> TextBoxes { get; set; } = new List<LabeledTextBox>();
    public string ThumbnailPath { get; set; }  // For visual reference
}

public enum SlideType
{
    TitlePage,
    PartsAndEquipment,
    ExplodedView,
    ReferenceImage,
    ApprovedSwabs,
    AcceptGoodChecklist,
    Procedure,
    PassGoodChecklist,
    Appendix,
    Other
}

public enum TextBoxType
{
    // Title page labels (existing)
    WI_Number,
    WI_Title,
    Revision,
    BOM_ASSY_DWG_NO,
    Operation_No,
    Product_Line,
    Subject,
    Template_Revision,
    
    // Multi-slide labels (new)
    SlideTitle,
    SlideProcedure,
    Notes,
    Other,
    Ignore
}
```

### 2. **Updated UI - Add Slide Type Panel**

I’ll modify your XAML to add a slide classification panel:

```xml
<!-- Add this section to your toolbar area -->
<Border Grid.Row="0" Background="#37474F" Padding="10">
    <StackPanel>
        <!-- Existing toolbar content -->
        
        <!-- NEW: Slide Classification -->
        <Separator Margin="0,10" Background="#666"/>
        <TextBlock Text="Classify This Slide:" Foreground="White" 
                   FontSize="12" FontWeight="Bold" Margin="0,5"/>
        <ComboBox x:Name="cmbSlideType" Width="200" Height="30"
                  SelectionChanged="CmbSlideType_SelectionChanged">
            <ComboBoxItem Content="Title Page" Tag="TitlePage"/>
            <ComboBoxItem Content="Parts and Equipment" Tag="PartsAndEquipment"/>
            <ComboBoxItem Content="Exploded View" Tag="ExplodedView"/>
            <ComboBoxItem Content="Reference Image" Tag="ReferenceImage"/>
            <ComboBoxItem Content="Approved Swabs" Tag="ApprovedSwabs"/>
            <ComboBoxItem Content="Accept/Good Checklist" Tag="AcceptGoodChecklist"/>
            <ComboBoxItem Content="Procedure" Tag="Procedure"/>
            <ComboBoxItem Content="Pass/Good Checklist" Tag="PassGoodChecklist"/>
            <ComboBoxItem Content="Appendix" Tag="Appendix"/>
            <ComboBoxItem Content="Other" Tag="Other"/>
        </ComboBox>
    </StackPanel>
</Border>
```

### 3. **Updated Right Panel - Context-Sensitive Labels**

The label buttons should change based on slide type:

```csharp
private void UpdateAvailableLabels(string slideType)
{
    // Clear existing buttons
    labelButtonsPanel.Children.Clear();
    
    if (slideType == "TitlePage")
    {
        // Show title page labels (your existing ones)
        AddLabelButton("WI Number", "WI_Number", "#2196F3");
        AddLabelButton("WI Title", "WI_Title", "#4CAF50");
        // ... etc
    }
    else
    {
        // Show generic slide labels
        AddLabelButton("Slide Title", "SlideTitle", "#2196F3");
        AddLabelButton("Procedure Text", "SlideProcedure", "#4CAF50");
        AddLabelButton("Notes", "Notes", "#FF9800");
        AddLabelButton("Other", "Other", "#757575");
    }
    
    // Always show these
    AddLabelButton("Ignore", "Ignore", "#757575");
    AddLabelButton("Hide Box", "HideBox", "#607D8B");
}
```

### 4. **Enhanced Navigation**

```csharp
private void BtnNextSlide_Click(object sender, RoutedEventArgs e)
{
    if (_currentFile == null) return;
    
    // Save current slide's work
    SaveCurrentSlideLabels();
    
    // Move to next slide
    if (_currentSlideIndex < _currentFile.Slides.Count - 1)
    {
        _currentSlideIndex++;
        LoadSlide(_currentSlideIndex);
    }
    else
    {
        MessageBox.Show("This is the last slide.", "Info");
    }
}

private void SaveCurrentSlideLabels()
{
    var currentSlide = _currentFile.Slides[_currentSlideIndex];
    currentSlide.SlideType = (cmbSlideType.SelectedItem as ComboBoxItem)?.Tag.ToString();
    currentSlide.TextBoxes = _allLabeledBoxes
        .Where(b => b.SourceFile == _currentFile.FilePath && 
                    b.SlideNumber == _currentSlideIndex + 1)
        .ToList();
}
```

### 5. **Extract All Slides**

```csharp
private void ExtractAllSlidesFromPowerPoint(string filePath)
{
    var pptApp = new Application();
    
    try
    {
        Presentation ppt = pptApp.Presentations.Open(filePath,
            MsoTriState.msoFalse, MsoTriState.msoFalse, MsoTriState.msoFalse);

        string revType = DetectRevisionType(ppt);
        _currentFile.Slides.Clear();

        // Extract ALL slides
        for (int i = 1; i <= ppt.Slides.Count; i++)
        {
            var slideInfo = new SlideInfo
            {
                SlideNumber = i,
                SlideType = i == 1 ? "TitlePage" : "Other",  // Default classification
                TextBoxes = new List<LabeledTextBox>()
            };

            Slide slide = ppt.Slides[i];
            var textBoxes = new List<TextBoxInfo>();

            // Collect text boxes from all sources
            CollectTextBoxes(slide.Shapes, textBoxes, "Slide");
            
            try { CollectTextBoxes(slide.Master.Shapes, textBoxes, "Master"); } 
            catch { }
            
            try { CollectTextBoxes(slide.Design.SlideMaster.Shapes, textBoxes, "Design"); } 
            catch { }
            
            try { CollectTextBoxes(slide.CustomLayout.Shapes, textBoxes, "CustomLayout"); } 
            catch { }

            // Remove duplicates
            var uniqueBoxes = textBoxes
                .GroupBy(b => new { b.Text, Left = Math.Round(b.Left, 1), Top = Math.Round(b.Top, 1) })
                .Select(g => g.First())
                .ToList();

            // Convert to LabeledTextBox
            foreach (var box in uniqueBoxes)
            {
                if (string.IsNullOrWhiteSpace(box.Text)) continue;

                var labeledBox = new LabeledTextBox
                {
                    Text = box.Text,
                    Left = box.Left,
                    Top = box.Top,
                    Width = box.Width,
                    Height = box.Height,
                    RevisionType = revType,
                    SourceFile = filePath,
                    SlideNumber = i,
                    AssignedLabel = null,
                    IsHidden = false
                };

                slideInfo.TextBoxes.Add(labeledBox);
                _allLabeledBoxes.Add(labeledBox);
            }

            _currentFile.Slides.Add(slideInfo);
        }

        txtSlideInfo.Text = $"Slide 1 of {ppt.Slides.Count}";
        ppt.Close();
    }
    finally
    {
        pptApp.Quit();
    }
}
```

### 6. **ML Prediction Integration**

```csharp
private void BtnPredictLabels_Click(object sender, RoutedEventArgs e)
{
    if (_currentFile == null)
    {
        MessageBox.Show("Please load a file first.", "No File");
        return;
    }

    var openDialog = new OpenFileDialog
    {
        Filter = "Model Files (*.zip)|*.zip",
        Title = "Select Trained Model"
    };

    if (openDialog.ShowDialog() == true)
    {
        try
        {
            PredictLabelsForCurrentSlide(openDialog.FileName);
            MessageBox.Show("Labels predicted! Review and correct as needed.", 
                "Prediction Complete");
        }
        catch (Exception ex)
        {
            MessageBox.Show($"Prediction error: {ex.Message}", "Error");
        }
    }
}

private void PredictLabelsForCurrentSlide(string modelPath)
{
    var mlContext = new MLContext();
    
    // Load the trained model
    ITransformer trainedModel = mlContext.Model.Load(modelPath, out var modelSchema);
    var predictionEngine = mlContext.Model.CreatePredictionEngine<TextBoxFeatures, TextBoxPrediction>(trainedModel);

    // Get current slide's text boxes
    var currentSlide = _currentFile.Slides[_currentSlideIndex];
    
    foreach (var box in currentSlide.TextBoxes)
    {
        if (box.IsHidden || !string.IsNullOrEmpty(box.AssignedLabel))
            continue;  // Skip already labeled or hidden boxes

        // Create features
        var features = new TextBoxFeatures
        {
            Left = box.Left,
            Top = box.Top,
            Width = box.Width,
            Height = box.Height,
            TextLength = box.Text.Length,
            ContainsNumbers = Regex.IsMatch(box.Text, @"\d") ? 1f : 0f,
            ContainsHyphen = box.Text.Contains("-") ? 1f : 0f,
            StartsWithWI = box.Text.StartsWith("WI", StringComparison.OrdinalIgnoreCase) ? 1f : 0f,
            IsAllDigits = Regex.IsMatch(box.Text, @"^\d+$") ? 1f : 0f,
            RevisionType = box.RevisionType
        };

        // Predict
        var prediction = predictionEngine.Predict(features);
        
        // Apply prediction with confidence threshold
        float maxScore = prediction.Score.Max();
        if (maxScore > 0.7f)  // Only apply if >70% confident
        {
            box.AssignedLabel = prediction.FieldType;
            Console.WriteLine($"Predicted '{prediction.FieldType}' for '{box.Text}' (confidence: {maxScore:P0})");
        }
    }

    // Refresh display
    DisplaySlide(_currentSlideIndex);
}
```

### 7. **Updated CSV Export**

```csharp
private void SaveTrainingDataToCSV(string filePath)
{
    using (var writer = new StreamWriter(filePath))
    {
        // New headers including slide classification
        writer.WriteLine("FileName,SlideNumber,SlideType,WI_Number,WI_Title,Revision,BOM_ASSY_DWG_NO,Operation_No,Product_Line,Subject,Template_Rev,TextBoxText,Left,Top,Width,Height,TextLength,ContainsNumbers,ContainsHyphen,StartsWithWI,IsAllDigits,RevisionType,Label");

        foreach (var file in _powerPointFiles)
        {
            foreach (var slide in file.Slides)
            {
                foreach (var box in slide.TextBoxes.Where(b => !b.IsHidden && !string.IsNullOrEmpty(b.AssignedLabel)))
                {
                    string line = string.Join(",",
                        EscapeCSV(file.FileName),
                        slide.SlideNumber,
                        EscapeCSV(slide.SlideType ?? "Other"),
                        // Extract values only for title page
                        slide.SlideType == "TitlePage" ? EscapeCSV(file.ExtractedWINumber) : "",
                        slide.SlideType == "TitlePage" ? EscapeCSV(file.ExtractedTitle) : "",
                        // ... etc for other fields
                        EscapeCSV(CleanTextForCSV(box.Text)),
                        box.Left.ToString(CultureInfo.InvariantCulture),
                        box.Top.ToString(CultureInfo.InvariantCulture),
                        box.Width.ToString(CultureInfo.InvariantCulture),
                        box.Height.ToString(CultureInfo.InvariantCulture),
                        box.Text.Length.ToString(),
                        Regex.IsMatch(box.Text, @"\d") ? "true" : "false",
                        box.Text.Contains("-") ? "true" : "false",
                        box.Text.StartsWith("WI", StringComparison.OrdinalIgnoreCase) ? "true" : "false",
                        Regex.IsMatch(box.Text, @"^\d+$") ? "true" : "false",
                        EscapeCSV(box.RevisionType),
                        EscapeCSV(box.AssignedLabel)
                    );

                    writer.WriteLine(line);
                }
            }
        }
    }
}
```

## Would you like me to:

1. **Provide the complete modified code files** with all these changes integrated?
1. **Create separate classification models** - one for slide types, one for text boxes?
1. **Add a progress indicator** showing which slides have been labeled in each file?
1. **Implement slide thumbnails** so you can see what each slide looks like while labeling?

Which would be most helpful for your workflow?​​​​​​​​​​​​​​​​