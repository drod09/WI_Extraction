"""
Work Instruction PowerPoint Data Extractor
Extracts tables and images from PowerPoint files to Excel
"""

import os
from pptx import Presentation
import pandas as pd
from datetime import datetime
from openpyxl import load_workbook
from openpyxl.styles import Font, PatternFill, Alignment, numbers
import re
from PIL import Image
import io

def identify_revision_type(prs):
    """Identifies revision type from FM-ME-07 text box at bottom right"""
    if len(prs.slides) > 0:
        slide = prs.slides[0]
        
        # Look for FM-ME-07 text in all shapes (including grouped shapes)
        for shape in slide.shapes:
            if shape.has_text_frame:
                text = shape.text.lower()
                if 'fm-me-' in text or 'fm me' in text or 'fmme' in text:
                    # Check for revision numbers
                    if 'rev15' in text or 'rev16' in text or 'rev 15' in text or 'rev 16' in text:
                        return '15-16'
                    elif 'rev17' in text or 'rev18' in text or 'rev19' in text or 'rev 17' in text or 'rev 18' in text or 'rev 19' in text:
                        return '17-19'
    
    return 'Unknown'

def clean_cell_value(value):
    """Cleans cell values to remove illegal characters for Excel"""
    if not value or not isinstance(value, str):
        return value
    
    # Replace newlines with spaces
    value = value.replace('\n', ' ').replace('\r', ' ')
    
    # Replace tabs with spaces
    value = value.replace('\t', ' ')
    
    # Remove other control characters (ASCII 0-31 except tab, newline, carriage return)
    value = ''.join(char for char in value if ord(char) >= 32 or char in '\t\n\r')
    
    # Clean up multiple spaces
    value = ' '.join(value.split())
    
    return value.strip()

def parse_date(date_str):
    """Parses various date formats and returns MM/DD/YYYY format"""
    if not date_str or not isinstance(date_str, str):
        return ""
    
    date_str = date_str.strip()
    
    if not date_str or date_str == '':
        return ""
    
    # Common date patterns
    patterns = [
        r'(\d{1,2})/(\d{1,2})/(\d{4})',  # MM/DD/YYYY or M/D/YYYY
        r'(\d{1,2})/(\d{1,2})/(\d{2})',  # MM/DD/YY or M/D/YY
        r'(\d{4})-(\d{1,2})-(\d{1,2})',  # YYYY-MM-DD
        r'(\d{1,2})-(\d{1,2})-(\d{4})',  # MM-DD-YYYY or DD-MM-YYYY
    ]
    
    for pattern in patterns:
        match = re.search(pattern, date_str)
        if match:
            try:
                if len(match.groups()) == 3:
                    part1, part2, part3 = match.groups()
                    
                    # Handle YYYY-MM-DD format
                    if len(part1) == 4:
                        year = int(part1)
                        month = int(part2)
                        day = int(part3)
                    # Handle YY format
                    elif len(part3) == 2:
                        month = int(part1)
                        day = int(part2)
                        year = 2000 + int(part3)
                    # Handle MM/DD/YYYY or MM-DD-YYYY
                    else:
                        month = int(part1)
                        day = int(part2)
                        year = int(part3)
                    
                    # Validate and format
                    if 1 <= month <= 12 and 1 <= day <= 31 and 1900 <= year <= 2100:
                        return f"{month:02d}/{day:02d}/{year:04d}"
            except:
                pass
    
    return date_str  # Return original if can't parse

def find_table_by_header(slide, header_text):
    """Finds a table by looking for header text"""
    for shape in slide.shapes:
        if shape.has_table:
            table = shape.table
            # Check first row for header
            first_row_text = ' '.join([cell.text for cell in table.rows[0].cells])
            if header_text.upper() in first_row_text.upper():
                return table
    return None

def extract_bom_table(slide, doc_id):
    """Extracts BOM/Configuration table from slide"""
    bom_data = []
    
    print(f"    Searching for BOM table...")
    
    # Look for BOM/CONFIGURATION TABLE
    table = find_table_by_header(slide, 'BOM/CONFIGURATION TABLE')
    if not table:
        table = find_table_by_header(slide, 'BOM/CONFIGURATION')
    if not table:
        table = find_table_by_header(slide, 'CONFIGURATION TABLE')
    if not table:
        table = find_table_by_header(slide, 'BOM')
    if not table:
        table = find_table_by_header(slide, 'CONFIGURATION')
    
    if table:
        print(f"    Found BOM table with {len(table.rows)} rows")
        
        # Look for the actual column headers row (Part Number, Description)
        header_row_index = None
        for idx, row in enumerate(table.rows):
            row_text = ' '.join([cell.text for cell in row.cells]).upper()
            if 'PART NUMBER' in row_text or 'DESCRIPTION' in row_text:
                header_row_index = idx
                break
        
        if header_row_index is not None:
            # Extract data rows after the column header row
            data_row_count = 0
            for idx, row in enumerate(list(table.rows)[header_row_index + 1:], start=1):
                if len(row.cells) >= 2:
                    part_num = row.cells[0].text.strip()
                    description = row.cells[1].text.strip()
                    
                    # Only add if both part number and description have content
                    if part_num and description and len(part_num) > 0 and len(description) > 0:
                        bom_data.append({
                            'DocumentID': doc_id,
                            'PartNumber': clean_cell_value(part_num),
                            'Description': clean_cell_value(description),
                            'RowOrder': idx
                        })
                        data_row_count += 1
            
            print(f"    Extracted {data_row_count} BOM entries")
    else:
        print(f"    No BOM/CONFIGURATION table found")
    
    return bom_data

def get_merged_cell_value(table, row_idx, col_idx):
    """
    Gets the actual value from a cell, handling merged cells.
    If a cell is part of a merged region, returns the value from the top-left cell of that region.
    """
    try:
        cell = table.cell(row_idx, col_idx)
        # Try to get text from this cell
        text = cell.text_frame.text.strip()
        
        # If empty, it might be part of a merged cell - look upward for the value
        if not text:
            # Check cells above in the same column
            for check_row in range(row_idx - 1, -1, -1):
                try:
                    check_cell = table.cell(check_row, col_idx)
                    check_text = check_cell.text_frame.text.strip()
                    if check_text:
                        return check_text
                except:
                    pass
        
        return text
    except:
        return ""


def extract_equipment_and_parts(slide, doc_id):
    """Extracts Equipment Required and Parts Required tables from slide 2"""
    equipment_data = []
    parts_data = []
    
    print(f"    Searching for Equipment and Parts tables on slide 2...")
    
    # Look for Equipment Required table
    equipment_table = find_table_by_header(slide, 'EQUIPMENT REQUIRED')
    if not equipment_table:
        equipment_table = find_table_by_header(slide, 'Equipment Required')
    
    if equipment_table:
        print(f"    Found Equipment Required table with {len(equipment_table.rows)} rows")
        
        # Find header row
        header_row_index = None
        for idx, row in enumerate(equipment_table.rows):
            row_text = ' '.join([cell.text for cell in row.cells]).upper()
            if 'QTY' in row_text and ('PART NO' in row_text or 'DESCRIPTION' in row_text):
                header_row_index = idx
                print(f"    Header row found at index {idx}")
                break
        
        if header_row_index is not None:
            data_row_count = 0
            
            # Process each data row
            for row_idx, row in enumerate(list(equipment_table.rows)[header_row_index + 1:], start=header_row_index + 1):
                print(f"    Processing row {row_idx}, cells: {len(row.cells)}")
                
                if len(row.cells) < 3:
                    continue
                
                # Get cell values - handle merged cells by looking up for values
                cell0_text = get_merged_cell_value(equipment_table, row_idx, 0)  # Qty
                cell1_text = get_merged_cell_value(equipment_table, row_idx, 1)  # Part No
                cell2_text = clean_cell_value(row.cells[2].text.strip())  # Description
                
                # Clean the values
                cell0_text = clean_cell_value(cell0_text)
                cell1_text = clean_cell_value(cell1_text)
                
                print(f"      Cell 0 (Qty): '{cell0_text}' (merged-aware)")
                print(f"      Cell 1 (Part): '{cell1_text}' (merged-aware)")
                print(f"      Cell 2 (Desc): '{cell2_text}'")
                
                # Check if Description cell contains multiple items separated by semicolons or newlines
                descriptions = []
                if ';' in cell2_text:
                    descriptions = [d.strip() for d in cell2_text.split(';') if d.strip()]
                elif '\n' in cell2_text or '\r' in cell2_text:
                    descriptions = [d.strip() for d in cell2_text.replace('\r', '\n').split('\n') if d.strip()]
                else:
                    descriptions = [cell2_text] if cell2_text else []
                
                print(f"      Found {len(descriptions)} description(s)")
                
                # If we have multiple descriptions, repeat Qty and Part No for each
                if len(descriptions) > 1:
                    print(f"      MERGED CELL DETECTED - Creating {len(descriptions)} separate rows")
                    for desc in descriptions:
                        equipment_data.append({
                            'DocumentID': doc_id,
                            'Quantity': cell0_text,  # Repeat same Qty
                            'PartNumber': cell1_text,  # Repeat same Part No
                            'Description': desc,
                            'RowOrder': data_row_count + 1
                        })
                        data_row_count += 1
                        print(f"        Row {data_row_count}: Qty='{cell0_text}', Part='{cell1_text}', Desc='{desc}'")
                else:
                    # Normal single row - but still use merged-aware values
                    if cell0_text or cell1_text or (descriptions and descriptions[0]):
                        equipment_data.append({
                            'DocumentID': doc_id,
                            'Quantity': cell0_text,
                            'PartNumber': cell1_text,
                            'Description': descriptions[0] if descriptions else "",
                            'RowOrder': data_row_count + 1
                        })
                        data_row_count += 1
                        print(f"        Row {data_row_count}: Qty='{cell0_text}', Part='{cell1_text}', Desc='{descriptions[0] if descriptions else ''}'")
            
            print(f"    Extracted {data_row_count} equipment entries")
    else:
        print(f"    No Equipment Required table found")
    
    # Parts Required - same logic with merged cell handling
    parts_table = find_table_by_header(slide, 'PARTS REQUIRED')
    if not parts_table:
        parts_table = find_table_by_header(slide, 'Parts Required')
    
    if parts_table:
        print(f"    Found Parts Required table with {len(parts_table.rows)} rows")
        
        header_row_index = None
        for idx, row in enumerate(parts_table.rows):
            row_text = ' '.join([cell.text for cell in row.cells]).upper()
            if 'QTY' in row_text and ('PART NO' in row_text or 'DESCRIPTION' in row_text):
                header_row_index = idx
                break
        
        if header_row_index is not None:
            data_row_count = 0
            
            for row_idx, row in enumerate(list(parts_table.rows)[header_row_index + 1:], start=header_row_index + 1):
                if len(row.cells) < 3:
                    continue
                
                # Get cell values - handle merged cells
                cell0_text = get_merged_cell_value(parts_table, row_idx, 0)  # Qty
                cell1_text = get_merged_cell_value(parts_table, row_idx, 1)  # Part No
                cell2_text = clean_cell_value(row.cells[2].text.strip())  # Description
                
                # Clean the values
                cell0_text = clean_cell_value(cell0_text)
                cell1_text = clean_cell_value(cell1_text)
                
                # Handle multiple descriptions
                descriptions = []
                if ';' in cell2_text:
                    descriptions = [d.strip() for d in cell2_text.split(';') if d.strip()]
                elif '\n' in cell2_text or '\r' in cell2_text:
                    descriptions = [d.strip() for d in cell2_text.replace('\r', '\n').split('\n') if d.strip()]
                else:
                    descriptions = [cell2_text] if cell2_text else []
                
                if len(descriptions) > 1:
                    for desc in descriptions:
                        parts_data.append({
                            'DocumentID': doc_id,
                            'Quantity': cell0_text,  # Repeat same Qty
                            'PartNumber': cell1_text,  # Repeat same Part No
                            'Description': desc,
                            'RowOrder': data_row_count + 1
                        })
                        data_row_count += 1
                else:
                    if cell0_text or cell1_text or (descriptions and descriptions[0]):
                        parts_data.append({
                            'DocumentID': doc_id,
                            'Quantity': cell0_text,
                            'PartNumber': cell1_text,
                            'Description': descriptions[0] if descriptions else "",
                            'RowOrder': data_row_count + 1
                        })
                        data_row_count += 1
            
            print(f"    Extracted {data_row_count} parts entries")
    else:
        print(f"    No Parts Required table found")
    
    return equipment_data, parts_data

def extract_all_other_tables(prs, doc_id, known_table_headers):
    """
    Scans all slides for tables that aren't already identified.
    Creates a separate dataset for each unique table found.
    
    Args:
        prs: PowerPoint presentation object
        doc_id: Document ID
        known_table_headers: List of table headers we already extract (to skip them)
    
    Returns:
        Dictionary where keys are table names and values are lists of row data
    """
    all_tables = {}
    table_counter = 1
    
    print(f"\n  Scanning for additional tables across all slides...")
    
    for slide_idx in range(len(prs.slides)):
        slide = prs.slides[slide_idx]
        slide_num = slide_idx + 1
        
        for shape in slide.shapes:
            if shape.has_table:
                table = shape.table
                
                # Get first row to identify the table
                if len(table.rows) == 0:
                    continue
                
                first_row_text = ' '.join([cell.text for cell in table.rows[0].cells]).upper()
                
                # Skip if this is a known table we already process
                is_known = False
                for known_header in known_table_headers:
                    if known_header.upper() in first_row_text:
                        is_known = True
                        print(f"    Slide {slide_num}: Skipping known table '{known_header}'")
                        break
                
                if is_known:
                    continue
                
                # This is a new table!
                # Determine table name from first row or use generic name
                table_name = first_row_text[:50].strip() if first_row_text else f"Table_{table_counter}"
                
                # Make it a valid sheet name (Excel limit: 31 chars, no special chars)
                table_name = table_name.replace('/', '_').replace('\\', '_').replace('*', '_')
                table_name = table_name.replace('[', '_').replace(']', '_').replace(':', '_')
                table_name = table_name.replace('?', '_').replace('|', '_')
                table_name = table_name[:31]  # Excel sheet name limit
                
                # Make unique if duplicate
                original_name = table_name
                suffix = 1
                while table_name in all_tables:
                    table_name = f"{original_name[:27]}_{suffix}"
                    suffix += 1
                
                print(f"    Slide {slide_num}: Found new table - '{table_name}'")
                print(f"      Rows: {len(table.rows)}, Columns: {len(table.columns)}")
                
                # Extract all rows from this table
                table_data = []
                
                for row_idx in range(len(table.rows)):
                    row_data = {
                        'DocumentID': doc_id,
                        'SlideNumber': slide_num,
                        'RowNumber': row_idx + 1
                    }
                    
                    # Extract each cell in the row
                    for col_idx in range(len(table.columns)):
                        # Use merged-cell-aware extraction
                        cell_value = get_merged_cell_value(table, row_idx, col_idx)
                        cell_value = clean_cell_value(cell_value)
                        
                        # Column name: use first row as headers if it looks like headers,
                        # otherwise use generic Column1, Column2, etc.
                        if row_idx == 0:
                            col_name = f"Column{col_idx + 1}"
                        else:
                            # Try to use first row as header
                            try:
                                header_cell = table.rows[0].cells[col_idx].text.strip()
                                if header_cell and len(header_cell) < 50:
                                    col_name = header_cell.replace(' ', '_').replace('/', '_')
                                    # Make it Excel-friendly
                                    col_name = ''.join(c for c in col_name if c.isalnum() or c == '_')
                                    if not col_name:
                                        col_name = f"Column{col_idx + 1}"
                                else:
                                    col_name = f"Column{col_idx + 1}"
                            except:
                                col_name = f"Column{col_idx + 1}"
                        
                        row_data[col_name] = cell_value
                    
                    table_data.append(row_data)
                
                all_tables[table_name] = table_data
                print(f"      Extracted {len(table_data)} rows")
                
                table_counter += 1
    
    if all_tables:
        print(f"\n  Found {len(all_tables)} additional table(s)")
    else:
        print(f"\n  No additional tables found")
    
    return all_tables

def extract_revision_history(slide, doc_id):
    """Extracts Revision History table from slide"""
    rev_data = []
    
    table = find_table_by_header(slide, 'REVISION HISTORY')
    
    if table:
        # Skip first row (header) and get data
        for idx, row in enumerate(list(table.rows)[1:], start=1):
            if len(row.cells) >= 3:
                rev_num = row.cells[0].text.strip()
                rev_desc = row.cells[1].text.strip()
                rev_date = row.cells[2].text.strip()
                
                # Skip header row and empty rows
                if rev_num and 'Rev' not in rev_num and rev_num != '#' and 'Description' not in rev_desc:
                    # Format date
                    formatted_date = parse_date(rev_date)
                    
                    rev_data.append({
                        'DocumentID': doc_id,
                        'RevNumber': rev_num,
                        'ChangeDescription': rev_desc,
                        'ChangeDate': formatted_date,
                        'RowOrder': idx
                    })
    
    return rev_data

def extract_drafting_and_approvals(slide, doc_id):
    """Extracts both Drafting and Approvals from combined table"""
    drafting_data = []
    approvals_data = []
    
    for shape in slide.shapes:
        if shape.has_table:
            table = shape.table
            
            # Check if this table has both Drafting and Approvals
            all_text = ' '.join([cell.text for row in table.rows for cell in row.cells]).upper()
            
            if 'DRAFTING' in all_text and 'APPROVALS' in all_text:
                # This is the combined table
                in_approvals_section = False
                
                for row_idx, row in enumerate(table.rows):
                    if len(row.cells) >= 3:
                        first_cell = row.cells[0].text.strip()
                        
                        # Check if we've reached Approvals section
                        if 'Approvals' in first_cell:
                            in_approvals_section = True
                            continue
                        
                        # Skip header rows
                        if first_cell in ['Drafting', 'Signatures', 'Date']:
                            continue
                        
                        # Extract data
                        col1 = row.cells[0].text.strip()
                        col2 = row.cells[1].text.strip()
                        col3 = row.cells[2].text.strip()
                        
                        # Format date
                        formatted_date = parse_date(col3)
                        
                        if col1:  # Has data
                            if in_approvals_section:
                                # Approvals section
                                approvals_data.append({
                                    'DocumentID': doc_id,
                                    'Department': col1,
                                    'Signature': col2,
                                    'ApprovalDate': formatted_date
                                })
                            else:
                                # Drafting section
                                drafting_data.append({
                                    'DocumentID': doc_id,
                                    'Role': col1,
                                    'Signature': col2,
                                    'SignatureDate': formatted_date
                                })
                
                break
    
    return drafting_data, approvals_data

def format_excel_sheet(worksheet):
    """Formats Excel sheet with gray headers and auto-fit columns"""
    # Format header row
    gray_fill = PatternFill(start_color="D3D3D3", end_color="D3D3D3", fill_type="solid")
    bold_font = Font(bold=True)
    center_alignment = Alignment(horizontal="center")
    
    for cell in worksheet[1]:
        cell.fill = gray_fill
        cell.font = bold_font
        cell.alignment = center_alignment
    
    # Auto-fit columns
    for column in worksheet.columns:
        max_length = 0
        column_letter = column[0].column_letter
        
        for cell in column:
            try:
                if cell.value:
                    max_length = max(max_length, len(str(cell.value)))
            except:
                pass
        
        adjusted_width = min(max_length + 2, 50)  # Cap at 50 characters
        worksheet.column_dimensions[column_letter].width = adjusted_width

def process_powerpoint_files(folder_path, output_excel):
    """Main function to process PowerPoint files"""
    
    # Initialize data containers
    bom_data_all = []
    equipment_data_all = []
    parts_data_all = []
    rev_history_all = []
    drafting_all = []
    approvals_all = []
    other_tables_all = {}  # Dictionary to hold all other tables
    
    doc_id = 1
    
    # Define known table headers that we already extract
    known_table_headers = [
        'BOM/CONFIGURATION',
        'BOM',
        'CONFIGURATION',
        'EQUIPMENT REQUIRED',
        'PARTS REQUIRED',
        'REVISION HISTORY',
        'DRAFTING',
        'APPROVALS'
    ]
    
    # Process each PowerPoint file
    for filename in os.listdir(folder_path):
        if filename.endswith('.pptx') or filename.endswith('.ppt'):
            if filename.startswith('~$'):  # Skip temp files
                continue
            
            print(f"Processing: {filename}")
            
            filepath = os.path.join(folder_path, filename)
            
            try:
                prs = Presentation(filepath)
                
                # Identify revision type
                rev_type = identify_revision_type(prs)
                print(f"  Revision type: {rev_type}")
                
                # Get first slide
                if len(prs.slides) > 0:
                    first_slide = prs.slides[0]
                    
                    # Extract tables from first slide
                    bom_data_all.extend(extract_bom_table(first_slide, doc_id))
                    
                    rev_history_all.extend(extract_revision_history(first_slide, doc_id))
                    
                    # Extract drafting and approvals (from combined table)
                    drafting, approvals = extract_drafting_and_approvals(first_slide, doc_id)
                    drafting_all.extend(drafting)
                    approvals_all.extend(approvals)
                    
                    print(f"  Extracted from slide 1: {len(drafting)} drafting, {len(approvals)} approvals")
                
                # Get second slide for Equipment and Parts
                if len(prs.slides) > 1:
                    second_slide = prs.slides[1]
                    equipment, parts = extract_equipment_and_parts(second_slide, doc_id)
                    equipment_data_all.extend(equipment)
                    parts_data_all.extend(parts)
                    print(f"  Extracted from slide 2: {len(equipment)} equipment, {len(parts)} parts")
                
                # **NEW: Scan for all other tables across all slides**
                other_tables = extract_all_other_tables(prs, doc_id, known_table_headers)
                
                # Merge other tables data
                for table_name, table_data in other_tables.items():
                    if table_name not in other_tables_all:
                        other_tables_all[table_name] = []
                    other_tables_all[table_name].extend(table_data)
                
                doc_id += 1
                
            except Exception as e:
                print(f"  ERROR processing {filename}: {str(e)}")
                import traceback
                traceback.print_exc()
    
    # Create Excel file
    print(f"\nCreating Excel file: {output_excel}")
    
    with pd.ExcelWriter(output_excel, engine='openpyxl') as writer:
        # BOM sheet
        if bom_data_all:
            df_bom = pd.DataFrame(bom_data_all)
            df_bom.to_excel(writer, sheet_name='BOM', index=False)
        else:
            df_bom = pd.DataFrame(columns=['DocumentID', 'PartNumber', 'Description', 'RowOrder'])
            df_bom.to_excel(writer, sheet_name='BOM', index=False)
        
        # Equipment Required sheet
        if equipment_data_all:
            df_equipment = pd.DataFrame(equipment_data_all)
            df_equipment.to_excel(writer, sheet_name='EquipmentRequired', index=False)
        else:
            df_equipment = pd.DataFrame(columns=['DocumentID', 'Quantity', 'PartNumber', 'Description', 'RowOrder'])
            df_equipment.to_excel(writer, sheet_name='EquipmentRequired', index=False)
        
        # Parts Required sheet
        if parts_data_all:
            df_parts = pd.DataFrame(parts_data_all)
            df_parts.to_excel(writer, sheet_name='PartsRequired', index=False)
        else:
            df_parts = pd.DataFrame(columns=['DocumentID', 'Quantity', 'PartNumber', 'Description', 'RowOrder'])
            df_parts.to_excel(writer, sheet_name='PartsRequired', index=False)
        
        # Revision History sheet
        if rev_history_all:
            df_rev = pd.DataFrame(rev_history_all)
            df_rev.to_excel(writer, sheet_name='RevisionHistory', index=False)
        else:
            df_rev = pd.DataFrame(columns=['DocumentID', 'RevNumber', 'ChangeDescription', 'ChangeDate', 'RowOrder'])
            df_rev.to_excel(writer, sheet_name='RevisionHistory', index=False)
        
        # Drafting sheet
        if drafting_all:
            df_draft = pd.DataFrame(drafting_all)
            df_draft.to_excel(writer, sheet_name='Drafting', index=False)
        else:
            df_draft = pd.DataFrame(columns=['DocumentID', 'Role', 'Signature', 'SignatureDate'])
            df_draft.to_excel(writer, sheet_name='Drafting', index=False)
        
        # Approvals sheet
        if approvals_all:
            df_approve = pd.DataFrame(approvals_all)
            df_approve.to_excel(writer, sheet_name='Approvals', index=False)
        else:
            df_approve = pd.DataFrame(columns=['DocumentID', 'Department', 'Signature', 'ApprovalDate'])
            df_approve.to_excel(writer, sheet_name='Approvals', index=False)
        
        # **NEW: Add sheets for all other discovered tables**
        for table_name, table_data in other_tables_all.items():
            if table_data:
                df_other = pd.DataFrame(table_data)
                # Ensure sheet name is valid
                safe_sheet_name = table_name[:31]
                df_other.to_excel(writer, sheet_name=safe_sheet_name, index=False)
                print(f"  Created sheet: {safe_sheet_name} ({len(table_data)} rows)")
    
    # Apply formatting to all sheets
    print("Applying formatting...")
    workbook = load_workbook(output_excel)
    
    for sheet_name in workbook.sheetnames:
        worksheet = workbook[sheet_name]
        format_excel_sheet(worksheet)
    
    workbook.save(output_excel)
    
    print(f"\nExtraction complete!")
    print(f"Processed {doc_id - 1} documents")
    print(f"Total BOM entries: {len(bom_data_all)}")
    print(f"Total Equipment entries: {len(equipment_data_all)}")
    print(f"Total Parts entries: {len(parts_data_all)}")
    print(f"Total Revision History entries: {len(rev_history_all)}")
    print(f"Total Drafting entries: {len(drafting_all)}")
    print(f"Total Approval entries: {len(approvals_all)}")
    print(f"Total additional tables found: {len(other_tables_all)}")
    for table_name, table_data in other_tables_all.items():
        print(f"  - {table_name}: {len(table_data)} rows")
    print(f"Saved to: {output_excel}")

if __name__ == "__main__":
    # CONFIGURE THESE PATHS
    input_folder = r"C:\Users\U309011\Desktop\New folder"
    output_excel = r"C:\Users\U309011\Desktop\WorkInstructions_Extracted.xlsx"
    
    print("=" * 70)
    print("WORK INSTRUCTION POWERPOINT TABLE EXTRACTOR")
    print("=" * 70)
    print(f"Input folder: {input_folder}")
    print(f"Output Excel: {output_excel}")
    print("=" * 70)
    
    # Run extraction
    process_powerpoint_files(input_folder, output_excel)
    
    print("\n" + "=" * 70)
    print("DONE! Open the Excel file to review extracted data.")
    print("=" * 70)

------------------------
namespace WorkInstructionExtractor
{
    partial class Form1
    {
        private System.ComponentModel.IContainer components = null;

        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        private void InitializeComponent()
        {
            this.txtPowerPointPath = new System.Windows.Forms.TextBox();
            this.txtOutputFolder = new System.Windows.Forms.TextBox();
            this.btnSelectFile = new System.Windows.Forms.Button();
            this.btnSelectOutputFolder = new System.Windows.Forms.Button();
            this.btnExtract = new System.Windows.Forms.Button();
            this.progressBar = new System.Windows.Forms.ProgressBar();
            this.txtLog = new System.Windows.Forms.RichTextBox();
            this.lblStatus = new System.Windows.Forms.Label();
            this.btnConfigureMapping = new System.Windows.Forms.Button();
            this.btnManageTemplates = new System.Windows.Forms.Button();
            this.label1 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.groupBox2 = new System.Windows.Forms.GroupBox();
            this.groupBox3 = new System.Windows.Forms.GroupBox();
            this.label4 = new System.Windows.Forms.Label();
            this.groupBox1.SuspendLayout();
            this.groupBox2.SuspendLayout();
            this.groupBox3.SuspendLayout();
            this.SuspendLayout();
            // 
            // txtPowerPointPath
            // 
            this.txtPowerPointPath.Location = new System.Drawing.Point(150, 30);
            this.txtPowerPointPath.Name = "txtPowerPointPath";
            this.txtPowerPointPath.ReadOnly = true;
            this.txtPowerPointPath.Size = new System.Drawing.Size(550, 22);
            this.txtPowerPointPath.TabIndex = 0;
            // 
            // txtOutputFolder
            // 
            this.txtOutputFolder.Location = new System.Drawing.Point(150, 65);
            this.txtOutputFolder.Name = "txtOutputFolder";
            this.txtOutputFolder.ReadOnly = true;
            this.txtOutputFolder.Size = new System.Drawing.Size(550, 22);
            this.txtOutputFolder.TabIndex = 2;
            // 
            // btnSelectFile
            // 
            this.btnSelectFile.Location = new System.Drawing.Point(720, 28);
            this.btnSelectFile.Name = "btnSelectFile";
            this.btnSelectFile.Size = new System.Drawing.Size(100, 26);
            this.btnSelectFile.TabIndex = 3;
            this.btnSelectFile.Text = "Browse...";
            this.btnSelectFile.UseVisualStyleBackColor = true;
            this.btnSelectFile.Click += new System.EventHandler(this.btnSelectFile_Click);
            // 
            // btnSelectOutputFolder
            // 
            this.btnSelectOutputFolder.Location = new System.Drawing.Point(720, 63);
            this.btnSelectOutputFolder.Name = "btnSelectOutputFolder";
            this.btnSelectOutputFolder.Size = new System.Drawing.Size(100, 26);
            this.btnSelectOutputFolder.TabIndex = 5;
            this.btnSelectOutputFolder.Text = "Browse...";
            this.btnSelectOutputFolder.UseVisualStyleBackColor = true;
            this.btnSelectOutputFolder.Click += new System.EventHandler(this.btnSelectOutputFolder_Click);
            // 
            // btnExtract
            // 
            this.btnExtract.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(120)))), ((int)(((byte)(215)))));
            this.btnExtract.FlatAppearance.BorderSize = 0;
            this.btnExtract.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.btnExtract.Font = new System.Drawing.Font("Segoe UI", 10F, System.Drawing.FontStyle.Bold);
            this.btnExtract.ForeColor = System.Drawing.Color.White;
            this.btnExtract.Location = new System.Drawing.Point(20, 25);
            this.btnExtract.Name = "btnExtract";
            this.btnExtract.Size = new System.Drawing.Size(200, 40);
            this.btnExtract.TabIndex = 6;
            this.btnExtract.Text = "Extract PowerPoint";
            this.btnExtract.UseVisualStyleBackColor = false;
            this.btnExtract.Click += new System.EventHandler(this.btnExtract_Click);
            // 
            // progressBar
            // 
            this.progressBar.Location = new System.Drawing.Point(240, 30);
            this.progressBar.Name = "progressBar";
            this.progressBar.Size = new System.Drawing.Size(400, 30);
            this.progressBar.TabIndex = 7;
            // 
            // txtLog
            // 
            this.txtLog.BackColor = System.Drawing.Color.White;
            this.txtLog.Dock = System.Windows.Forms.DockStyle.Fill;
            this.txtLog.Font = new System.Drawing.Font("Consolas", 9F);
            this.txtLog.Location = new System.Drawing.Point(3, 18);
            this.txtLog.Name = "txtLog";
            this.txtLog.ReadOnly = true;
            this.txtLog.Size = new System.Drawing.Size(834, 189);
            this.txtLog.TabIndex = 8;
            this.txtLog.Text = "";
            // 
            // lblStatus
            // 
            this.lblStatus.Font = new System.Drawing.Font("Segoe UI", 9F);
            this.lblStatus.Location = new System.Drawing.Point(660, 35);
            this.lblStatus.Name = "lblStatus";
            this.lblStatus.Size = new System.Drawing.Size(180, 20);
            this.lblStatus.TabIndex = 10;
            this.lblStatus.Text = "Ready";
            
            // btnManageTemplates
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(20, 33);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(102, 16);
            this.label1.TabIndex = 13;
            this.label1.Text = "PowerPoint File:";
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(20, 68);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(93, 16);
            this.label3.TabIndex = 15;
            this.label3.Text = "Output Folder:";
            // 
            // groupBox1
            // 
            this.groupBox1.Controls.Add(this.label1);
            this.groupBox1.Controls.Add(this.label3);
            this.groupBox1.Controls.Add(this.txtPowerPointPath);
            this.groupBox1.Controls.Add(this.txtOutputFolder);
            this.groupBox1.Controls.Add(this.btnSelectFile);
            this.groupBox1.Controls.Add(this.btnSelectOutputFolder);
            this.groupBox1.Location = new System.Drawing.Point(20, 80);
            this.groupBox1.Name = "groupBox1";
            this.groupBox1.Size = new System.Drawing.Size(840, 110);
            this.groupBox1.TabIndex = 16;
            this.groupBox1.TabStop = false;
            this.groupBox1.Text = "Input Files";
            // 
            // groupBox2
            // 
            this.groupBox2.Controls.Add(this.btnConfigureMapping);
            this.groupBox2.Controls.Add(this.btnManageTemplates);
            this.groupBox2.Location = new System.Drawing.Point(20, 210);
            this.groupBox2.Name = "groupBox2";
            this.groupBox2.Size = new System.Drawing.Size(840, 85);
            this.groupBox2.TabIndex = 17;
            this.groupBox2.TabStop = false;
            this.groupBox2.Text = "Field Mapping Options";
            // 
            // groupBox3
            // 
            this.groupBox3.Controls.Add(this.txtLog);
            this.groupBox3.Location = new System.Drawing.Point(20, 410);
            this.groupBox3.Name = "groupBox3";
            this.groupBox3.Size = new System.Drawing.Size(840, 210);
            this.groupBox3.TabIndex = 18;
            this.groupBox3.TabStop = false;
            this.groupBox3.Text = "Activity Log";
            // 
            // label4
            // 
            this.label4.Font = new System.Drawing.Font("Segoe UI", 16F, System.Drawing.FontStyle.Bold);
            this.label4.Location = new System.Drawing.Point(20, 20);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(840, 40);
            this.label4.TabIndex = 19;
            this.label4.Text = "Work Instruction Extractor";
            this.label4.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
            // 
            // Form1
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(880, 640);
            this.Controls.Add(this.label4);
            this.Controls.Add(this.groupBox3);
            this.Controls.Add(this.groupBox2);
            this.Controls.Add(this.groupBox1);
            this.Controls.Add(this.lblStatus);
            this.Controls.Add(this.progressBar);
            this.Controls.Add(this.btnExtract);
            this.MinimumSize = new System.Drawing.Size(800, 600);
            this.Name = "Form1";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = "Work Instruction Extractor";
            this.Load += new System.EventHandler(this.Form1_Load);
            this.groupBox1.ResumeLayout(false);
            this.groupBox1.PerformLayout();
            this.groupBox2.ResumeLayout(false);
            this.groupBox3.ResumeLayout(false);
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.TextBox txtPowerPointPath;
        private System.Windows.Forms.TextBox txtOutputFolder;
        private System.Windows.Forms.Button btnSelectFile;
        private System.Windows.Forms.Button btnSelectOutputFolder;
        private System.Windows.Forms.Button btnExtract;
        private System.Windows.Forms.ProgressBar progressBar;
        private System.Windows.Forms.RichTextBox txtLog;
        private System.Windows.Forms.Label lblStatus;
        private System.Windows.Forms.Button btnConfigureMapping;
        private System.Windows.Forms.Button btnManageTemplates;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.GroupBox groupBox1;
        private System.Windows.Forms.GroupBox groupBox2;
        private System.Windows.Forms.GroupBox groupBox3;
        private System.Windows.Forms.Label label4;
    }

}

------------------------------------

using System;
using System.Windows.Forms;

namespace WorkInstructionExtractor
{
    static class Program
    {
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1());
        }
    }
}

------------------------

<Project Sdk="Microsoft.NET.Sdk">
	<PropertyGroup>
		<TargetFramework>net8.0-windows</TargetFramework>
		<UseWindowsForms>true</UseWindowsForms>
		<EnableComHosting>true</EnableComHosting>
		<EnableDefaultCompileItems>true</EnableDefaultCompileItems>
		<OutputType>WinExe</OutputType>
	</PropertyGroup>

	<ItemGroup>
		<COMReference Include="Microsoft.Office.Core">
			<WrapperTool>tlbimp</WrapperTool>
			<VersionMinor>8</VersionMinor>
			<VersionMajor>2</VersionMajor>
			<Guid>2df8d04c-5bfa-101b-bde5-00aa0044de52</Guid>
			<Lcid>0</Lcid>
			<Isolated>false</Isolated>
			<EmbedInteropTypes>true</EmbedInteropTypes>
		</COMReference>
		<COMReference Include="Microsoft.Office.Interop.PowerPoint">
			<WrapperTool>tlbimp</WrapperTool>
			<VersionMinor>12</VersionMinor>
			<VersionMajor>2</VersionMajor>
			<Guid>91493440-5a91-11cf-8700-00aa0060263b</Guid>
			<Lcid>0</Lcid>
			<Isolated>false</Isolated>
			<EmbedInteropTypes>true</EmbedInteropTypes>
		</COMReference>
	</ItemGroup>
	
<ItemGroup>
    <PackageReference Include="EPPlus" Version="8.2.1" />
  </ItemGroup>

  <ItemGroup>
    <None Update="extract_tables.py">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
  </ItemGroup>

</Project>

------------------------

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace WorkInstructionExtractor
{
    public partial class Form1 : Form
    {
        private BackgroundWorker backgroundWorker;

        public Form1()
        {
            InitializeComponent();
            InitializeBackgroundWorker();
        }

        private void InitializeBackgroundWorker()
        {
            backgroundWorker = new BackgroundWorker
            {
                WorkerReportsProgress = true,
                WorkerSupportsCancellation = true
            };

            backgroundWorker.DoWork += BackgroundWorker_DoWork;
            backgroundWorker.ProgressChanged += BackgroundWorker_ProgressChanged;
            backgroundWorker.RunWorkerCompleted += BackgroundWorker_RunWorkerCompleted;
        }

        private void btnSelectFile_Click(object sender, EventArgs e)
        {
            using (OpenFileDialog openFileDialog = new OpenFileDialog())
            {
                openFileDialog.Filter = "PowerPoint Files (*.pptx)|*.pptx|All Files (*.*)|*.*";
                openFileDialog.Title = "Select PowerPoint Work Instruction";

                if (openFileDialog.ShowDialog() == DialogResult.OK)
                {
                    txtPowerPointPath.Text = openFileDialog.FileName;
                    LogMessage($"Selected PowerPoint: {Path.GetFileName(openFileDialog.FileName)}");
                }
            }
        }

        private void btnSelectOutputFolder_Click(object sender, EventArgs e)
        {
            using (FolderBrowserDialog folderDialog = new FolderBrowserDialog())
            {
                folderDialog.Description = "Select Output Folder";

                if (folderDialog.ShowDialog() == DialogResult.OK)
                {
                    txtOutputFolder.Text = folderDialog.SelectedPath;
                    LogMessage($"Output folder: {folderDialog.SelectedPath}");
                }
            }
        }

        
        private List<TextBoxInfo> ExtractTextBoxesFromPowerPoint(string pptxPath)
        {
            var textBoxes = new List<TextBoxInfo>();
            Microsoft.Office.Interop.PowerPoint.Application pptApp = null;
            Microsoft.Office.Interop.PowerPoint.Presentation ppt = null;

            try
            {
                pptApp = new Microsoft.Office.Interop.PowerPoint.Application();
                ppt = pptApp.Presentations.Open(pptxPath,
                    Microsoft.Office.Core.MsoTriState.msoFalse,
                    Microsoft.Office.Core.MsoTriState.msoFalse,
                    Microsoft.Office.Core.MsoTriState.msoFalse);

                if (ppt.Slides.Count > 0)
                {
                    var firstSlide = ppt.Slides[1];

                    // Collect from slide
                    CollectTextBoxesForMapping(firstSlide.Shapes, textBoxes);

                    // Collect from master
                    try { CollectTextBoxesForMapping(firstSlide.Master.Shapes, textBoxes); } catch { }
                    try { CollectTextBoxesForMapping(firstSlide.Design.SlideMaster.Shapes, textBoxes); } catch { }
                    try { CollectTextBoxesForMapping(firstSlide.CustomLayout.Shapes, textBoxes); } catch { }
                }

                ppt.Close();
            }
            finally
            {
                if (ppt != null)
                {
                    try { ppt.Close(); } catch { }
                }
                if (pptApp != null)
                {
                    try { pptApp.Quit(); } catch { }
                }
            }

            return textBoxes;
        }

        private void CollectTextBoxesForMapping(Microsoft.Office.Interop.PowerPoint.Shapes shapes, List<TextBoxInfo> textBoxes)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in shapes)
            {
                try
                {
                    if (shape.Type == Microsoft.Office.Core.MsoShapeType.msoGroup)
                    {
                        CollectTextBoxesFromGroupForMapping(shape.GroupItems, textBoxes);
                    }
                    else if (shape.HasTextFrame == Microsoft.Office.Core.MsoTriState.msoTrue)
                    {
                        string text = shape.TextFrame.TextRange.Text.Trim();
                        if (!string.IsNullOrEmpty(text))
                        {
                            textBoxes.Add(new TextBoxInfo
                            {
                                Text = text,
                                Left = shape.Left,
                                Top = shape.Top,
                                Width = shape.Width,
                                Height = shape.Height
                            });
                        }
                    }
                }
                catch { }
            }
        }

        private void CollectTextBoxesFromGroupForMapping(Microsoft.Office.Interop.PowerPoint.GroupShapes groupShapes, List<TextBoxInfo> textBoxes)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in groupShapes)
            {
                try
                {
                    if (shape.Type == Microsoft.Office.Core.MsoShapeType.msoGroup)
                    {
                        CollectTextBoxesFromGroupForMapping(shape.GroupItems, textBoxes);
                    }
                    else if (shape.HasTextFrame == Microsoft.Office.Core.MsoTriState.msoTrue)
                    {
                        string text = shape.TextFrame.TextRange.Text.Trim();
                        if (!string.IsNullOrEmpty(text))
                        {
                            textBoxes.Add(new TextBoxInfo
                            {
                                Text = text,
                                Left = shape.Left,
                                Top = shape.Top,
                                Width = shape.Width,
                                Height = shape.Height
                            });
                        }
                    }
                }
                catch { }
            }
        }

        private void btnExtract_Click(object sender, EventArgs e)
        {
            // Validation
            if (string.IsNullOrWhiteSpace(txtPowerPointPath.Text))
            {
                MessageBox.Show("Please select a PowerPoint file.", "Validation Error",
                    MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            if (string.IsNullOrWhiteSpace(txtOutputFolder.Text))
            {
                MessageBox.Show("Please select an output folder.", "Validation Error",
                    MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            // Disable UI during processing
            SetUIEnabled(false);
            txtLog.Clear();
            progressBar.Value = 0;

            // Start background processing
            var workData = new ExtractionWorkData
            {
                PowerPointPath = txtPowerPointPath.Text,
                OutputFolder = txtOutputFolder.Text
            };

            backgroundWorker.RunWorkerAsync(workData);
        }

        private void BackgroundWorker_DoWork(object sender, DoWorkEventArgs e)
        {
            var worker = sender as BackgroundWorker;
            var data = e.Argument as ExtractionWorkData;

            try
            {
                // Extract PowerPoint data
                worker.ReportProgress(10, "Extracting data from PowerPoint...");

                var extractor = new PowerPointExtractor();
                var extractResult = extractor.ExtractWorkInstruction(
                    data.PowerPointPath,
                    data.OutputFolder,
                    (progress, message) => worker.ReportProgress(progress, message)
                );

                worker.ReportProgress(100, $"Complete! Data extracted to: {extractResult.ExcelPath}");
                e.Result = new ExtractionResultWrapper
                {
                    Success = true,
                    ExcelPath = extractResult.ExcelPath
                };
            }
            catch (Exception ex)
            {
                e.Result = new ExtractionResultWrapper
                {
                    Success = false,
                    ErrorMessage = ex.Message
                };
            }
        }

        private void BackgroundWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            progressBar.Value = e.ProgressPercentage;
            lblStatus.Text = e.UserState?.ToString() ?? "Processing...";
            LogMessage(e.UserState?.ToString() ?? "");
        }

        private void BackgroundWorker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            SetUIEnabled(true);

            var result = e.Result as ExtractionResultWrapper;

            if (result != null && result.Success)
            {
                LogMessage(" Extraction completed successfully!", Color.Green);

                var message = $"Data extracted successfully!\n\nExcel file: {result.ExcelPath}";

                var openFiles = MessageBox.Show(
                    message + "\n\nWould you like to open the output folder?",
                    "Success",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Information
                );

                if (openFiles == DialogResult.Yes)
                {
                    System.Diagnostics.Process.Start("explorer.exe", txtOutputFolder.Text);
                }
            }
            else if (result != null && !result.Success)
            {
                LogMessage($" Error: {result.ErrorMessage}", Color.Red);
                MessageBox.Show($"An error occurred:\n\n{result.ErrorMessage}",
                    "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void SetUIEnabled(bool enabled)
        {
            btnSelectFile.Enabled = enabled;
            btnSelectOutputFolder.Enabled = enabled;
            btnExtract.Enabled = enabled;
            btnConfigureMapping.Enabled = enabled;
            btnManageTemplates.Enabled = enabled;
        }

        private void LogMessage(string message, Color? color = null)
        {
            if (txtLog.InvokeRequired)
            {
                txtLog.Invoke(new Action(() => LogMessage(message, color)));
                return;
            }

            txtLog.SelectionStart = txtLog.TextLength;
            txtLog.SelectionLength = 0;
            txtLog.SelectionColor = color ?? Color.Black;
            txtLog.AppendText($"[{DateTime.Now:HH:mm:ss}] {message}\n");
            txtLog.SelectionColor = txtLog.ForeColor;
            txtLog.ScrollToCaret();
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            LogMessage("Work Instruction Extractor ready.");
        }
    }

    // Helper classes
    public class ExtractionWorkData
    {
        public string PowerPointPath { get; set; }
        public string OutputFolder { get; set; }
    }

    public class ExtractionResultWrapper
    {
        public bool Success { get; set; }
        public string ExcelPath { get; set; }
        public string ErrorMessage { get; set; }
    }

}

-------------------------

using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using PowerPointApp = Microsoft.Office.Interop.PowerPoint.Application;
using Microsoft.Office.Interop.PowerPoint;
using Microsoft.Office.Core;
using OfficeOpenXml;

namespace WorkInstructionExtractor
{
    public class PowerPointExtractor
    {
        static PowerPointExtractor()
        {
            ExcelPackage.License.SetNonCommercialPersonal("<Diana>");
        }

        public ExtractionResult ExtractWorkInstruction(
            string pptxPath,
            string outputFolder,
            Action<int, string> progressCallback = null)
        {
            progressCallback?.Invoke(0, "Starting extraction...");

            // Create output folders
            string baseImagesFolder = Path.Combine(outputFolder, "BaseImages");
            string composedImagesFolder = Path.Combine(outputFolder, "ComposedImages");

            if (!Directory.Exists(baseImagesFolder))
                Directory.CreateDirectory(baseImagesFolder);
            if (!Directory.Exists(composedImagesFolder))
                Directory.CreateDirectory(composedImagesFolder);

            string headerExcel = Path.Combine(outputFolder, "HeaderData.xlsx");
            string tablesExcel = Path.Combine(outputFolder, "TablesData.xlsx");
            string finalExcel = Path.Combine(outputFolder, "Extracted_Data.xlsx");

            // STEP 1: Extract header data and images with C#
            progressCallback?.Invoke(10, "Extracting header data and images...");
            var (headerData, tocData) = ExtractHeadersAndImages(pptxPath, headerExcel, baseImagesFolder, composedImagesFolder, progressCallback);

            string wiNumber = headerData.FirstOrDefault()?["WI_Number"] ?? "";

            // STEP 2: Run Python script to extract tables (pass the single file, not folder)
            progressCallback?.Invoke(40, "Extracting table data with Python...");
            bool pythonSuccess = RunPythonScript(pptxPath, tablesExcel, progressCallback);

            if (!pythonSuccess)
            {
                progressCallback?.Invoke(100, " Warning: Table extraction failed. Only header data and images extracted.");
            }
            else
            {
                // STEP 3: Merge the data
                progressCallback?.Invoke(80, "Merging data into final Excel file...");
                MergeExcelFiles(headerExcel, tablesExcel, finalExcel);

                // Clean up intermediate files
                try
                {
                    File.Delete(headerExcel);
                    File.Delete(tablesExcel);
                }
                catch { }

                progressCallback?.Invoke(100, "Extraction complete!");
            }

            return new ExtractionResult
            {
                ExcelPath = finalExcel,
                BaseImagesFolder = baseImagesFolder,
                ComposedImagesFolder = composedImagesFolder,
                WINumber = wiNumber
            };
        }

        private (List<Dictionary<string, string>> headerData, List<Dictionary<string, string>> tocData) ExtractHeadersAndImages(
            string filePath, string excelPath, string baseImagesFolder, string composedImagesFolder, Action<int, string> progressCallback)
        {
            var headerData = new List<Dictionary<string, string>>();
            var imageData = new List<Dictionary<string, string>>();
            var textData = new List<Dictionary<string, string>>();
            var tocData = new List<Dictionary<string, string>>();

            PowerPointApp pptApp = new PowerPointApp();
            int docCounter = 1;

            try
            {
                progressCallback?.Invoke(15, $"Opening PowerPoint file...");

                Presentation ppt = pptApp.Presentations.Open(filePath,
                    MsoTriState.msoFalse,
                    MsoTriState.msoFalse,
                    MsoTriState.msoFalse);

                if (ppt.Slides.Count > 0)
                {
                    progressCallback?.Invoke(20, "Extracting header data...");

                    Slide firstSlide = ppt.Slides[1];

                    var data = new Dictionary<string, string>();
                    data["DocumentID"] = docCounter.ToString();
                    data["SourceFileName"] = Path.GetFileName(filePath);

                    var allTextBoxes = new List<TextBoxInfo>();

                    CollectTextBoxes(firstSlide.Shapes, allTextBoxes);
                    try { CollectTextBoxes(firstSlide.Master.Shapes, allTextBoxes); } catch { }
                    try { CollectTextBoxes(firstSlide.Design.SlideMaster.Shapes, allTextBoxes); } catch { }
                    try { CollectTextBoxes(firstSlide.CustomLayout.Shapes, allTextBoxes); } catch { }

                    
                    int totalPages = ppt.Slides.Count;
                    data["TotalPages"] = totalPages.ToString();

                    progressCallback?.Invoke(25, "Extracting images...");

                    var images = ExtractImagesFromPresentation(ppt, docCounter, GetValue(data, "WI_Number"),
                        Path.GetFileName(filePath), baseImagesFolder, composedImagesFolder);
                    imageData.AddRange(images);

                    data["TotalImages"] = images.Count.ToString();

                    progressCallback?.Invoke(30, "Extracting text content...");

                    var slideTexts = ExtractTextFromSlides(ppt, docCounter, GetValue(data, "WI_Number"),
                        Path.GetFileName(filePath));
                    textData.AddRange(slideTexts);

                    progressCallback?.Invoke(33, "Building table of contents...");

                    var tocEntries = ExtractTableOfContents(ppt, docCounter, GetValue(data, "WI_Number"),
                        Path.GetFileName(filePath));
                    tocData.AddRange(tocEntries);

                    // Extract subject from TOC if available
                    if (tocEntries.Count > 0 && string.IsNullOrEmpty(GetValue(data, "Subject")))
                    {
                        data["Subject"] = tocEntries[0]["SlideSubject"];
                    }

                    headerData.Add(data);

                    progressCallback?.Invoke(35, $"Extracted: {GetValue(data, "WI_Number")}");
                }

                ppt.Close();
            }
            finally
            {
                pptApp.Quit();
            }

            WriteToExcel(headerData, imageData, textData, tocData, excelPath);

            return (headerData, tocData);
        }
               
        private void ExtractDataWithPatterns(List<TextBoxInfo> textBoxes, Dictionary<string, string> data)
        {
            // Pattern-based extraction that doesn't rely on position
            foreach (var box in textBoxes)
            {
                string text = box.Text.Trim();
                string upperText = text.ToUpper();

                // Extract WI Number (pattern-based, position-independent)
                if (string.IsNullOrEmpty(GetValue(data, "WI_Number")))
                {
                    var wiMatch = System.Text.RegularExpressions.Regex.Match(text,
                        @"W\.?I\.?\s*-?\s*\d+",
                        System.Text.RegularExpressions.RegexOptions.IgnoreCase);

                    if (wiMatch.Success)
                    {
                        string wiNum = wiMatch.Value.Replace(" ", "").Replace(".", "");
                        if (!wiNum.Contains("-"))
                            wiNum = wiNum.Replace("WI", "WI-");
                        data["WI_Number"] = wiNum.ToUpper();
                    }
                }

                // Extract Revision (pattern-based)
                if (string.IsNullOrEmpty(GetValue(data, "Revision")))
                {
                    // Skip labels
                    if (upperText == "REV" || upperText == "REV:" || upperText == "REVISION:")
                        continue;

                    // Look for single/double digit revisions
                    if (text.Length >= 1 && text.Length <= 3 &&
                        System.Text.RegularExpressions.Regex.IsMatch(text, @"^[0-9]+$"))
                    {
                        // This could be a revision number - only set if not already set
                        if (string.IsNullOrEmpty(GetValue(data, "Revision")))
                        {
                            data["Revision"] = text;
                        }
                    }
                }

                // Extract Template Revision (pattern-based)
                if (upperText.Contains("FM-ME") || upperText.Contains("FM ME") || upperText.Contains("FMME"))
                {
                    var revMatch = System.Text.RegularExpressions.Regex.Match(text,
                        @"FM-?[\s]?ME-?\d+.*?rev\.?\s*(\d+)",
                        System.Text.RegularExpressions.RegexOptions.IgnoreCase);

                    if (revMatch.Success && revMatch.Groups.Count > 1)
                    {
                        data["RevisionType"] = revMatch.Groups[1].Value;
                    }
                }
            }
        }

        private List<Dictionary<string, string>> ExtractTextFromSlides(Presentation ppt, int docId, string wiNumber, string sourceFileName)
        {
            var textData = new List<Dictionary<string, string>>();

            for (int slideIdx = 2; slideIdx <= ppt.Slides.Count; slideIdx++)
            {
                try
                {
                    Slide slide = ppt.Slides[slideIdx];
                    string slideSubject = ExtractSlideSubject(slide);
                    int textBoxCounter = 1;

                    foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Shapes)
                    {
                        // Skip tables - we don't want to extract table data as text
                        if (shape.HasTable == MsoTriState.msoTrue)
                        {
                            continue;
                        }

                        string extractedText = ExtractTextFromShape(shape);
                        if (!string.IsNullOrWhiteSpace(extractedText))
                        {
                            // IMPORTANT: Skip if this text IS the slide subject (avoid duplication)
                            string normalizedExtracted = extractedText.Trim().ToUpper();
                            string normalizedSubject = slideSubject.Trim().ToUpper();

                            if (normalizedExtracted == normalizedSubject)
                            {
                                // This is the slide title/subject - skip it
                                continue;
                            }

                            textData.Add(new Dictionary<string, string>
                            {
                                ["DocumentID"] = docId.ToString(),
                                ["WI_Number"] = wiNumber,
                                ["SourceFileName"] = sourceFileName,
                                ["SlideNumber"] = slideIdx.ToString(),
                                ["SlideSubject"] = slideSubject,
                                ["TextBoxNumber"] = textBoxCounter.ToString(),
                                ["TextContent"] = extractedText.Trim()
                            });

                            textBoxCounter++;
                        }
                    }
                }
                catch { }
            }

            return textData;
        }

        private string ExtractSlideSubject(Slide slide)
        {
            try
            {
                // Method 1: Check for title placeholder
                foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Shapes)
                {
                    try
                    {
                        if (shape.Type == MsoShapeType.msoPlaceholder)
                        {
                            var placeholder = shape.PlaceholderFormat;
                            if (placeholder.Type == PpPlaceholderType.ppPlaceholderTitle ||
                                placeholder.Type == PpPlaceholderType.ppPlaceholderCenterTitle)
                            {
                                if (shape.HasTextFrame == MsoTriState.msoTrue)
                                {
                                    string titleText = shape.TextFrame.TextRange.Text.Trim();
                                    if (!string.IsNullOrWhiteSpace(titleText))
                                    {
                                        return titleText.ToUpper();
                                    }
                                }
                            }
                        }
                    }
                    catch { }
                }

                // Method 2: Find largest font at top of slide
                var topShapes = new List<(string text, float top, float fontSize)>();

                foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Shapes)
                {
                    try
                    {
                        if (shape.HasTextFrame == MsoTriState.msoTrue)
                        {
                            string text = shape.TextFrame.TextRange.Text.Trim();
                            if (!string.IsNullOrWhiteSpace(text) && text.Length < 100)
                            {
                                float fontSize = 12;
                                try { fontSize = shape.TextFrame.TextRange.Font.Size; } catch { }

                                if (shape.Top < 100)
                                {
                                    topShapes.Add((text, shape.Top, fontSize));
                                }
                            }
                        }
                    }
                    catch { }
                }

                if (topShapes.Count > 0)
                {
                    var largestFont = topShapes.OrderByDescending(s => s.fontSize).ThenBy(s => s.top).First();
                    return largestFont.text.ToUpper();
                }

                return "UNTITLED SLIDE";
            }
            catch
            {
                return "UNTITLED SLIDE";
            }
        }

        private string ExtractTextFromShape(Microsoft.Office.Interop.PowerPoint.Shape shape)
        {
            var text = new System.Text.StringBuilder();

            try
            {
                if (shape.Type == MsoShapeType.msoGroup)
                {
                    foreach (Microsoft.Office.Interop.PowerPoint.Shape groupShape in shape.GroupItems)
                    {
                        string groupText = ExtractTextFromShape(groupShape);
                        if (!string.IsNullOrWhiteSpace(groupText))
                        {
                            text.AppendLine(groupText);
                        }
                    }
                }
                else if (shape.HasTextFrame == MsoTriState.msoTrue)
                {
                    try
                    {
                        string shapeText = shape.TextFrame.TextRange.Text;
                        if (!string.IsNullOrWhiteSpace(shapeText))
                        {
                            text.AppendLine(shapeText.Trim());
                        }
                    }
                    catch { }
                }
            }
            catch { }

            return text.ToString().Trim();
        }

        private List<Dictionary<string, string>> ExtractTableOfContents(Presentation ppt, int docId, string wiNumber, string sourceFileName)
        {
            var tocData = new List<Dictionary<string, string>>();

            string currentSubject = null;
            int subjectStartSlide = 0;
            int slideCount = 0;

            for (int slideIdx = 1; slideIdx <= ppt.Slides.Count; slideIdx++)
            {
                try
                {
                    Slide slide = ppt.Slides[slideIdx];
                    string slideSubject = ExtractSlideSubject(slide);

                    // Convert to uppercase
                    slideSubject = slideSubject.ToUpper();

                    // Check if subject changed or if it's a new subject
                    if (currentSubject == null)
                    {
                        // First slide
                        currentSubject = slideSubject;
                        subjectStartSlide = slideIdx;
                        slideCount = 1;
                    }
                    else if (slideSubject == currentSubject)
                    {
                        // Same subject continues
                        slideCount++;
                    }
                    else
                    {
                        // Subject changed - save the previous subject entry
                        tocData.Add(new Dictionary<string, string>
                        {
                            ["DocumentID"] = docId.ToString(),
                            ["WI_Number"] = wiNumber,
                            ["SourceFileName"] = sourceFileName,
                            ["SlideNumber"] = subjectStartSlide.ToString(),
                            ["SlideSubject"] = currentSubject,
                            ["SlideTotal"] = slideCount.ToString()
                        });

                        // Start tracking new subject
                        currentSubject = slideSubject;
                        subjectStartSlide = slideIdx;
                        slideCount = 1;
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error processing slide {slideIdx} for TOC: {ex.Message}");
                }
            }

            // Don't forget to add the last subject
            if (currentSubject != null)
            {
                tocData.Add(new Dictionary<string, string>
                {
                    ["DocumentID"] = docId.ToString(),
                    ["WI_Number"] = wiNumber,
                    ["SourceFileName"] = sourceFileName,
                    ["SlideNumber"] = subjectStartSlide.ToString(),
                    ["SlideSubject"] = currentSubject,
                    ["SlideTotal"] = slideCount.ToString()
                });
            }

            return tocData;
        }

        private List<Dictionary<string, string>> ExtractImagesFromPresentation(Presentation ppt, int docId,
            string wiNumber, string sourceFileName, string baseImagesFolder, string composedImagesFolder)
        {
            var imageData = new List<Dictionary<string, string>>();
            int imageCounter = 1;

            string cleanWiNumber = wiNumber;
            if (wiNumber.StartsWith("WI-WI-"))
            {
                cleanWiNumber = wiNumber.Substring(3);
            }

            string docFolderName = !string.IsNullOrEmpty(cleanWiNumber) ? cleanWiNumber : $"Doc-{docId}";
            docFolderName = MakeValidFolderName(docFolderName);

            string baseDocFolder = Path.Combine(baseImagesFolder, docFolderName);
            string composedDocFolder = Path.Combine(composedImagesFolder, docFolderName);

            if (!Directory.Exists(baseDocFolder))
                Directory.CreateDirectory(baseDocFolder);
            if (!Directory.Exists(composedDocFolder))
                Directory.CreateDirectory(composedDocFolder);

            for (int slideIdx = 1; slideIdx <= ppt.Slides.Count; slideIdx++)
            {
                Slide slide = ppt.Slides[slideIdx];

                foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Shapes)
                {
                    try
                    {
                        if (shape.Type == MsoShapeType.msoPicture)
                        {
                            string imageFileName = $"{cleanWiNumber}_Slide{slideIdx:D2}_Img{imageCounter:D2}.png";
                            string imagePath = Path.Combine(baseDocFolder, imageFileName);

                            ExportShape(shape, imagePath);

                            imageData.Add(new Dictionary<string, string>
                            {
                                ["DocumentID"] = docId.ToString(),
                                ["WI_Number"] = cleanWiNumber,
                                ["SourceFileName"] = sourceFileName,
                                ["SlideNumber"] = slideIdx.ToString(),
                                ["ImageNumber"] = imageCounter.ToString(),
                                ["ImageType"] = "Base",
                                ["ImageFileName"] = imageFileName,
                                ["ImagePath"] = Path.Combine(docFolderName, imageFileName),
                                ["IsGrouped"] = "No",
                                ["Width"] = shape.Width.ToString("F2"),
                                ["Height"] = shape.Height.ToString("F2")
                            });

                            imageCounter++;
                        }
                        else if (shape.Type == MsoShapeType.msoGroup)
                        {
                            bool hasImages = ContainsPictures(shape.GroupItems);

                            if (hasImages)
                            {
                                string composedFileName = $"{cleanWiNumber}_Slide{slideIdx:D2}_Composed{imageCounter:D2}.png";
                                string composedPath = Path.Combine(composedDocFolder, composedFileName);

                                ExportShape(shape, composedPath);

                                imageData.Add(new Dictionary<string, string>
                                {
                                    ["DocumentID"] = docId.ToString(),
                                    ["WI_Number"] = cleanWiNumber,
                                    ["SourceFileName"] = sourceFileName,
                                    ["SlideNumber"] = slideIdx.ToString(),
                                    ["ImageNumber"] = imageCounter.ToString(),
                                    ["ImageType"] = "Composed",
                                    ["ImageFileName"] = composedFileName,
                                    ["ImagePath"] = Path.Combine(docFolderName, composedFileName),
                                    ["IsGrouped"] = "Yes",
                                    ["Width"] = shape.Width.ToString("F2"),
                                    ["Height"] = shape.Height.ToString("F2")
                                });

                                ExtractImagesFromGroup(shape.GroupItems, docId, cleanWiNumber, sourceFileName,
                                    slideIdx, ref imageCounter, baseDocFolder, docFolderName, imageData);

                                imageCounter++;
                            }
                        }
                    }
                    catch { }
                }
            }

            return imageData;
        }

        private void ExtractImagesFromGroup(Microsoft.Office.Interop.PowerPoint.GroupShapes groupShapes, int docId,
            string wiNumber, string sourceFileName, int slideIdx, ref int imageCounter,
            string baseDocFolder, string docFolderName, List<Dictionary<string, string>> imageData)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in groupShapes)
            {
                try
                {
                    if (shape.Type == MsoShapeType.msoPicture)
                    {
                        string imageFileName = $"{wiNumber}_Slide{slideIdx:D2}_Img{imageCounter:D2}_FromGroup.png";
                        string imagePath = Path.Combine(baseDocFolder, imageFileName);

                        ExportShape(shape, imagePath);

                        imageData.Add(new Dictionary<string, string>
                        {
                            ["DocumentID"] = docId.ToString(),
                            ["WI_Number"] = wiNumber,
                            ["SourceFileName"] = sourceFileName,
                            ["SlideNumber"] = slideIdx.ToString(),
                            ["ImageNumber"] = imageCounter.ToString(),
                            ["ImageType"] = "Base",
                            ["ImageFileName"] = imageFileName,
                            ["ImagePath"] = Path.Combine(docFolderName, imageFileName),
                            ["IsGrouped"] = "Yes (Extracted)",
                            ["Width"] = shape.Width.ToString("F2"),
                            ["Height"] = shape.Height.ToString("F2")
                        });

                        imageCounter++;
                    }
                    else if (shape.Type == MsoShapeType.msoGroup)
                    {
                        ExtractImagesFromGroup(shape.GroupItems, docId, wiNumber, sourceFileName,
                            slideIdx, ref imageCounter, baseDocFolder, docFolderName, imageData);
                    }
                }
                catch { }
            }
        }

        private bool ContainsPictures(Microsoft.Office.Interop.PowerPoint.GroupShapes groupShapes)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in groupShapes)
            {
                if (shape.Type == MsoShapeType.msoPicture)
                    return true;
                if (shape.Type == MsoShapeType.msoGroup && ContainsPictures(shape.GroupItems))
                    return true;
            }
            return false;
        }

        private void ExportShape(Microsoft.Office.Interop.PowerPoint.Shape shape, string outputPath)
        {
            try
            {
                shape.Export(outputPath, PpShapeFormat.ppShapeFormatPNG);
            }
            catch
            {
                try
                {
                    shape.Copy();
                    var img = System.Windows.Forms.Clipboard.GetImage();
                    if (img != null)
                    {
                        img.Save(outputPath, ImageFormat.Png);
                    }
                }
                catch { }
            }
        }

        private string MakeValidFolderName(string name)
        {
            char[] invalidChars = Path.GetInvalidFileNameChars();
            foreach (char c in invalidChars)
            {
                name = name.Replace(c, '_');
            }
            return name;
        }

        private bool RunPythonScript(string pptxFilePath, string outputExcel, Action<int, string> progressCallback)
        {
            try
            {
                progressCallback?.Invoke(45, "Looking for Python...");
                string pythonExe = FindPythonExecutable();

                if (string.IsNullOrEmpty(pythonExe))
                {
                    progressCallback?.Invoke(50, "Python not found");
                    return false;
                }

                string scriptPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "extract_tables.py");

                if (!File.Exists(scriptPath))
                {
                    progressCallback?.Invoke(50, $"Python script not found: extract_tables.py");
                    return false;
                }

                // Create a temporary folder with just this one file
                string tempFolder = Path.Combine(Path.GetTempPath(), "TempWI_" + Guid.NewGuid().ToString());
                Directory.CreateDirectory(tempFolder);

                string tempFilePath = Path.Combine(tempFolder, Path.GetFileName(pptxFilePath));
                File.Copy(pptxFilePath, tempFilePath, true);

                string tempScript = CreateTempPythonScript(tempFolder, outputExcel, scriptPath);

                progressCallback?.Invoke(50, "Running Python script...");

                ProcessStartInfo start = new ProcessStartInfo();
                start.FileName = pythonExe;
                start.Arguments = $"\"{tempScript}\"";
                start.UseShellExecute = false;
                start.RedirectStandardOutput = true;
                start.RedirectStandardError = true;
                start.CreateNoWindow = true;

                using (Process process = Process.Start(start))
                {
                    string output = process.StandardOutput.ReadToEnd();
                    string errors = process.StandardError.ReadToEnd();

                    process.WaitForExit();

                    if (!string.IsNullOrEmpty(errors))
                    {
                        progressCallback?.Invoke(55, $"Python errors: {errors}");
                    }

                    // Clean up temp files
                    try
                    {
                        File.Delete(tempScript);
                        File.Delete(tempFilePath);
                        Directory.Delete(tempFolder);
                    }
                    catch { }

                    return process.ExitCode == 0 && File.Exists(outputExcel);
                }
            }
            catch (Exception ex)
            {
                progressCallback?.Invoke(50, $"Error running Python: {ex.Message}");
                return false;
            }
        }

        private string FindPythonExecutable()
        {
            string[] possiblePaths = new string[]
            {
            "python",
            "python3",
            @"C:\Python39\python.exe",
            @"C:\Python310\python.exe",
            @"C:\Python311\python.exe",
            @"C:\Python313\python.exe",
            @"C:\Users\" + Environment.UserName + @"\AppData\Local\Programs\Python\Python39\python.exe",
            @"C:\Users\" + Environment.UserName + @"\AppData\Local\Programs\Python\Python310\python.exe",
            @"C:\Users\" + Environment.UserName + @"\AppData\Local\Programs\Python\Python311\python.exe",
            @"C:\Users\" + Environment.UserName + @"\AppData\Local\Programs\Python\Python313\python.exe"
            };

            foreach (string path in possiblePaths)
            {
                try
                {
                    ProcessStartInfo psi = new ProcessStartInfo();
                    psi.FileName = path;
                    psi.Arguments = "--version";
                    psi.UseShellExecute = false;
                    psi.RedirectStandardOutput = true;
                    psi.CreateNoWindow = true;

                    using (Process process = Process.Start(psi))
                    {
                        process.WaitForExit();
                        if (process.ExitCode == 0)
                        {
                            return path;
                        }
                    }
                }
                catch
                {
                    continue;
                }
            }

            return null;
        }

        private string CreateTempPythonScript(string inputFolder, string outputExcel, string originalScript)
        {
            string scriptContent = File.ReadAllText(originalScript);

            scriptContent = System.Text.RegularExpressions.Regex.Replace(
                scriptContent,
                @"input_folder = r"".*?""",
                $"input_folder = r\"{inputFolder}\""
            );

            scriptContent = System.Text.RegularExpressions.Regex.Replace(
                scriptContent,
                @"output_excel = r"".*?""",
                $"output_excel = r\"{outputExcel}\""
            );

            string tempScript = Path.Combine(Path.GetTempPath(), "temp_extract_tables.py");
            File.WriteAllText(tempScript, scriptContent);

            return tempScript;
        }

        private void MergeExcelFiles(string headerFile, string tablesFile, string outputFile)
        {
            using (var headerPackage = new ExcelPackage(new FileInfo(headerFile)))
            using (var tablesPackage = new ExcelPackage(new FileInfo(tablesFile)))
            using (var outputPackage = new ExcelPackage())
            {
                // Copy sheets from header file in correct order
                // Sheet 0: Header Data
                if (headerPackage.Workbook.Worksheets.Count > 0)
                {
                    var headerSheet = headerPackage.Workbook.Worksheets[0];
                    outputPackage.Workbook.Worksheets.Add("Header Data", headerSheet);
                }

                // Sheet 1: Images
                if (headerPackage.Workbook.Worksheets.Count > 1)
                {
                    var imagesSheet = headerPackage.Workbook.Worksheets[1];
                    outputPackage.Workbook.Worksheets.Add("Images", imagesSheet);
                }

                // Sheet 2: Table of Contents
                if (headerPackage.Workbook.Worksheets.Count > 2)
                {
                    var tocSheet = headerPackage.Workbook.Worksheets[2];
                    outputPackage.Workbook.Worksheets.Add("Table of Contents", tocSheet);
                }

                // Sheet 3: Text Content
                if (headerPackage.Workbook.Worksheets.Count > 3)
                {
                    var textSheet = headerPackage.Workbook.Worksheets[3];
                    outputPackage.Workbook.Worksheets.Add("Text Content", textSheet);
                }

                // Copy all sheets from tables file (BOM, Equipment, Parts, etc.)
                foreach (var sheet in tablesPackage.Workbook.Worksheets)
                {
                    outputPackage.Workbook.Worksheets.Add(sheet.Name, sheet);
                }

                FileInfo outputFileInfo = new FileInfo(outputFile);
                outputPackage.SaveAs(outputFileInfo);
            }
        }

        private void CollectTextBoxes(Microsoft.Office.Interop.PowerPoint.Shapes shapes, List<TextBoxInfo> textBoxes)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in shapes)
            {
                if (shape.Type == MsoShapeType.msoGroup)
                {
                    CollectTextBoxesFromGroup(shape.GroupItems, textBoxes);
                }
                else if (shape.HasTextFrame == MsoTriState.msoTrue)
                {
                    string text = shape.TextFrame.TextRange.Text.Trim();
                    if (!string.IsNullOrEmpty(text))
                    {
                        textBoxes.Add(new TextBoxInfo
                        {
                            Text = text,
                            Left = shape.Left,
                            Top = shape.Top,
                            Width = shape.Width,
                            Height = shape.Height
                        });
                    }
                }
            }
        }

        private void CollectTextBoxesFromGroup(Microsoft.Office.Interop.PowerPoint.GroupShapes groupShapes, List<TextBoxInfo> textBoxes)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in groupShapes)
            {
                if (shape.Type == MsoShapeType.msoGroup)
                {
                    CollectTextBoxesFromGroup(shape.GroupItems, textBoxes);
                }
                else if (shape.HasTextFrame == MsoTriState.msoTrue)
                {
                    string text = shape.TextFrame.TextRange.Text.Trim();
                    if (!string.IsNullOrEmpty(text))
                    {
                        textBoxes.Add(new TextBoxInfo
                        {
                            Text = text,
                            Left = shape.Left,
                            Top = shape.Top,
                            Width = shape.Width,
                            Height = shape.Height
                        });
                    }
                }
            }
        }

        private void ExtractData(List<TextBoxInfo> textBoxes, Dictionary<string, string> data, Presentation ppt)
        {
            foreach (var box in textBoxes)
            {
                string text = box.Text.Trim();
                string upperText = text.ToUpper();

                // Extract WI Number
                if (string.IsNullOrEmpty(GetValue(data, "WI_Number")))
                {
                    var wiMatch = System.Text.RegularExpressions.Regex.Match(text,
                        @"W\.?I\.?\s*-?\s*\d+",
                        System.Text.RegularExpressions.RegexOptions.IgnoreCase);

                    if (wiMatch.Success)
                    {
                        string wiNum = wiMatch.Value.Replace(" ", "").Replace(".", "");
                        if (!wiNum.Contains("-"))
                            wiNum = wiNum.Replace("WI", "WI-");
                        data["WI_Number"] = wiNum.ToUpper();
                    }
                }

                // Extract Title
                if (string.IsNullOrEmpty(GetValue(data, "WI_Title")))
                {
                    bool isLabel = upperText == "WORK INSTRUCTION TITLE" ||
                                  upperText == "WORK INSTRUCTION" ||
                                  upperText == "DESCRIPTION:" ||
                                  upperText.Contains("W.I. NUMBER") ||
                                  upperText.Contains("BOM") && upperText.Contains("DWG") ||
                                  upperText.Contains("OPS") && upperText.Contains("OPTIONAL") ||
                                  upperText.Contains("OPERATION NO") ||
                                  upperText == "PRODUCT LINE" ||
                                  upperText == "SUBJECT" ||
                                  upperText == "SUBJECT:" ||
                                  upperText == "PAGE" ||
                                  upperText == "REV" ||
                                  upperText.Contains("COMPANY") && upperText.Length > 20 ||
                                  upperText.Contains("FM-ME") ||
                                  upperText.Contains("TRAINING RECORD") ||
                                  upperText.Contains("REVISION HISTORY") ||
                                  upperText.Contains("NOTICE") ||
                                  upperText.Contains("STATEMENT") ||
                                  (text.EndsWith(":") && text.Length < 20);

                    if (isLabel) continue;

                    bool isRev17_19Title = (box.Left > 100 && box.Left < 110 && box.Top > 455 && box.Top < 470);
                    bool isRev15_16Title = (box.Left > 20 && box.Left < 80 && box.Top > 515 && box.Top < 525);

                    if ((isRev17_19Title || isRev15_16Title) && text.Length > 3 && text.Length < 100)
                    {
                        data["WI_Title"] = text;
                    }
                }

                // Extract Revision
                if (string.IsNullOrEmpty(GetValue(data, "Revision")))
                {
                    if (upperText == "REV" || upperText == "REV:" || upperText == "REVISION:")
                        continue;

                    bool isRev17_19Rev = (box.Left > 665 && box.Left < 680 && box.Top > 460 && box.Top < 470);
                    bool isRev15_16Rev = (box.Left > 595 && box.Left < 620 && box.Top > 555 && box.Top < 565);

                    if ((isRev17_19Rev || isRev15_16Rev) &&
                        text.Length >= 1 && text.Length <= 3 &&
                        System.Text.RegularExpressions.Regex.IsMatch(text, @"^[0-9]+$"))
                    {
                        data["Revision"] = text;
                    }
                }

                // Extract BOM/ASSY DWG NO
                if (string.IsNullOrEmpty(GetValue(data, "BOM_ASSY_DWG_NO")))
                {
                    if ((upperText.Contains("BOM") || upperText.Contains("ASSY") || upperText.Contains("DWG")) &&
                        upperText.Contains("NO"))
                        continue;

                    bool isRev17_19BOM = (box.Left > 0 && box.Left < 20 && box.Top > 498 && box.Top < 505);
                    bool isRev15_16BOM = (box.Left > 300 && box.Left < 315 && box.Top > 558 && box.Top < 565);

                    if ((isRev17_19BOM || isRev15_16BOM) &&
                        text.Length > 1 && text.Length < 50 &&
                        !text.StartsWith("WI-") && !text.StartsWith("W.I."))
                    {
                        data["BOM_ASSY_DWG_NO"] = text;
                    }
                }

                // Extract Operation Number
                if (string.IsNullOrEmpty(GetValue(data, "Operation_No")))
                {
                    if ((upperText.Contains("OPERATION") && upperText.Contains("NO")) ||
                        upperText == "OPS (OPTIONAL)" || upperText == "OPERATION NO.")
                        continue;

                    bool isRev17_19Ops = (box.Left > 140 && box.Left < 155 && box.Top > 498 && box.Top < 505);
                    bool isRev15_16Ops = (box.Left > 185 && box.Left < 195 && box.Top > 555 && box.Top < 565);

                    if ((isRev17_19Ops || isRev15_16Ops) && text.Length > 1 && text.Length < 40)
                    {
                        data["Operation_No"] = text;
                    }
                }

                // Extract Product Line
                if (string.IsNullOrEmpty(GetValue(data, "Product_Line")))
                {
                    if (upperText == "PRODUCT LINE")
                        continue;

                    bool isRev17_19PL = (box.Left > 210 && box.Left < 230 && box.Top > 498 && box.Top < 505);
                    bool isRev15_16PL = (box.Left > 460 && box.Left < 515 && box.Top > 555 && box.Top < 565);

                    if ((isRev17_19PL || isRev15_16PL) &&
                        text.Length >= 2 && text.Length < 30 &&
                        !upperText.Contains("PAGE") &&
                        System.Text.RegularExpressions.Regex.IsMatch(text, @"[A-Z0-9]"))
                    {
                        data["Product_Line"] = text;
                    }
                }

                // Extract Subject
                if (string.IsNullOrEmpty(GetValue(data, "Subject")))
                {
                    if (upperText == "SUBJECT" ||
                        upperText == "SUBJECT:" ||
                        upperText.Contains("COMPANY") ||
                        System.Text.RegularExpressions.Regex.IsMatch(text, @"^\<?#?\>?\s*OF\s*\d+$", System.Text.RegularExpressions.RegexOptions.IgnoreCase))
                        continue;

                    bool isRev15_16Subject = (box.Left > 420 && box.Left < 430 && box.Top > 520 && box.Top < 525);

                    bool isRev17_19Subject = (box.Top > 495 && box.Top < 510) &&
                                             (box.Left > 315 && box.Left < 640) &&
                                             (box.Height > 10 && box.Height < 30) &&
                                             (box.Width > 200 && box.Width < 400) &&
                                             text.Length > 2 &&
                                             text.Length < 60 &&
                                             text != GetValue(data, "WI_Number") &&
                                             text != GetValue(data, "WI_Title") &&
                                             text != GetValue(data, "Product_Line") &&
                                             text != GetValue(data, "Operation_No") &&
                                             text != GetValue(data, "BOM_ASSY_DWG_NO");

                    if (isRev15_16Subject || isRev17_19Subject)
                    {
                        data["Subject"] = text;
                    }
                }

                // Extract Template Revision
                if (upperText.Contains("FM-ME") || upperText.Contains("FM ME") || upperText.Contains("FMME"))
                {
                    var revMatch = System.Text.RegularExpressions.Regex.Match(text,
                        @"FM-?[\s]?ME-?\d+.*?rev\.?\s*(\d+)",
                        System.Text.RegularExpressions.RegexOptions.IgnoreCase);

                    if (revMatch.Success && revMatch.Groups.Count > 1)
                    {
                        data["RevisionType"] = revMatch.Groups[1].Value;
                    }
                }
            }
        }

        private string GetValue(Dictionary<string, string> dict, string key)
        {
            return dict.ContainsKey(key) ? dict[key] : "";
        }

        private void WriteToExcel(List<Dictionary<string, string>> headerData,
            List<Dictionary<string, string>> imageData,
            List<Dictionary<string, string>> textData,
            List<Dictionary<string, string>> tocData,
            string excelPath)
        {
            if (File.Exists(excelPath))
                File.Delete(excelPath);

            using (var package = new ExcelPackage())
            {
                // Header Data sheet
                var worksheet = package.Workbook.Worksheets.Add("Header Data");

                var headers = new string[] {
                "Document ID", "Source File Name", "WI Number", "WI Title", "Revision",
                "BOM/ASSY DWG NO", "Operation No", "Product Line", "Subject", "Revision Type",
                "Total Pages", "Total Images"
            };

                for (int i = 0; i < headers.Length; i++)
                {
                    worksheet.Cells[1, i + 1].Value = headers[i];
                }

                using (var range = worksheet.Cells[1, 1, 1, headers.Length])
                {
                    range.Style.Font.Bold = true;
                    range.Style.Fill.PatternType = OfficeOpenXml.Style.ExcelFillStyle.Solid;
                    range.Style.Fill.BackgroundColor.SetColor(System.Drawing.Color.LightGray);
                    range.Style.HorizontalAlignment = OfficeOpenXml.Style.ExcelHorizontalAlignment.Center;
                }

                int row = 2;
                foreach (var record in headerData)
                {
                    worksheet.Cells[row, 1].Value = GetValue(record, "DocumentID");
                    worksheet.Cells[row, 2].Value = GetValue(record, "SourceFileName");
                    worksheet.Cells[row, 3].Value = GetValue(record, "WI_Number");
                    worksheet.Cells[row, 4].Value = GetValue(record, "WI_Title");
                    worksheet.Cells[row, 5].Value = GetValue(record, "Revision");
                    worksheet.Cells[row, 6].Value = GetValue(record, "BOM_ASSY_DWG_NO");
                    worksheet.Cells[row, 7].Value = GetValue(record, "Operation_No");
                    worksheet.Cells[row, 8].Value = GetValue(record, "Product_Line");
                    worksheet.Cells[row, 9].Value = GetValue(record, "Subject");
                    worksheet.Cells[row, 10].Value = GetValue(record, "RevisionType");
                    worksheet.Cells[row, 11].Value = GetValue(record, "TotalPages");
                    worksheet.Cells[row, 12].Value = GetValue(record, "TotalImages");
                    row++;
                }

                worksheet.Cells[worksheet.Dimension.Address].AutoFitColumns();

                // Images sheet
                if (imageData.Count > 0)
                {
                    var imgWorksheet = package.Workbook.Worksheets.Add("Images");

                    var imgHeaders = new string[] {
                    "Document ID", "WI Number", "Source File Name", "Slide Number", "Image Number",
                    "Image Type", "Image File Name", "Image Path", "Is Grouped", "Width", "Height"
                };

                    for (int i = 0; i < imgHeaders.Length; i++)
                    {
                        imgWorksheet.Cells[1, i + 1].Value = imgHeaders[i];
                    }

                    using (var range = imgWorksheet.Cells[1, 1, 1, imgHeaders.Length])
                    {
                        range.Style.Font.Bold = true;
                        range.Style.Fill.PatternType = OfficeOpenXml.Style.ExcelFillStyle.Solid;
                        range.Style.Fill.BackgroundColor.SetColor(System.Drawing.Color.LightGray);
                        range.Style.HorizontalAlignment = OfficeOpenXml.Style.ExcelHorizontalAlignment.Center;
                    }

                    row = 2;
                    foreach (var img in imageData)
                    {
                        imgWorksheet.Cells[row, 1].Value = GetValue(img, "DocumentID");
                        imgWorksheet.Cells[row, 2].Value = GetValue(img, "WI_Number");
                        imgWorksheet.Cells[row, 3].Value = GetValue(img, "SourceFileName");
                        imgWorksheet.Cells[row, 4].Value = GetValue(img, "SlideNumber");
                        imgWorksheet.Cells[row, 5].Value = GetValue(img, "ImageNumber");
                        imgWorksheet.Cells[row, 6].Value = GetValue(img, "ImageType");
                        imgWorksheet.Cells[row, 7].Value = GetValue(img, "ImageFileName");
                        imgWorksheet.Cells[row, 8].Value = GetValue(img, "ImagePath");
                        imgWorksheet.Cells[row, 9].Value = GetValue(img, "IsGrouped");
                        imgWorksheet.Cells[row, 10].Value = GetValue(img, "Width");
                        imgWorksheet.Cells[row, 11].Value = GetValue(img, "Height");
                        row++;
                    }

                    imgWorksheet.Cells[imgWorksheet.Dimension.Address].AutoFitColumns();
                }

                // Table of Contents sheet
                if (tocData.Count > 0)
                {
                    var tocWorksheet = package.Workbook.Worksheets.Add("Table of Contents");

                    var tocHeaders = new string[] {
                    "Document ID", "WI Number", "Source File Name", "Slide Number",
                    "Slide Subject", "Slide Total"
                };

                    for (int i = 0; i < tocHeaders.Length; i++)
                    {
                        tocWorksheet.Cells[1, i + 1].Value = tocHeaders[i];
                    }

                    using (var range = tocWorksheet.Cells[1, 1, 1, tocHeaders.Length])
                    {
                        range.Style.Font.Bold = true;
                        range.Style.Fill.PatternType = OfficeOpenXml.Style.ExcelFillStyle.Solid;
                        range.Style.Fill.BackgroundColor.SetColor(System.Drawing.Color.LightGray);
                        range.Style.HorizontalAlignment = OfficeOpenXml.Style.ExcelHorizontalAlignment.Center;
                    }

                    row = 2;
                    foreach (var toc in tocData)
                    {
                        tocWorksheet.Cells[row, 1].Value = GetValue(toc, "DocumentID");
                        tocWorksheet.Cells[row, 2].Value = GetValue(toc, "WI_Number");
                        tocWorksheet.Cells[row, 3].Value = GetValue(toc, "SourceFileName");
                        tocWorksheet.Cells[row, 4].Value = GetValue(toc, "SlideNumber");
                        tocWorksheet.Cells[row, 5].Value = GetValue(toc, "SlideSubject");
                        tocWorksheet.Cells[row, 6].Value = GetValue(toc, "SlideTotal");
                        row++;
                    }

                    tocWorksheet.Cells[tocWorksheet.Dimension.Address].AutoFitColumns();
                }

                // Text Content sheet
                if (textData.Count > 0)
                {
                    var textWorksheet = package.Workbook.Worksheets.Add("Text Content");

                    var textHeaders = new string[] {
                    "Document ID", "WI Number", "Source File Name", "Slide Number",
                    "Slide Subject", "TextBox Number", "Text Content"
                };

                    for (int i = 0; i < textHeaders.Length; i++)
                    {
                        textWorksheet.Cells[1, i + 1].Value = textHeaders[i];
                    }

                    using (var range = textWorksheet.Cells[1, 1, 1, textHeaders.Length])
                    {
                        range.Style.Font.Bold = true;
                        range.Style.Fill.PatternType = OfficeOpenXml.Style.ExcelFillStyle.Solid;
                        range.Style.Fill.BackgroundColor.SetColor(System.Drawing.Color.LightGray);
                        range.Style.HorizontalAlignment = OfficeOpenXml.Style.ExcelHorizontalAlignment.Center;
                    }

                    row = 2;
                    foreach (var txt in textData)
                    {
                        textWorksheet.Cells[row, 1].Value = GetValue(txt, "DocumentID");
                        textWorksheet.Cells[row, 2].Value = GetValue(txt, "WI_Number");
                        textWorksheet.Cells[row, 3].Value = GetValue(txt, "SourceFileName");
                        textWorksheet.Cells[row, 4].Value = GetValue(txt, "SlideNumber");
                        textWorksheet.Cells[row, 5].Value = GetValue(txt, "SlideSubject");
                        textWorksheet.Cells[row, 6].Value = GetValue(txt, "TextBoxNumber");
                        textWorksheet.Cells[row, 7].Value = GetValue(txt, "TextContent");

                        textWorksheet.Cells[row, 7].Style.WrapText = true;

                        row++;
                    }

                    textWorksheet.Column(7).Width = 80;
                    textWorksheet.Cells[textWorksheet.Dimension.Address].AutoFitColumns();
                }

                FileInfo fileInfo = new FileInfo(excelPath);
                package.SaveAs(fileInfo);
            }
        }
    }

    // Helper classes
    public class ExtractionResult
    {
        public string ExcelPath { get; set; } = string.Empty;
        public string BaseImagesFolder { get; set; } = string.Empty;
        public string ComposedImagesFolder { get; set; } = string.Empty;
        public string WINumber { get; set; } = string.Empty;
    }

    public class TextBoxInfo
    {
        public string Text { get; set; } = string.Empty;
        public float Left { get; set; }
        public float Top { get; set; }
        public float Width { get; set; }
        public float Height { get; set; }
    }

}





