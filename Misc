Good call! Position-based extraction is actually more reliable when you know the template formats. Let me create a cleaner approach that detects the revision type first, then uses position-based extraction:

```csharp
/// <summary>
/// Extract all header fields using position-based extraction with revision detection
/// </summary>
private void ExtractData(List<TextBoxInfo> textBoxes, Dictionary<string, string> data)
{
    // Initialize all fields
    data["WI_Number"] = "";
    data["WI_Title"] = "";
    data["Revision"] = "";
    data["BOM_ASSY_DWG_NO"] = "";
    data["Operation_No"] = "";
    data["Product_Line"] = "";
    data["Subject"] = "";
    data["RevisionType"] = "";

    // First, detect the revision type from FM-ME text
    string revisionType = DetectRevisionType(textBoxes);
    data["RevisionType"] = revisionType;

    Console.WriteLine($"Detected Revision Type: {revisionType}");

    // Extract based on revision type
    if (revisionType == "15" || revisionType == "16")
    {
        ExtractRev15_16(textBoxes, data);
    }
    else if (revisionType == "17" || revisionType == "18" || revisionType == "19")
    {
        ExtractRev17_19(textBoxes, data);
    }
    else
    {
        // Unknown revision - try pattern-based as fallback
        Console.WriteLine("Unknown revision type - using pattern-based extraction");
        ExtractWithPatterns(textBoxes, data);
    }
}

/// <summary>
/// Detect revision type from FM-ME text box
/// </summary>
private string DetectRevisionType(List<TextBoxInfo> textBoxes)
{
    foreach (var box in textBoxes)
    {
        string upper = box.Text.ToUpper();
        if (upper.Contains("FM-ME") || upper.Contains("FM ME") || upper.Contains("FMME"))
        {
            var match = System.Text.RegularExpressions.Regex.Match(box.Text,
                @"rev\.?\s*(\d+)",
                System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            
            if (match.Success && match.Groups.Count > 1)
            {
                return match.Groups[1].Value;
            }
        }
    }
    return "Unknown";
}

/// <summary>
/// Extract fields for Rev 15-16 templates (Slide format 5:4, needs conversion to 4:3)
/// Position ranges are approximate and may need adjustment
/// </summary>
private void ExtractRev15_16(List<TextBoxInfo> textBoxes, Dictionary<string, string> data)
{
    Console.WriteLine("Using Rev 15-16 extraction logic");

    foreach (var box in textBoxes)
    {
        string text = box.Text.Trim();
        string upper = text.ToUpper();

        // Skip labels
        if (IsLabel(upper) || string.IsNullOrWhiteSpace(text)) continue;

        Console.WriteLine($"Rev15-16: Text='{text}', Left={box.Left:F1}, Top={box.Top:F1}");

        // WI Number - pattern based (consistent across all revs)
        if (string.IsNullOrEmpty(data["WI_Number"]))
        {
            var wiMatch = System.Text.RegularExpressions.Regex.Match(text,
                @"W\.?\s*I\.?\s*-?\s*\d{2,}",
                System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            if (wiMatch.Success)
            {
                string wiNum = wiMatch.Value.Replace(" ", "").Replace(".", "").ToUpper();
                if (!wiNum.Contains("-"))
                    wiNum = wiNum.Replace("WI", "WI-");
                data["WI_Number"] = wiNum;
                Console.WriteLine($"  -> WI_Number: {wiNum}");
                continue;
            }
        }

        // WI Title - Rev 15/16: Left 20-80, Top 515-525
        if (string.IsNullOrEmpty(data["WI_Title"]))
        {
            if (box.Left > 20 && box.Left < 80 && box.Top > 510 && box.Top < 530 &&
                text.Length > 10 && text.Length < 150)
            {
                data["WI_Title"] = text;
                Console.WriteLine($"  -> WI_Title: {text}");
                continue;
            }
        }

        // Revision - Rev 15/16: Left 595-620, Top 555-565, 1-2 digits
        if (string.IsNullOrEmpty(data["Revision"]))
        {
            if (box.Left > 590 && box.Left < 625 && box.Top > 550 && box.Top < 570 &&
                System.Text.RegularExpressions.Regex.IsMatch(text, @"^\d{1,2}$"))
            {
                data["Revision"] = text;
                Console.WriteLine($"  -> Revision: {text}");
                continue;
            }
        }

        // BOM/ASSY DWG NO - Rev 15/16: Left 300-315, Top 558-565
        if (string.IsNullOrEmpty(data["BOM_ASSY_DWG_NO"]))
        {
            if (box.Left > 295 && box.Left < 320 && box.Top > 555 && box.Top < 568 &&
                text.Length > 2 && text.Length < 50 &&
                !text.StartsWith("WI", StringComparison.OrdinalIgnoreCase))
            {
                data["BOM_ASSY_DWG_NO"] = text;
                Console.WriteLine($"  -> BOM_ASSY_DWG_NO: {text}");
                continue;
            }
        }

        // Operation No - Rev 15/16: Left 185-195, Top 555-565
        if (string.IsNullOrEmpty(data["Operation_No"]))
        {
            if (box.Left > 180 && box.Left < 200 && box.Top > 550 && box.Top < 570 &&
                text.Length > 1 && text.Length < 40)
            {
                data["Operation_No"] = text;
                Console.WriteLine($"  -> Operation_No: {text}");
                continue;
            }
        }

        // Product Line - Rev 15/16: Left 460-515, Top 555-565
        if (string.IsNullOrEmpty(data["Product_Line"]))
        {
            if (box.Left > 455 && box.Left < 520 && box.Top > 550 && box.Top < 570 &&
                text.Length >= 2 && text.Length < 30 &&
                !upper.Contains("PAGE"))
            {
                data["Product_Line"] = text;
                Console.WriteLine($"  -> Product_Line: {text}");
                continue;
            }
        }

        // Subject - Rev 15/16: Left 420-430, Top 520-525
        if (string.IsNullOrEmpty(data["Subject"]))
        {
            if (box.Left > 415 && box.Left < 435 && box.Top > 515 && box.Top < 530 &&
                text.Length > 5 && text.Length < 80 &&
                !upper.Contains("COMPANY") &&
                text != data["WI_Title"])
            {
                data["Subject"] = text;
                Console.WriteLine($"  -> Subject: {text}");
                continue;
            }
        }
    }

    // Fallback: if Subject is still empty, try pattern-based
    if (string.IsNullOrEmpty(data["Subject"]))
    {
        foreach (var box in textBoxes)
        {
            string text = box.Text.Trim();
            string upper = text.ToUpper();
            
            if (text.Length > 5 && text.Length < 80 &&
                !IsLabel(upper) &&
                !upper.Contains("COMPANY") &&
                !upper.Contains("PAGE") &&
                text != data["WI_Title"] &&
                text != data["WI_Number"] &&
                text != data["BOM_ASSY_DWG_NO"])
            {
                data["Subject"] = text;
                Console.WriteLine($"  -> Subject (fallback): {text}");
                break;
            }
        }
    }
}

/// <summary>
/// Extract fields for Rev 17-19 templates (Slide format 4:3)
/// </summary>
private void ExtractRev17_19(List<TextBoxInfo> textBoxes, Dictionary<string, string> data)
{
    Console.WriteLine("Using Rev 17-19 extraction logic");

    foreach (var box in textBoxes)
    {
        string text = box.Text.Trim();
        string upper = text.ToUpper();

        // Skip labels
        if (IsLabel(upper) || string.IsNullOrWhiteSpace(text)) continue;

        Console.WriteLine($"Rev17-19: Text='{text}', Left={box.Left:F1}, Top={box.Top:F1}");

        // WI Number - pattern based (consistent across all revs)
        if (string.IsNullOrEmpty(data["WI_Number"]))
        {
            var wiMatch = System.Text.RegularExpressions.Regex.Match(text,
                @"W\.?\s*I\.?\s*-?\s*\d{2,}",
                System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            if (wiMatch.Success)
            {
                string wiNum = wiMatch.Value.Replace(" ", "").Replace(".", "").ToUpper();
                if (!wiNum.Contains("-"))
                    wiNum = wiNum.Replace("WI", "WI-");
                data["WI_Number"] = wiNum;
                Console.WriteLine($"  -> WI_Number: {wiNum}");
                continue;
            }
        }

        // WI Title - Rev 17/19: Left 100-110, Top 455-470
        if (string.IsNullOrEmpty(data["WI_Title"]))
        {
            if (box.Left > 95 && box.Left < 115 && box.Top > 450 && box.Top < 475 &&
                text.Length > 10 && text.Length < 150)
            {
                data["WI_Title"] = text;
                Console.WriteLine($"  -> WI_Title: {text}");
                continue;
            }
        }

        // Revision - Rev 17/19: Left 665-680, Top 460-470, 1-2 digits
        if (string.IsNullOrEmpty(data["Revision"]))
        {
            if (box.Left > 660 && box.Left < 685 && box.Top > 455 && box.Top < 475 &&
                System.Text.RegularExpressions.Regex.IsMatch(text, @"^\d{1,2}$"))
            {
                data["Revision"] = text;
                Console.WriteLine($"  -> Revision: {text}");
                continue;
            }
        }

        // BOM/ASSY DWG NO - Rev 17/19: Left 0-20, Top 498-505
        if (string.IsNullOrEmpty(data["BOM_ASSY_DWG_NO"]))
        {
            if (box.Left > -5 && box.Left < 25 && box.Top > 493 && box.Top < 510 &&
                text.Length > 2 && text.Length < 50 &&
                !text.StartsWith("WI", StringComparison.OrdinalIgnoreCase))
            {
                data["BOM_ASSY_DWG_NO"] = text;
                Console.WriteLine($"  -> BOM_ASSY_DWG_NO: {text}");
                continue;
            }
        }

        // Operation No - Rev 17/19: Left 140-155, Top 498-505
        if (string.IsNullOrEmpty(data["Operation_No"]))
        {
            if (box.Left > 135 && box.Left < 160 && box.Top > 493 && box.Top < 510 &&
                text.Length > 1 && text.Length < 40)
            {
                data["Operation_No"] = text;
                Console.WriteLine($"  -> Operation_No: {text}");
                continue;
            }
        }

        // Product Line - Rev 17/19: Left 210-230, Top 498-505
        if (string.IsNullOrEmpty(data["Product_Line"]))
        {
            if (box.Left > 205 && box.Left < 235 && box.Top > 493 && box.Top < 510 &&
                text.Length >= 2 && text.Length < 30 &&
                !upper.Contains("PAGE"))
            {
                data["Product_Line"] = text;
                Console.WriteLine($"  -> Product_Line: {text}");
                continue;
            }
        }

        // Subject - Rev 17/19: Left 315-640, Top 495-510
        if (string.IsNullOrEmpty(data["Subject"]))
        {
            if (box.Left > 310 && box.Left < 645 && box.Top > 490 && box.Top < 515 &&
                text.Length > 5 && text.Length < 80 &&
                !upper.Contains("COMPANY") &&
                text != data["WI_Title"])
            {
                data["Subject"] = text;
                Console.WriteLine($"  -> Subject: {text}");
                continue;
            }
        }
    }

    // Fallback: if Subject is still empty, try pattern-based
    if (string.IsNullOrEmpty(data["Subject"]))
    {
        foreach (var box in textBoxes)
        {
            string text = box.Text.Trim();
            string upper = text.ToUpper();
            
            if (text.Length > 5 && text.Length < 80 &&
                !IsLabel(upper) &&
                !upper.Contains("COMPANY") &&
                !upper.Contains("PAGE") &&
                text != data["WI_Title"] &&
                text != data["WI_Number"] &&
                text != data["BOM_ASSY_DWG_NO"])
            {
                data["Subject"] = text;
                Console.WriteLine($"  -> Subject (fallback): {text}");
                break;
            }
        }
    }
}

/// <summary>
/// Fallback pattern-based extraction for unknown revisions
/// </summary>
private void ExtractWithPatterns(List<TextBoxInfo> textBoxes, Dictionary<string, string> data)
{
    // WI Number
    foreach (var box in textBoxes)
    {
        if (string.IsNullOrEmpty(data["WI_Number"]))
        {
            var wiMatch = System.Text.RegularExpressions.Regex.Match(box.Text,
                @"W\.?\s*I\.?\s*-?\s*\d{2,}",
                System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            if (wiMatch.Success)
            {
                string wiNum = wiMatch.Value.Replace(" ", "").Replace(".", "").ToUpper();
                if (!wiNum.Contains("-"))
                    wiNum = wiNum.Replace("WI", "WI-");
                data["WI_Number"] = wiNum;
            }
        }
    }

    // Simple pattern-based extraction for other fields
    foreach (var box in textBoxes)
    {
        string text = box.Text.Trim();
        string upper = text.ToUpper();

        if (IsLabel(upper) || string.IsNullOrWhiteSpace(text)) continue;

        // Revision
        if (string.IsNullOrEmpty(data["Revision"]) &&
            System.Text.RegularExpressions.Regex.IsMatch(text, @"^\d{1,2}$"))
        {
            data["Revision"] = text;
        }

        // Title - longer text
        if (string.IsNullOrEmpty(data["WI_Title"]) &&
            text.Length > 15 && text.Length < 150)
        {
            data["WI_Title"] = text;
        }

        // Subject - medium text
        if (string.IsNullOrEmpty(data["Subject"]) &&
            text.Length > 5 && text.Length < 80 &&
            text != data["WI_Title"])
        {
            data["Subject"] = text;
        }
    }
}
```

Now for the output file name, change this in the `ExtractWorkInstruction` method:

```csharp
public ExtractionResult ExtractWorkInstruction(
    string pptxPath,
    string outputFolder,
    Action<int, string> progressCallback = null)
{
    progressCallback?.Invoke(0, "Starting extraction...");

    // Create output folders
    string baseImagesFolder = Path.Combine(outputFolder, "BaseImages");
    string composedImagesFolder = Path.Combine(outputFolder, "ComposedImages");
    Directory.CreateDirectory(baseImagesFolder);
    Directory.CreateDirectory(composedImagesFolder);

    string headerExcel = Path.Combine(outputFolder, "HeaderData.xlsx");
    string tablesExcel = Path.Combine(outputFolder, "TablesData.xlsx");
    string finalExcel = Path.Combine(outputFolder, "ExtractedData.xlsx");  // CHANGED THIS LINE

    // ... rest of the method stays the same
```

Test this with your Rev 16 file and let me know:

1. What the console output shows for the detected positions
1. Which fields are still incorrect
1. Whether the slide format is 5:4 or 4:3 (we may need to adjust coordinates)

We can fine-tune the position ranges based on your actual files!​​​​​​​​​​​​​​​​