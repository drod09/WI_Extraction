program.cs
using System;
using System.Windows.Forms;

namespace WorkInstructionExtractor
{
    static class Program
    {
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new MainForm());
        }
    }
}
-------

WorkInstructionExtractor.cs
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Wordprocessing;
using DocumentFormat.OpenXml;
using ClosedXML.Excel;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using A = DocumentFormat.OpenXml.Drawing;
using DW = DocumentFormat.OpenXml.Drawing.Wordprocessing;
using PIC = DocumentFormat.OpenXml.Drawing.Pictures;
using W = DocumentFormat.OpenXml.Wordprocessing;

namespace WorkInstructionExtractor
{
    public class WorkInstructionData
    {
        // Header data
        public string WINumber { get; set; } = string.Empty;
        public string Title { get; set; } = string.Empty;
        public string Revision { get; set; } = string.Empty;
        public string BomAssyDwgNo { get; set; } = string.Empty;
        public string OperationNo { get; set; } = string.Empty;
        public string ProductLine { get; set; } = string.Empty;
        public string Subject { get; set; } = string.Empty;

        // Tables
        public List<Dictionary<string, string>> BomTable { get; set; } = new List<Dictionary<string, string>>();
        public List<Dictionary<string, string>> EquipmentRequired { get; set; } = new List<Dictionary<string, string>>();
        public List<Dictionary<string, string>> PartsRequired { get; set; } = new List<Dictionary<string, string>>();
        public List<Dictionary<string, string>> RevisionHistory { get; set; } = new List<Dictionary<string, string>>();
        public List<Dictionary<string, string>> DraftingSignatures { get; set; } = new List<Dictionary<string, string>>();
        public List<Dictionary<string, string>> Approvals { get; set; } = new List<Dictionary<string, string>>();

        // Content slides data
        public List<SlideContent> ContentSlides { get; set; } = new List<SlideContent>();

        // Image paths
        public string? FrontPageImagePath { get; set; }
        public Dictionary<int, string> SlideImages { get; set; } = new Dictionary<int, string>();
    }

    public class SlideContent
    {
        public int SlideNumber { get; set; }
        public string SlideTitle { get; set; } = string.Empty;
        public string TextContent { get; set; } = string.Empty;
        public string? ImagePath { get; set; }
    }

    public class WordTemplatePopulator
    {
        public static void PopulateTemplate(string templatePath, string outputPath, WorkInstructionData data)
        {
            // Copy template to output location
            File.Copy(templatePath, outputPath, true);

            using (WordprocessingDocument doc = WordprocessingDocument.Open(outputPath, true))
            {
                var body = doc.MainDocumentPart?.Document?.Body;
                if (body == null) return;

                // Populate header/footer data
                PopulateHeaderFooter(doc, data);

                // Populate Page 1 tables
                PopulatePage1Tables(body, data);

                // Insert front page image
                if (!string.IsNullOrEmpty(data.FrontPageImagePath) && File.Exists(data.FrontPageImagePath))
                {
                    InsertFrontPageImage(doc, body, data.FrontPageImagePath);
                }

                // Populate content slides (Page 2)
                PopulateContentSlides(doc, body, data);

                doc.Save();
            }
        }

        private static void PopulateHeaderFooter(WordprocessingDocument doc, WorkInstructionData data)
        {
            if (doc.MainDocumentPart == null) return;

            // Update all header parts
            foreach (var headerPart in doc.MainDocumentPart.HeaderParts)
            {
                ReplaceTextInPart(headerPart.Header, "[WI_NUMBER]", data.WINumber);
                ReplaceTextInPart(headerPart.Header, "[TITLE]", data.Title);
            }

            // Update all footer parts
            foreach (var footerPart in doc.MainDocumentPart.FooterParts)
            {
                var footer = footerPart.Footer;
                ReplaceTextInPart(footer, "[WI_NUMBER]", data.WINumber);
                ReplaceTextInPart(footer, "[TITLE]", data.Title);
                ReplaceTextInPart(footer, "[REVISION]", data.Revision);
                ReplaceTextInPart(footer, "[BOM_ASSY]", data.BomAssyDwgNo);
                ReplaceTextInPart(footer, "[OPERATION]", data.OperationNo);
                ReplaceTextInPart(footer, "[PRODUCT_LINE]", data.ProductLine);
                ReplaceTextInPart(footer, "[SUBJECT]", data.Subject);
            }
        }

        private static void PopulatePage1Tables(W.Body body, WorkInstructionData data)
        {
            var tables = body.Elements<W.Table>().ToList();

            if (tables.Count == 0) return;

            // Table 0: Revision History (has 2-row header: title + columns)
            if (tables.Count > 0 && data.RevisionHistory != null && data.RevisionHistory.Count > 0)
            {
                PopulateTableWithTitleRow(tables[0], data.RevisionHistory);
            }

            // Table 1: BOM/Configuration (has 2-row header: title + columns)
            if (tables.Count > 1 && data.BomTable != null && data.BomTable.Count > 0)
            {
                PopulateTableWithTitleRow(tables[1], data.BomTable);
            }

            // Table 2: Drafting (fixed structure - don't populate)
            // Skip - this has fixed labels (Author, Updated by)

            // Table 3: Approvals (fixed structure - don't populate)
            // Skip - this has fixed labels (Mfg. Engineering, Operations, etc.)

            // Table 4: Equipment Required (has 2-row header: title + columns)
            if (tables.Count > 4 && data.EquipmentRequired != null && data.EquipmentRequired.Count > 0)
            {
                PopulateTableWithTitleRow(tables[4], data.EquipmentRequired);
            }

            // Table 5: Parts Required (has 2-row header: title + columns)
            if (tables.Count > 5 && data.PartsRequired != null && data.PartsRequired.Count > 0)
            {
                PopulateTableWithTitleRow(tables[5], data.PartsRequired);
            }

            // Tables 6-7: Training Logs (leave as-is)
        }

        private static void PopulateTableWithTitleRow(W.Table table, List<Dictionary<string, string>> data)
        {
            if (data == null || data.Count == 0) return;

            var rows = table.Elements<W.TableRow>().ToList();
            if (rows.Count < 3) return; // Need title row + column header + at least 1 data row

            // Row 0 is the title (e.g., "BOM / CONFIGURATION TABLE")
            // Row 1 is the column headers (e.g., "Part Number", "Description")
            // Row 2+ are data rows

            var columnHeaderRow = rows[1];
            var headerCells = columnHeaderRow.Elements<W.TableCell>().ToList();
            var columnNames = headerCells.Select(c => GetCellText(c).Trim()).ToList();

            // Get template row (row 2) for cloning
            var templateRow = rows[2];

            // Remove all data rows (keep title row 0 and column header row 1)
            for (int i = rows.Count - 1; i >= 2; i--)
            {
                rows[i].Remove();
            }

            // Add new rows with data
            foreach (var rowData in data)
            {
                var newRow = (W.TableRow)templateRow.CloneNode(true);
                var cells = newRow.Elements<W.TableCell>().ToList();

                for (int i = 0; i < cells.Count && i < columnNames.Count; i++)
                {
                    string columnName = columnNames[i];
                    if (rowData.ContainsKey(columnName))
                    {
                        SetCellText(cells[i], rowData[columnName]);
                    }
                    else
                    {
                        SetCellText(cells[i], "");
                    }
                }

                table.Append(newRow);
            }
        }

        private static void PopulateContentSlides(WordprocessingDocument doc, W.Body body, WorkInstructionData data)
        {
            if (data.ContentSlides == null || data.ContentSlides.Count == 0) return;

            // Find the "FOR REFERENCE ONLY" section (Page 3)
            int insertIndex = FindContentSlidesInsertionPoint(body);

            if (insertIndex == -1) return;

            foreach (var slide in data.ContentSlides.OrderBy(s => s.SlideNumber))
            {
                // Add page break before each slide (except first)
                if (slide.SlideNumber > data.ContentSlides.Min(s => s.SlideNumber))
                {
                    InsertPageBreak(body, insertIndex++);
                }

                // Add slide title
                var titlePara = CreateFormattedParagraph(slide.SlideTitle, true, 14);
                body.InsertAt(titlePara, insertIndex++);

                // Add text content
                if (!string.IsNullOrEmpty(slide.TextContent))
                {
                    var contentPara = CreateFormattedParagraph(slide.TextContent, false, 11);
                    body.InsertAt(contentPara, insertIndex++);
                }

                // Add image
                if (!string.IsNullOrEmpty(slide.ImagePath) && File.Exists(slide.ImagePath))
                {
                    var imagePara = InsertImage(doc, body, slide.ImagePath, insertIndex);
                    if (imagePara != null)
                    {
                        body.InsertAt(imagePara, insertIndex++);
                    }
                }

                // Add spacing
                body.InsertAt(new W.Paragraph(), insertIndex++);
            }
        }

        private static int FindContentSlidesInsertionPoint(W.Body body)
        {
            var elements = body.ChildElements.ToList();

            // Look for "FOR REFERENCE ONLY" text
            for (int i = 0; i < elements.Count; i++)
            {
                if (elements[i] is W.Paragraph para)
                {
                    string text = para.InnerText;
                    if (text.Contains("FOR REFERENCE ONLY"))
                    {
                        // Insert after this paragraph
                        return i + 1;
                    }
                }
            }

            // If not found, insert before last page (Training Log)
            // Look for page breaks and insert before the last one
            for (int i = elements.Count - 1; i >= 0; i--)
            {
                if (elements[i] is W.Paragraph para)
                {
                    if (para.Descendants<W.Break>().Any(b => b.Type != null && b.Type == BreakValues.Page))
                    {
                        return i;
                    }
                }
            }

            return -1;
        }

        private static void InsertFrontPageImage(WordprocessingDocument doc, W.Body body, string imagePath)
        {
            // Find the BOM table and insert image after it
            var tables = body.Elements<W.Table>().ToList();
            if (tables.Count == 0) return;

            var bomTable = tables[0];
            var insertionPoint = body.ChildElements.ToList().IndexOf(bomTable) + 1;

            var imagePara = InsertImage(doc, body, imagePath, insertionPoint);
            if (imagePara != null)
            {
                body.InsertAt(imagePara, insertionPoint);
            }
        }

        private static W.Paragraph? InsertImage(WordprocessingDocument doc, W.Body body, string imagePath, int index)
        {
            if (!File.Exists(imagePath) || doc.MainDocumentPart == null) return null;

            MainDocumentPart mainPart = doc.MainDocumentPart;

            // Determine image part type
            string extension = Path.GetExtension(imagePath).ToLower();
            ImagePart imagePart;

            switch (extension)
            {
                case ".png":
                    imagePart = mainPart.AddImagePart(ImagePartType.Png);
                    break;
                case ".jpg":
                case ".jpeg":
                    imagePart = mainPart.AddImagePart(ImagePartType.Jpeg);
                    break;
                case ".bmp":
                    imagePart = mainPart.AddImagePart(ImagePartType.Bmp);
                    break;
                case ".gif":
                    imagePart = mainPart.AddImagePart(ImagePartType.Gif);
                    break;
                default:
                    imagePart = mainPart.AddImagePart(ImagePartType.Png);
                    break;
            }

            using (FileStream stream = new FileStream(imagePath, FileMode.Open))
            {
                imagePart.FeedData(stream);
            }

            // Get image dimensions
            var (width, height) = GetImageDimensions(imagePath);

            // Scale to fit page width (landscape: ~14 inches = 9144000 EMUs)
            long maxWidth = 9144000;
            long maxHeight = 6858000;

            double scale = Math.Min((double)maxWidth / width, (double)maxHeight / height);
            if (scale > 1) scale = 1; // Don't enlarge

            long finalWidth = (long)(width * scale);
            long finalHeight = (long)(height * scale);

            string relationshipId = mainPart.GetIdOfPart(imagePart);

            var element = new W.Drawing(
                new DW.Inline(
                    new DW.Extent() { Cx = finalWidth, Cy = finalHeight },
                    new DW.EffectExtent() { LeftEdge = 0L, TopEdge = 0L, RightEdge = 0L, BottomEdge = 0L },
                    new DW.DocProperties() { Id = (UInt32Value)1U, Name = "Picture" },
                    new DW.NonVisualGraphicFrameDrawingProperties(
                        new A.GraphicFrameLocks() { NoChangeAspect = true }),
                    new A.Graphic(
                        new A.GraphicData(
                            new PIC.Picture(
                                new PIC.NonVisualPictureProperties(
                                    new PIC.NonVisualDrawingProperties() { Id = (UInt32Value)0U, Name = "Image" },
                                    new PIC.NonVisualPictureDrawingProperties()),
                                new PIC.BlipFill(
                                    new A.Blip() { Embed = relationshipId },
                                    new A.Stretch(new A.FillRectangle())),
                                new PIC.ShapeProperties(
                                    new A.Transform2D(
                                        new A.Offset() { X = 0L, Y = 0L },
                                        new A.Extents() { Cx = finalWidth, Cy = finalHeight }),
                                    new A.PresetGeometry(new A.AdjustValueList()) { Preset = A.ShapeTypeValues.Rectangle }))
                        )
                        { Uri = "http://schemas.openxmlformats.org/drawingml/2006/picture" })
                )
                { DistanceFromTop = (UInt32Value)0U, DistanceFromBottom = (UInt32Value)0U, DistanceFromLeft = (UInt32Value)0U, DistanceFromRight = (UInt32Value)0U }
            );

            return new W.Paragraph(new W.Run(element));
        }

        private static (long width, long height) GetImageDimensions(string imagePath)
        {
            try
            {
                using (var image = System.Drawing.Image.FromFile(imagePath))
                {
                    // Convert pixels to EMUs (914400 EMUs per inch, assuming 96 DPI)
                    long width = (long)(image.Width * 914400.0 / 96.0);
                    long height = (long)(image.Height * 914400.0 / 96.0);
                    return (width, height);
                }
            }
            catch
            {
                // Default size if image can't be read
                return (5486400, 4114800); // 6" x 4.5"
            }
        }

        private static W.Paragraph CreateFormattedParagraph(string text, bool isBold, int fontSize)
        {
            var run = new W.Run(new W.Text(text));
            var runProperties = new W.RunProperties();
            runProperties.Append(new W.RunFonts() { Ascii = "Arial", HighAnsi = "Arial" });
            runProperties.Append(new W.FontSize() { Val = (fontSize * 2).ToString() }); // Half-points

            if (isBold)
            {
                runProperties.Append(new W.Bold());
            }

            run.PrependChild(runProperties);

            return new W.Paragraph(run);
        }

        private static void InsertPageBreak(W.Body body, int index)
        {
            var para = new W.Paragraph(
                new W.Run(
                    new W.Break() { Type = BreakValues.Page }
                )
            );
            body.InsertAt(para, index);
        }

        private static void ReplaceTextInPart(OpenXmlElement element, string placeholder, string value)
        {
            foreach (var text in element.Descendants<W.Text>())
            {
                if (text.Text.Contains(placeholder))
                {
                    text.Text = text.Text.Replace(placeholder, value);
                }
            }
        }

        private static string GetCellText(W.TableCell cell)
        {
            return string.Join(" ", cell.Descendants<W.Text>().Select(t => t.Text));
        }

        private static void SetCellText(W.TableCell cell, string text)
        {
            var paragraph = cell.Elements<W.Paragraph>().FirstOrDefault();
            if (paragraph == null)
            {
                paragraph = new W.Paragraph();
                cell.Append(paragraph);
            }

            paragraph.RemoveAllChildren<W.Run>();
            paragraph.Append(new W.Run(new W.Text(text ?? "")));
        }

        // Method to load data from Excel file
        public static WorkInstructionData LoadFromExcel(string excelPath, string composedImagesFolder)
        {
            var data = new WorkInstructionData();

            using (var workbook = new XLWorkbook(excelPath))
            {
                // Load header data from "Header Data" sheet (note the space!)
                if (workbook.Worksheets.Contains("Header Data"))
                {
                    var headerSheet = workbook.Worksheet("Header Data");
                    var rows = headerSheet.RowsUsed().ToList();

                    if (rows.Count > 1) // Need at least header + 1 data row
                    {
                        var dataRow = rows[1]; // Second row contains data

                        // Read based on column positions
                        data.WINumber = dataRow.Cell(3).GetString(); // Column C: WI Number
                        data.Title = dataRow.Cell(4).GetString(); // Column D: WI Title
                        data.Revision = dataRow.Cell(5).GetString(); // Column E: Revision
                        data.BomAssyDwgNo = dataRow.Cell(6).GetString(); // Column F: BOM/ASSY DWG NO
                        data.OperationNo = dataRow.Cell(7).GetString(); // Column G: Operation No
                        data.ProductLine = dataRow.Cell(8).GetString(); // Column H: Product Line
                        data.Subject = dataRow.Cell(9).GetString(); // Column I: Subject
                    }
                }

                // Load tables from Python-generated sheets
                LoadTableFromSheet(workbook, "BOM", data.BomTable);
                LoadTableFromSheet(workbook, "EquipmentRequired", data.EquipmentRequired);
                LoadTableFromSheet(workbook, "PartsRequired", data.PartsRequired);
                LoadTableFromSheet(workbook, "RevisionHistory", data.RevisionHistory);
                LoadTableFromSheet(workbook, "Drafting", data.DraftingSignatures);
                LoadTableFromSheet(workbook, "Approvals", data.Approvals);

                // Load content slides from "Text Content" sheet
                if (workbook.Worksheets.Contains("Text Content"))
                {
                    var slideSheet = workbook.Worksheet("Text Content");
                    var rows = slideSheet.RowsUsed().Skip(1); // Skip header

                    // Group by slide number to combine text boxes
                    var slideGroups = new Dictionary<int, List<string>>();
                    var slideTitles = new Dictionary<int, string>();

                    foreach (var row in rows)
                    {
                        var slideNumberStr = row.Cell(4).GetString(); // Column D: Slide Number
                        if (!int.TryParse(slideNumberStr, out int slideNumber))
                            continue;

                        var slideTitle = row.Cell(5).GetString(); // Column E: Slide Subject
                        var textContent = row.Cell(7).GetString(); // Column G: Text Content

                        if (!slideGroups.ContainsKey(slideNumber))
                        {
                            slideGroups[slideNumber] = new List<string>();
                            slideTitles[slideNumber] = slideTitle;
                        }

                        if (!string.IsNullOrWhiteSpace(textContent))
                        {
                            slideGroups[slideNumber].Add(textContent);
                        }
                    }

                    // Create slide content objects
                    foreach (var slideNum in slideGroups.Keys.OrderBy(k => k))
                    {
                        var slideContent = new SlideContent
                        {
                            SlideNumber = slideNum,
                            SlideTitle = slideTitles[slideNum],
                            TextContent = string.Join("\n\n", slideGroups[slideNum])
                        };

                        // Find corresponding composed image
                        string imageName = $"{data.WINumber}_Slide{slideNum:D2}_Composed01.png";
                        string imagePath = Path.Combine(composedImagesFolder, data.WINumber, imageName);

                        if (File.Exists(imagePath))
                        {
                            slideContent.ImagePath = imagePath;
                        }

                        data.ContentSlides.Add(slideContent);
                    }
                }

                // Set front page image
                string frontImagePath = Path.Combine(composedImagesFolder, data.WINumber, $"{data.WINumber}_Slide01_Composed01.png");
                if (File.Exists(frontImagePath))
                {
                    data.FrontPageImagePath = frontImagePath;
                }
            }

            return data;
        }

        private static void LoadTableFromSheet(XLWorkbook workbook, string sheetName, List<Dictionary<string, string>> targetList)
        {
            if (!workbook.Worksheets.Contains(sheetName)) return;

            var sheet = workbook.Worksheet(sheetName);
            var rows = sheet.RowsUsed().ToList();

            if (rows.Count < 2) return; // Need header + data

            // Get column names from first row
            var headerRow = rows[0];
            var columnNames = headerRow.Cells().Select(c => c.GetString()).ToList();

            // Read data rows
            foreach (var row in rows.Skip(1))
            {
                var rowData = new Dictionary<string, string>();
                var cells = row.Cells().ToList();

                for (int i = 0; i < cells.Count && i < columnNames.Count; i++)
                {
                    rowData[columnNames[i]] = cells[i].GetString();
                }

                targetList.Add(rowData);
            }
        }
    }
}
----------

WorkInstructionExtractor.csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>WinExe</OutputType> <!-- Changed from Exe to WinExe -->
		<TargetFramework>net8.0-windows</TargetFramework>
		<UseWindowsForms>true</UseWindowsForms>
	</PropertyGroup>

	<ItemGroup>
		<COMReference Include="Microsoft.Office.Interop.PowerPoint">
			<WrapperTool>tlbimp</WrapperTool>
			<VersionMinor>12</VersionMinor>
			<VersionMajor>2</VersionMajor>
			<Guid>91493440-5a91-11cf-8700-00aa0060263b</Guid>
			<Lcid>0</Lcid>
			<Isolated>false</Isolated>
			<EmbedInteropTypes>true</EmbedInteropTypes>
		</COMReference>
		<COMReference Include="Microsoft.Office.Core">
			<WrapperTool>tlbimp</WrapperTool>
			<VersionMinor>8</VersionMinor>
			<VersionMajor>2</VersionMajor>
			<Guid>2df8d04c-5bfa-101b-bde5-00aa0044de52</Guid>
			<Lcid>0</Lcid>
			<Isolated>false</Isolated>
			<EmbedInteropTypes>true</EmbedInteropTypes>
		</COMReference>
	</ItemGroup>

	<ItemGroup>
		<PackageReference Include="DocX" Version="5.0.0" />
		<PackageReference Include="EPPlus" Version="8.2.1" /> <!-- Add these new packages for Word template population -->
		<PackageReference Include="DocumentFormat.OpenXml" Version="2.20.0" />
		<PackageReference Include="ClosedXML" Version="0.102.0" />
		<PackageReference Include="System.Drawing.Common" Version="8.0.0" />
	</ItemGroup>

</Project>
-----------

MainForm
using System;
using System.IO;
using System.Windows.Forms;
using System.Drawing;
using System.ComponentModel;

namespace WorkInstructionExtractor
{
    public partial class MainForm : Form
    {
        private TextBox txtPowerPointPath;
        private TextBox txtWordTemplatePath;
        private TextBox txtOutputFolder;
        private Button btnBrowsePowerPoint;
        private Button btnBrowseTemplate;
        private Button btnBrowseOutput;
        private Button btnConvert;
        private ProgressBar progressBar;
        private RichTextBox txtLog;
        private CheckBox chkExtractOnly;
        private Label lblStatus;
        private BackgroundWorker backgroundWorker;

        public MainForm()
        {
            InitializeComponent();
            InitializeBackgroundWorker();
        }

        private void InitializeComponent()
        {
            this.Text = "Work Instruction Converter";
            this.Size = new Size(900, 700);
            this.StartPosition = FormStartPosition.CenterScreen;
            this.MinimumSize = new Size(800, 600);

            // Create main panel
            var mainPanel = new TableLayoutPanel
            {
                Dock = DockStyle.Fill,
                ColumnCount = 1,
                RowCount = 5,
                Padding = new Padding(20)
            };

            // Title Label
            var lblTitle = new Label
            {
                Text = "Work Instruction Converter",
                Font = new Font("Segoe UI", 16, FontStyle.Bold),
                Dock = DockStyle.Top,
                Height = 40,
                TextAlign = ContentAlignment.MiddleCenter
            };

            // Input Section
            var inputPanel = CreateInputSection();

            // Options Section
            var optionsPanel = CreateOptionsSection();

            // Action Section
            var actionPanel = CreateActionSection();

            // Log Section
            var logPanel = CreateLogSection();

            // Add all sections to main panel
            mainPanel.Controls.Add(lblTitle, 0, 0);
            mainPanel.Controls.Add(inputPanel, 0, 1);
            mainPanel.Controls.Add(optionsPanel, 0, 2);
            mainPanel.Controls.Add(actionPanel, 0, 3);
            mainPanel.Controls.Add(logPanel, 0, 4);

            mainPanel.RowStyles.Add(new RowStyle(SizeType.Absolute, 50));
            mainPanel.RowStyles.Add(new RowStyle(SizeType.Absolute, 150));
            mainPanel.RowStyles.Add(new RowStyle(SizeType.Absolute, 60));
            mainPanel.RowStyles.Add(new RowStyle(SizeType.Absolute, 100));
            mainPanel.RowStyles.Add(new RowStyle(SizeType.Percent, 100));

            this.Controls.Add(mainPanel);
        }

        private GroupBox CreateInputSection()
        {
            var panel = new GroupBox
            {
                Text = "Input Files",
                Dock = DockStyle.Fill,
                Padding = new Padding(10)
            };

            var layout = new TableLayoutPanel
            {
                Dock = DockStyle.Fill,
                ColumnCount = 3,
                RowCount = 3,
                Padding = new Padding(5)
            };

            // PowerPoint File
            var lblPowerPoint = new Label { Text = "PowerPoint File:", Dock = DockStyle.Fill, TextAlign = ContentAlignment.MiddleLeft };
            txtPowerPointPath = new TextBox { Dock = DockStyle.Fill, ReadOnly = true };
            btnBrowsePowerPoint = new Button { Text = "Browse...", Width = 100, Dock = DockStyle.Fill };
            btnBrowsePowerPoint.Click += BtnBrowsePowerPoint_Click;

            // Word Template
            var lblTemplate = new Label { Text = "Word Template:", Dock = DockStyle.Fill, TextAlign = ContentAlignment.MiddleLeft };
            txtWordTemplatePath = new TextBox { Dock = DockStyle.Fill, ReadOnly = true };
            btnBrowseTemplate = new Button { Text = "Browse...", Width = 100, Dock = DockStyle.Fill };
            btnBrowseTemplate.Click += BtnBrowseTemplate_Click;

            // Output Folder
            var lblOutput = new Label { Text = "Output Folder:", Dock = DockStyle.Fill, TextAlign = ContentAlignment.MiddleLeft };
            txtOutputFolder = new TextBox { Dock = DockStyle.Fill, ReadOnly = true };
            btnBrowseOutput = new Button { Text = "Browse...", Width = 100, Dock = DockStyle.Fill };
            btnBrowseOutput.Click += BtnBrowseOutput_Click;

            // Add controls to layout
            layout.Controls.Add(lblPowerPoint, 0, 0);
            layout.Controls.Add(txtPowerPointPath, 1, 0);
            layout.Controls.Add(btnBrowsePowerPoint, 2, 0);

            layout.Controls.Add(lblTemplate, 0, 1);
            layout.Controls.Add(txtWordTemplatePath, 1, 1);
            layout.Controls.Add(btnBrowseTemplate, 2, 1);

            layout.Controls.Add(lblOutput, 0, 2);
            layout.Controls.Add(txtOutputFolder, 1, 2);
            layout.Controls.Add(btnBrowseOutput, 2, 2);

            layout.ColumnStyles.Add(new ColumnStyle(SizeType.Absolute, 120));
            layout.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 100));
            layout.ColumnStyles.Add(new ColumnStyle(SizeType.Absolute, 100));

            panel.Controls.Add(layout);
            return panel;
        }

        private GroupBox CreateOptionsSection()
        {
            var panel = new GroupBox
            {
                Text = "Options",
                Dock = DockStyle.Fill,
                Padding = new Padding(10)
            };

            chkExtractOnly = new CheckBox
            {
                Text = "Extract data only (don't populate Word template)",
                AutoSize = true,
                Location = new Point(10, 25)
            };

            panel.Controls.Add(chkExtractOnly);
            return panel;
        }

        private Panel CreateActionSection()
        {
            var panel = new Panel { Dock = DockStyle.Fill };

            btnConvert = new Button
            {
                Text = "Convert Work Instruction",
                Size = new Size(200, 40),
                Location = new Point(10, 10),
                Font = new Font("Segoe UI", 10, FontStyle.Bold),
                BackColor = Color.FromArgb(0, 120, 215),
                ForeColor = Color.White,
                FlatStyle = FlatStyle.Flat
            };
            btnConvert.FlatAppearance.BorderSize = 0;
            btnConvert.Click += BtnConvert_Click;

            progressBar = new ProgressBar
            {
                Location = new Point(220, 15),
                Size = new Size(400, 30),
                Style = ProgressBarStyle.Continuous
            };

            lblStatus = new Label
            {
                Text = "Ready",
                Location = new Point(630, 20),
                Size = new Size(200, 20),
                Font = new Font("Segoe UI", 9)
            };

            panel.Controls.Add(btnConvert);
            panel.Controls.Add(progressBar);
            panel.Controls.Add(lblStatus);

            return panel;
        }

        private GroupBox CreateLogSection()
        {
            var panel = new GroupBox
            {
                Text = "Activity Log",
                Dock = DockStyle.Fill,
                Padding = new Padding(10)
            };

            txtLog = new RichTextBox
            {
                Dock = DockStyle.Fill,
                ReadOnly = true,
                Font = new Font("Consolas", 9),
                BackColor = Color.White
            };

            panel.Controls.Add(txtLog);
            return panel;
        }

        private void InitializeBackgroundWorker()
        {
            backgroundWorker = new BackgroundWorker
            {
                WorkerReportsProgress = true,
                WorkerSupportsCancellation = true
            };

            backgroundWorker.DoWork += BackgroundWorker_DoWork;
            backgroundWorker.ProgressChanged += BackgroundWorker_ProgressChanged;
            backgroundWorker.RunWorkerCompleted += BackgroundWorker_RunWorkerCompleted;
        }

        private void BtnBrowsePowerPoint_Click(object sender, EventArgs e)
        {
            using (var dialog = new OpenFileDialog())
            {
                dialog.Filter = "PowerPoint Files (*.pptx)|*.pptx|All Files (*.*)|*.*";
                dialog.Title = "Select PowerPoint Work Instruction";

                if (dialog.ShowDialog() == DialogResult.OK)
                {
                    txtPowerPointPath.Text = dialog.FileName;
                    LogMessage($"Selected PowerPoint: {Path.GetFileName(dialog.FileName)}");
                }
            }
        }

        private void BtnBrowseTemplate_Click(object sender, EventArgs e)
        {
            using (var dialog = new OpenFileDialog())
            {
                dialog.Filter = "Word Templates (*.docx;*.dotx)|*.docx;*.dotx|All Files (*.*)|*.*";
                dialog.Title = "Select Word Template";

                if (dialog.ShowDialog() == DialogResult.OK)
                {
                    txtWordTemplatePath.Text = dialog.FileName;
                    LogMessage($"Selected Template: {Path.GetFileName(dialog.FileName)}");
                }
            }
        }

        private void BtnBrowseOutput_Click(object sender, EventArgs e)
        {
            using (var dialog = new FolderBrowserDialog())
            {
                dialog.Description = "Select Output Folder";

                if (dialog.ShowDialog() == DialogResult.OK)
                {
                    txtOutputFolder.Text = dialog.SelectedPath;
                    LogMessage($"Output folder: {dialog.SelectedPath}");
                }
            }
        }

        private void BtnConvert_Click(object sender, EventArgs e)
        {
            // Validation
            if (string.IsNullOrWhiteSpace(txtPowerPointPath.Text))
            {
                MessageBox.Show("Please select a PowerPoint file.", "Validation Error",
                    MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            if (!chkExtractOnly.Checked && string.IsNullOrWhiteSpace(txtWordTemplatePath.Text))
            {
                MessageBox.Show("Please select a Word template.", "Validation Error",
                    MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            if (string.IsNullOrWhiteSpace(txtOutputFolder.Text))
            {
                MessageBox.Show("Please select an output folder.", "Validation Error",
                    MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            // Disable UI during processing
            SetUIEnabled(false);
            txtLog.Clear();
            progressBar.Value = 0;

            // Start background processing
            var workData = new ConversionWorkData
            {
                PowerPointPath = txtPowerPointPath.Text,
                TemplatePath = txtWordTemplatePath.Text,
                OutputFolder = txtOutputFolder.Text,
                ExtractOnly = chkExtractOnly.Checked
            };

            backgroundWorker.RunWorkerAsync(workData);
        }

        private void BackgroundWorker_DoWork(object sender, DoWorkEventArgs e)
        {
            var worker = sender as BackgroundWorker;
            var data = e.Argument as ConversionWorkData;

            try
            {
                // Step 1: Extract PowerPoint data
                worker.ReportProgress(10, "Extracting data from PowerPoint...");

                var extractor = new PowerPointExtractor();
                var extractResult = extractor.ExtractWorkInstruction(
                    data.PowerPointPath,
                    data.OutputFolder,
                    (progress, message) => worker.ReportProgress(progress, message)
                );

                if (!data.ExtractOnly)
                {
                    // Step 2: Populate Word template
                    worker.ReportProgress(60, "Loading extracted data...");

                    var populator = new WordTemplatePopulator();
                    var wiData = WordTemplatePopulator.LoadFromExcel(
                        extractResult.ExcelPath,
                        extractResult.ComposedImagesFolder
                    );

                    worker.ReportProgress(70, "Populating Word template...");

                    string outputWordPath = Path.Combine(
                        data.OutputFolder,
                        $"{wiData.WINumber}_WorkInstruction.docx"
                    );

                    WordTemplatePopulator.PopulateTemplate(
                        data.TemplatePath,
                        outputWordPath,
                        wiData
                    );

                    worker.ReportProgress(100, $"Complete! Word document saved: {outputWordPath}");
                    e.Result = new ConversionResult
                    {
                        Success = true,
                        ExcelPath = extractResult.ExcelPath,
                        WordPath = outputWordPath
                    };
                }
                else
                {
                    worker.ReportProgress(100, $"Complete! Data extracted to: {extractResult.ExcelPath}");
                    e.Result = new ConversionResult
                    {
                        Success = true,
                        ExcelPath = extractResult.ExcelPath
                    };
                }
            }
            catch (Exception ex)
            {
                e.Result = new ConversionResult
                {
                    Success = false,
                    ErrorMessage = ex.Message
                };
            }
        }

        private void BackgroundWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            progressBar.Value = e.ProgressPercentage;
            lblStatus.Text = e.UserState?.ToString() ?? "Processing...";
            LogMessage(e.UserState?.ToString() ?? "");
        }

        private void BackgroundWorker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            SetUIEnabled(true);

            var result = e.Result as ConversionResult;

            if (result != null && result.Success)
            {
                LogMessage("✓ Conversion completed successfully!", Color.Green);

                var message = chkExtractOnly.Checked
                    ? $"Data extracted successfully!\n\nExcel file: {result.ExcelPath}"
                    : $"Conversion completed successfully!\n\nExcel file: {result.ExcelPath}\nWord file: {result.WordPath}";

                var openFiles = MessageBox.Show(
                    message + "\n\nWould you like to open the output folder?",
                    "Success",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Information
                );

                if (openFiles == DialogResult.Yes)
                {
                    System.Diagnostics.Process.Start("explorer.exe", txtOutputFolder.Text);
                }
            }
            else if (result != null && !result.Success)
            {
                LogMessage($"✗ Error: {result.ErrorMessage}", Color.Red);
                MessageBox.Show($"An error occurred:\n\n{result.ErrorMessage}",
                    "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void SetUIEnabled(bool enabled)
        {
            btnBrowsePowerPoint.Enabled = enabled;
            btnBrowseTemplate.Enabled = enabled;
            btnBrowseOutput.Enabled = enabled;
            btnConvert.Enabled = enabled;
            chkExtractOnly.Enabled = enabled;
        }

        private void LogMessage(string message, Color? color = null)
        {
            if (txtLog.InvokeRequired)
            {
                txtLog.Invoke(new Action(() => LogMessage(message, color)));
                return;
            }

            txtLog.SelectionStart = txtLog.TextLength;
            txtLog.SelectionLength = 0;
            txtLog.SelectionColor = color ?? Color.Black;
            txtLog.AppendText($"[{DateTime.Now:HH:mm:ss}] {message}\n");
            txtLog.SelectionColor = txtLog.ForeColor;
            txtLog.ScrollToCaret();
        }
    }

    // Helper classes
    public class ConversionWorkData
    {
        public string PowerPointPath { get; set; }
        public string TemplatePath { get; set; }
        public string OutputFolder { get; set; }
        public bool ExtractOnly { get; set; }
    }

    public class ConversionResult
    {
        public bool Success { get; set; }
        public string ExcelPath { get; set; }
        public string WordPath { get; set; }
        public string ErrorMessage { get; set; }
    }
}
-----------

PowerPointExtractor 
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using Microsoft.Office.Interop.PowerPoint;
using Microsoft.Office.Core;
using OfficeOpenXml;

namespace WorkInstructionExtractor
{
    public class PowerPointExtractor
    {
        static PowerPointExtractor()
        {
            ExcelPackage.License.SetNonCommercialPersonal("Diana");
        }

        public ExtractionResult ExtractWorkInstruction(
            string pptxPath,
            string outputFolder,
            Action<int, string> progressCallback = null)
        {
            progressCallback?.Invoke(0, "Starting extraction...");

            // Create output folders
            string baseImagesFolder = Path.Combine(outputFolder, "BaseImages");
            string composedImagesFolder = Path.Combine(outputFolder, "ComposedImages");

            if (!Directory.Exists(baseImagesFolder))
                Directory.CreateDirectory(baseImagesFolder);
            if (!Directory.Exists(composedImagesFolder))
                Directory.CreateDirectory(composedImagesFolder);

            string headerExcel = Path.Combine(outputFolder, "HeaderData.xlsx");
            string tablesExcel = Path.Combine(outputFolder, "TablesData.xlsx");
            string finalExcel = Path.Combine(outputFolder, "Extracted_Data.xlsx");

            // STEP 1: Extract header data and images with C#
            progressCallback?.Invoke(10, "Extracting header data and images...");
            var headerData = ExtractHeadersAndImages(pptxPath, headerExcel, baseImagesFolder, composedImagesFolder, progressCallback);

            string wiNumber = headerData.FirstOrDefault()?["WI_Number"] ?? "";

            // STEP 2: Run Python script to extract tables (pass the single file, not folder)
            progressCallback?.Invoke(40, "Extracting table data with Python...");
            bool pythonSuccess = RunPythonScript(pptxPath, tablesExcel, progressCallback);

            if (!pythonSuccess)
            {
                progressCallback?.Invoke(100, "⚠️ Warning: Table extraction failed. Only header data and images extracted.");
            }
            else
            {
                // STEP 3: Merge the data
                progressCallback?.Invoke(80, "Merging data into final Excel file...");
                MergeExcelFiles(headerExcel, tablesExcel, finalExcel);

                // Clean up intermediate files
                try
                {
                    File.Delete(headerExcel);
                    File.Delete(tablesExcel);
                }
                catch { }

                progressCallback?.Invoke(100, "Extraction complete!");
            }

            return new ExtractionResult
            {
                ExcelPath = finalExcel,
                BaseImagesFolder = baseImagesFolder,
                ComposedImagesFolder = composedImagesFolder,
                WINumber = wiNumber
            };
        }

        private List<Dictionary<string, string>> ExtractHeadersAndImages(string filePath, string excelPath,
            string baseImagesFolder, string composedImagesFolder, Action<int, string> progressCallback)
        {
            var headerData = new List<Dictionary<string, string>>();
            var imageData = new List<Dictionary<string, string>>();
            var textData = new List<Dictionary<string, string>>();

            Application pptApp = new Application();
            int docCounter = 1;

            try
            {
                progressCallback?.Invoke(15, $"Opening PowerPoint file...");

                Presentation ppt = pptApp.Presentations.Open(filePath,
                    MsoTriState.msoFalse,
                    MsoTriState.msoFalse,
                    MsoTriState.msoFalse);

                if (ppt.Slides.Count > 0)
                {
                    progressCallback?.Invoke(20, "Extracting header data...");

                    Slide firstSlide = ppt.Slides[1];

                    var data = new Dictionary<string, string>();
                    data["DocumentID"] = docCounter.ToString();
                    data["SourceFileName"] = Path.GetFileName(filePath);

                    var allTextBoxes = new List<TextBoxInfo>();

                    CollectTextBoxes(firstSlide.Shapes, allTextBoxes);
                    try { CollectTextBoxes(firstSlide.Master.Shapes, allTextBoxes); } catch { }
                    try { CollectTextBoxes(firstSlide.Design.SlideMaster.Shapes, allTextBoxes); } catch { }
                    try { CollectTextBoxes(firstSlide.CustomLayout.Shapes, allTextBoxes); } catch { }

                    ExtractData(allTextBoxes, data);

                    int totalPages = ppt.Slides.Count;
                    data["TotalPages"] = totalPages.ToString();

                    progressCallback?.Invoke(25, "Extracting images...");

                    var images = ExtractImagesFromPresentation(ppt, docCounter, GetValue(data, "WI_Number"),
                        Path.GetFileName(filePath), baseImagesFolder, composedImagesFolder);
                    imageData.AddRange(images);

                    data["TotalImages"] = images.Count.ToString();

                    progressCallback?.Invoke(30, "Extracting text content...");

                    var slideTexts = ExtractTextFromSlides(ppt, docCounter, GetValue(data, "WI_Number"),
                        Path.GetFileName(filePath));
                    textData.AddRange(slideTexts);

                    headerData.Add(data);

                    progressCallback?.Invoke(35, $"Extracted: {GetValue(data, "WI_Number")}");
                }

                ppt.Close();
            }
            finally
            {
                pptApp.Quit();
            }

            WriteToExcel(headerData, imageData, textData, excelPath);

            return headerData;
        }

        private List<Dictionary<string, string>> ExtractTextFromSlides(Presentation ppt, int docId, string wiNumber, string sourceFileName)
        {
            var textData = new List<Dictionary<string, string>>();

            for (int slideIdx = 3; slideIdx <= ppt.Slides.Count; slideIdx++)
            {
                try
                {
                    Slide slide = ppt.Slides[slideIdx];
                    string slideSubject = ExtractSlideSubject(slide);
                    int textBoxCounter = 1;

                    foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Shapes)
                    {
                        string extractedText = ExtractTextFromShape(shape);
                        if (!string.IsNullOrWhiteSpace(extractedText))
                        {
                            textData.Add(new Dictionary<string, string>
                            {
                                ["DocumentID"] = docId.ToString(),
                                ["WI_Number"] = wiNumber,
                                ["SourceFileName"] = sourceFileName,
                                ["SlideNumber"] = slideIdx.ToString(),
                                ["SlideSubject"] = slideSubject,
                                ["TextBoxNumber"] = textBoxCounter.ToString(),
                                ["TextContent"] = extractedText.Trim()
                            });

                            textBoxCounter++;
                        }
                    }
                }
                catch { }
            }

            return textData;
        }

        private string ExtractSlideSubject(Slide slide)
        {
            try
            {
                foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Shapes)
                {
                    try
                    {
                        if (shape.Type == MsoShapeType.msoPlaceholder)
                        {
                            var placeholder = shape.PlaceholderFormat;
                            if (placeholder.Type == PpPlaceholderType.ppPlaceholderTitle ||
                                placeholder.Type == PpPlaceholderType.ppPlaceholderCenterTitle)
                            {
                                if (shape.HasTextFrame == MsoTriState.msoTrue)
                                {
                                    string titleText = shape.TextFrame.TextRange.Text.Trim();
                                    if (!string.IsNullOrWhiteSpace(titleText))
                                    {
                                        return titleText;
                                    }
                                }
                            }
                        }
                    }
                    catch { }
                }

                var topShapes = new List<(string text, float top, float fontSize)>();

                foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Shapes)
                {
                    try
                    {
                        if (shape.HasTextFrame == MsoTriState.msoTrue)
                        {
                            string text = shape.TextFrame.TextRange.Text.Trim();
                            if (!string.IsNullOrWhiteSpace(text) && text.Length < 100)
                            {
                                float fontSize = 12;
                                try { fontSize = shape.TextFrame.TextRange.Font.Size; } catch { }

                                if (shape.Top < 100)
                                {
                                    topShapes.Add((text, shape.Top, fontSize));
                                }
                            }
                        }
                    }
                    catch { }
                }

                if (topShapes.Count > 0)
                {
                    var largestFont = topShapes.OrderByDescending(s => s.fontSize).ThenBy(s => s.top).First();
                    return largestFont.text;
                }

                return "Untitled Slide";
            }
            catch
            {
                return "Untitled Slide";
            }
        }

        private string ExtractTextFromShape(Microsoft.Office.Interop.PowerPoint.Shape shape)
        {
            var text = new System.Text.StringBuilder();

            try
            {
                if (shape.Type == MsoShapeType.msoGroup)
                {
                    foreach (Microsoft.Office.Interop.PowerPoint.Shape groupShape in shape.GroupItems)
                    {
                        string groupText = ExtractTextFromShape(groupShape);
                        if (!string.IsNullOrWhiteSpace(groupText))
                        {
                            text.AppendLine(groupText);
                        }
                    }
                }
                else if (shape.HasTextFrame == MsoTriState.msoTrue)
                {
                    try
                    {
                        string shapeText = shape.TextFrame.TextRange.Text;
                        if (!string.IsNullOrWhiteSpace(shapeText))
                        {
                            text.AppendLine(shapeText.Trim());
                        }
                    }
                    catch { }
                }
                else if (shape.HasTable == MsoTriState.msoTrue)
                {
                    try
                    {
                        var table = shape.Table;
                        for (int row = 1; row <= table.Rows.Count; row++)
                        {
                            var rowText = new System.Text.StringBuilder();
                            for (int col = 1; col <= table.Columns.Count; col++)
                            {
                                string cellText = table.Cell(row, col).Shape.TextFrame.TextRange.Text;
                                if (!string.IsNullOrWhiteSpace(cellText))
                                {
                                    rowText.Append(cellText.Trim() + " | ");
                                }
                            }
                            if (rowText.Length > 0)
                            {
                                text.AppendLine(rowText.ToString().TrimEnd(' ', '|'));
                            }
                        }
                    }
                    catch { }
                }
            }
            catch { }

            return text.ToString().Trim();
        }

        private List<Dictionary<string, string>> ExtractImagesFromPresentation(Presentation ppt, int docId,
            string wiNumber, string sourceFileName, string baseImagesFolder, string composedImagesFolder)
        {
            var imageData = new List<Dictionary<string, string>>();
            int imageCounter = 1;

            string cleanWiNumber = wiNumber;
            if (wiNumber.StartsWith("WI-WI-"))
            {
                cleanWiNumber = wiNumber.Substring(3);
            }

            string docFolderName = !string.IsNullOrEmpty(cleanWiNumber) ? cleanWiNumber : $"Doc-{docId}";
            docFolderName = MakeValidFolderName(docFolderName);

            string baseDocFolder = Path.Combine(baseImagesFolder, docFolderName);
            string composedDocFolder = Path.Combine(composedImagesFolder, docFolderName);

            if (!Directory.Exists(baseDocFolder))
                Directory.CreateDirectory(baseDocFolder);
            if (!Directory.Exists(composedDocFolder))
                Directory.CreateDirectory(composedDocFolder);

            for (int slideIdx = 1; slideIdx <= ppt.Slides.Count; slideIdx++)
            {
                Slide slide = ppt.Slides[slideIdx];

                foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Shapes)
                {
                    try
                    {
                        if (shape.Type == MsoShapeType.msoPicture)
                        {
                            string imageFileName = $"{cleanWiNumber}_Slide{slideIdx:D2}_Img{imageCounter:D2}.png";
                            string imagePath = Path.Combine(baseDocFolder, imageFileName);

                            ExportShape(shape, imagePath);

                            imageData.Add(new Dictionary<string, string>
                            {
                                ["DocumentID"] = docId.ToString(),
                                ["WI_Number"] = cleanWiNumber,
                                ["SourceFileName"] = sourceFileName,
                                ["SlideNumber"] = slideIdx.ToString(),
                                ["ImageNumber"] = imageCounter.ToString(),
                                ["ImageType"] = "Base",
                                ["ImageFileName"] = imageFileName,
                                ["ImagePath"] = Path.Combine(docFolderName, imageFileName),
                                ["IsGrouped"] = "No",
                                ["Width"] = shape.Width.ToString("F2"),
                                ["Height"] = shape.Height.ToString("F2")
                            });

                            imageCounter++;
                        }
                        else if (shape.Type == MsoShapeType.msoGroup)
                        {
                            bool hasImages = ContainsPictures(shape.GroupItems);

                            if (hasImages)
                            {
                                string composedFileName = $"{cleanWiNumber}_Slide{slideIdx:D2}_Composed{imageCounter:D2}.png";
                                string composedPath = Path.Combine(composedDocFolder, composedFileName);

                                ExportShape(shape, composedPath);

                                imageData.Add(new Dictionary<string, string>
                                {
                                    ["DocumentID"] = docId.ToString(),
                                    ["WI_Number"] = cleanWiNumber,
                                    ["SourceFileName"] = sourceFileName,
                                    ["SlideNumber"] = slideIdx.ToString(),
                                    ["ImageNumber"] = imageCounter.ToString(),
                                    ["ImageType"] = "Composed",
                                    ["ImageFileName"] = composedFileName,
                                    ["ImagePath"] = Path.Combine(docFolderName, composedFileName),
                                    ["IsGrouped"] = "Yes",
                                    ["Width"] = shape.Width.ToString("F2"),
                                    ["Height"] = shape.Height.ToString("F2")
                                });

                                ExtractImagesFromGroup(shape.GroupItems, docId, cleanWiNumber, sourceFileName,
                                    slideIdx, ref imageCounter, baseDocFolder, docFolderName, imageData);

                                imageCounter++;
                            }
                        }
                    }
                    catch { }
                }
            }

            return imageData;
        }

        private void ExtractImagesFromGroup(Microsoft.Office.Interop.PowerPoint.GroupShapes groupShapes, int docId,
            string wiNumber, string sourceFileName, int slideIdx, ref int imageCounter,
            string baseDocFolder, string docFolderName, List<Dictionary<string, string>> imageData)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in groupShapes)
            {
                try
                {
                    if (shape.Type == MsoShapeType.msoPicture)
                    {
                        string imageFileName = $"{wiNumber}_Slide{slideIdx:D2}_Img{imageCounter:D2}_FromGroup.png";
                        string imagePath = Path.Combine(baseDocFolder, imageFileName);

                        ExportShape(shape, imagePath);

                        imageData.Add(new Dictionary<string, string>
                        {
                            ["DocumentID"] = docId.ToString(),
                            ["WI_Number"] = wiNumber,
                            ["SourceFileName"] = sourceFileName,
                            ["SlideNumber"] = slideIdx.ToString(),
                            ["ImageNumber"] = imageCounter.ToString(),
                            ["ImageType"] = "Base",
                            ["ImageFileName"] = imageFileName,
                            ["ImagePath"] = Path.Combine(docFolderName, imageFileName),
                            ["IsGrouped"] = "Yes (Extracted)",
                            ["Width"] = shape.Width.ToString("F2"),
                            ["Height"] = shape.Height.ToString("F2")
                        });

                        imageCounter++;
                    }
                    else if (shape.Type == MsoShapeType.msoGroup)
                    {
                        ExtractImagesFromGroup(shape.GroupItems, docId, wiNumber, sourceFileName,
                            slideIdx, ref imageCounter, baseDocFolder, docFolderName, imageData);
                    }
                }
                catch { }
            }
        }

        private bool ContainsPictures(Microsoft.Office.Interop.PowerPoint.GroupShapes groupShapes)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in groupShapes)
            {
                if (shape.Type == MsoShapeType.msoPicture)
                    return true;
                if (shape.Type == MsoShapeType.msoGroup && ContainsPictures(shape.GroupItems))
                    return true;
            }
            return false;
        }

        private void ExportShape(Microsoft.Office.Interop.PowerPoint.Shape shape, string outputPath)
        {
            try
            {
                shape.Export(outputPath, PpShapeFormat.ppShapeFormatPNG);
            }
            catch
            {
                try
                {
                    shape.Copy();
                    var img = System.Windows.Forms.Clipboard.GetImage();
                    if (img != null)
                    {
                        img.Save(outputPath, ImageFormat.Png);
                    }
                }
                catch { }
            }
        }

        private string MakeValidFolderName(string name)
        {
            char[] invalidChars = Path.GetInvalidFileNameChars();
            foreach (char c in invalidChars)
            {
                name = name.Replace(c, '_');
            }
            return name;
        }

        private bool RunPythonScript(string pptxFilePath, string outputExcel, Action<int, string> progressCallback)
        {
            try
            {
                progressCallback?.Invoke(45, "Looking for Python...");
                string pythonExe = FindPythonExecutable();

                if (string.IsNullOrEmpty(pythonExe))
                {
                    progressCallback?.Invoke(50, "Python not found");
                    return false;
                }

                string scriptPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "extract_tables.py");

                if (!File.Exists(scriptPath))
                {
                    progressCallback?.Invoke(50, $"Python script not found: extract_tables.py");
                    return false;
                }

                // Create a temporary folder with just this one file
                string tempFolder = Path.Combine(Path.GetTempPath(), "TempWI_" + Guid.NewGuid().ToString());
                Directory.CreateDirectory(tempFolder);

                string tempFilePath = Path.Combine(tempFolder, Path.GetFileName(pptxFilePath));
                File.Copy(pptxFilePath, tempFilePath, true);

                string tempScript = CreateTempPythonScript(tempFolder, outputExcel, scriptPath);

                progressCallback?.Invoke(50, "Running Python script...");

                ProcessStartInfo start = new ProcessStartInfo();
                start.FileName = pythonExe;
                start.Arguments = $"\"{tempScript}\"";
                start.UseShellExecute = false;
                start.RedirectStandardOutput = true;
                start.RedirectStandardError = true;
                start.CreateNoWindow = true;

                using (Process process = Process.Start(start))
                {
                    string output = process.StandardOutput.ReadToEnd();
                    string errors = process.StandardError.ReadToEnd();

                    process.WaitForExit();

                    if (!string.IsNullOrEmpty(errors))
                    {
                        progressCallback?.Invoke(55, $"Python errors: {errors}");
                    }

                    // Clean up temp files
                    try
                    {
                        File.Delete(tempScript);
                        File.Delete(tempFilePath);
                        Directory.Delete(tempFolder);
                    }
                    catch { }

                    return process.ExitCode == 0 && File.Exists(outputExcel);
                }
            }
            catch (Exception ex)
            {
                progressCallback?.Invoke(50, $"Error running Python: {ex.Message}");
                return false;
            }
        }

        private string FindPythonExecutable()
        {
            string[] possiblePaths = new string[]
            {
                "python",
                "python3",
                @"C:\Python39\python.exe",
                @"C:\Python310\python.exe",
                @"C:\Python311\python.exe",
                @"C:\Python313\python.exe",
                @"C:\Users\" + Environment.UserName + @"\AppData\Local\Programs\Python\Python39\python.exe",
                @"C:\Users\" + Environment.UserName + @"\AppData\Local\Programs\Python\Python310\python.exe",
                @"C:\Users\" + Environment.UserName + @"\AppData\Local\Programs\Python\Python311\python.exe",
                @"C:\Users\" + Environment.UserName + @"\AppData\Local\Programs\Python\Python313\python.exe"
            };

            foreach (string path in possiblePaths)
            {
                try
                {
                    ProcessStartInfo psi = new ProcessStartInfo();
                    psi.FileName = path;
                    psi.Arguments = "--version";
                    psi.UseShellExecute = false;
                    psi.RedirectStandardOutput = true;
                    psi.CreateNoWindow = true;

                    using (Process process = Process.Start(psi))
                    {
                        process.WaitForExit();
                        if (process.ExitCode == 0)
                        {
                            return path;
                        }
                    }
                }
                catch
                {
                    continue;
                }
            }

            return null;
        }

        private string CreateTempPythonScript(string inputFolder, string outputExcel, string originalScript)
        {
            string scriptContent = File.ReadAllText(originalScript);

            scriptContent = System.Text.RegularExpressions.Regex.Replace(
                scriptContent,
                @"input_folder = r"".*?""",
                $"input_folder = r\"{inputFolder}\""
            );

            scriptContent = System.Text.RegularExpressions.Regex.Replace(
                scriptContent,
                @"output_excel = r"".*?""",
                $"output_excel = r\"{outputExcel}\""
            );

            string tempScript = Path.Combine(Path.GetTempPath(), "temp_extract_tables.py");
            File.WriteAllText(tempScript, scriptContent);

            return tempScript;
        }

        private void MergeExcelFiles(string headerFile, string tablesFile, string outputFile)
        {
            using (var headerPackage = new ExcelPackage(new FileInfo(headerFile)))
            using (var tablesPackage = new ExcelPackage(new FileInfo(tablesFile)))
            using (var outputPackage = new ExcelPackage())
            {
                // Copy Header Data sheet first
                var headerSheet = headerPackage.Workbook.Worksheets[0];
                outputPackage.Workbook.Worksheets.Add("Header Data", headerSheet);

                // Copy Images sheet if it exists
                if (headerPackage.Workbook.Worksheets.Count > 1)
                {
                    var imagesSheet = headerPackage.Workbook.Worksheets[1];
                    outputPackage.Workbook.Worksheets.Add("Images", imagesSheet);
                }

                // Copy Text Content sheet if it exists
                if (headerPackage.Workbook.Worksheets.Count > 2)
                {
                    var textSheet = headerPackage.Workbook.Worksheets[2];
                    outputPackage.Workbook.Worksheets.Add("Text Content", textSheet);
                }

                // Copy all sheets from tables file
                foreach (var sheet in tablesPackage.Workbook.Worksheets)
                {
                    outputPackage.Workbook.Worksheets.Add(sheet.Name, sheet);
                }

                FileInfo outputFileInfo = new FileInfo(outputFile);
                outputPackage.SaveAs(outputFileInfo);
            }
        }

        private void CollectTextBoxes(Microsoft.Office.Interop.PowerPoint.Shapes shapes, List<TextBoxInfo> textBoxes)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in shapes)
            {
                if (shape.Type == MsoShapeType.msoGroup)
                {
                    CollectTextBoxesFromGroup(shape.GroupItems, textBoxes);
                }
                else if (shape.HasTextFrame == MsoTriState.msoTrue)
                {
                    string text = shape.TextFrame.TextRange.Text.Trim();
                    if (!string.IsNullOrEmpty(text))
                    {
                        textBoxes.Add(new TextBoxInfo
                        {
                            Text = text,
                            Left = shape.Left,
                            Top = shape.Top,
                            Width = shape.Width,
                            Height = shape.Height
                        });
                    }
                }
            }
        }

        private void CollectTextBoxesFromGroup(Microsoft.Office.Interop.PowerPoint.GroupShapes groupShapes, List<TextBoxInfo> textBoxes)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in groupShapes)
            {
                if (shape.Type == MsoShapeType.msoGroup)
                {
                    CollectTextBoxesFromGroup(shape.GroupItems, textBoxes);
                }
                else if (shape.HasTextFrame == MsoTriState.msoTrue)
                {
                    string text = shape.TextFrame.TextRange.Text.Trim();
                    if (!string.IsNullOrEmpty(text))
                    {
                        textBoxes.Add(new TextBoxInfo
                        {
                            Text = text,
                            Left = shape.Left,
                            Top = shape.Top,
                            Width = shape.Width,
                            Height = shape.Height
                        });
                    }
                }
            }
        }

        private void ExtractData(List<TextBoxInfo> textBoxes, Dictionary<string, string> data)
        {
            foreach (var box in textBoxes)
            {
                string text = box.Text.Trim();
                string upperText = text.ToUpper();

                // Extract WI Number
                if (string.IsNullOrEmpty(GetValue(data, "WI_Number")))
                {
                    var wiMatch = System.Text.RegularExpressions.Regex.Match(text,
                        @"W\.?I\.?\s*-?\s*\d+",
                        System.Text.RegularExpressions.RegexOptions.IgnoreCase);

                    if (wiMatch.Success)
                    {
                        string wiNum = wiMatch.Value.Replace(" ", "").Replace(".", "");
                        if (!wiNum.Contains("-"))
                            wiNum = wiNum.Replace("WI", "WI-");
                        data["WI_Number"] = wiNum.ToUpper();
                    }
                }

                // Extract Title
                if (string.IsNullOrEmpty(GetValue(data, "WI_Title")))
                {
                    bool isLabel = upperText == "WORK INSTRUCTION TITLE" ||
                                  upperText == "WORK INSTRUCTION" ||
                                  upperText == "DESCRIPTION:" ||
                                  upperText.Contains("W.I. NUMBER") ||
                                  upperText.Contains("BOM") && upperText.Contains("DWG") ||
                                  upperText.Contains("OPS") && upperText.Contains("OPTIONAL") ||
                                  upperText.Contains("OPERATION NO") ||
                                  upperText == "PRODUCT LINE" ||
                                  upperText == "SUBJECT" ||
                                  upperText == "SUBJECT:" ||
                                  upperText == "PAGE" ||
                                  upperText == "REV" ||
                                  upperText.Contains("COMPANY") && upperText.Length > 20 ||
                                  upperText.Contains("FM-ME") ||
                                  upperText.Contains("TRAINING RECORD") ||
                                  upperText.Contains("REVISION HISTORY") ||
                                  upperText.Contains("NOTICE") ||
                                  upperText.Contains("STATEMENT") ||
                                  (text.EndsWith(":") && text.Length < 20);

                    if (isLabel) continue;

                    bool isRev17_19Title = (box.Left > 100 && box.Left < 110 && box.Top > 455 && box.Top < 470);
                    bool isRev15_16Title = (box.Left > 20 && box.Left < 80 && box.Top > 515 && box.Top < 525);

                    if ((isRev17_19Title || isRev15_16Title) && text.Length > 3 && text.Length < 100)
                    {
                        data["WI_Title"] = text;
                    }
                }

                // Extract Revision
                if (string.IsNullOrEmpty(GetValue(data, "Revision")))
                {
                    if (upperText == "REV" || upperText == "REV:" || upperText == "REVISION:")
                        continue;

                    bool isRev17_19Rev = (box.Left > 665 && box.Left < 680 && box.Top > 460 && box.Top < 470);
                    bool isRev15_16Rev = (box.Left > 595 && box.Left < 620 && box.Top > 555 && box.Top < 565);

                    if ((isRev17_19Rev || isRev15_16Rev) &&
                        text.Length >= 1 && text.Length <= 3 &&
                        System.Text.RegularExpressions.Regex.IsMatch(text, @"^[0-9]+$"))
                    {
                        data["Revision"] = text;
                    }
                }

                // Extract BOM/ASSY DWG NO
                if (string.IsNullOrEmpty(GetValue(data, "BOM_ASSY_DWG_NO")))
                {
                    if ((upperText.Contains("BOM") || upperText.Contains("ASSY") || upperText.Contains("DWG")) &&
                        upperText.Contains("NO"))
                        continue;

                    bool isRev17_19BOM = (box.Left > 0 && box.Left < 20 && box.Top > 498 && box.Top < 505);
                    bool isRev15_16BOM = (box.Left > 300 && box.Left < 315 && box.Top > 558 && box.Top < 565);

                    if ((isRev17_19BOM || isRev15_16BOM) &&
                        text.Length > 1 && text.Length < 50 &&
                        !text.StartsWith("WI-") && !text.StartsWith("W.I."))
                    {
                        data["BOM_ASSY_DWG_NO"] = text;
                    }
                }

                // Extract Operation Number
                if (string.IsNullOrEmpty(GetValue(data, "Operation_No")))
                {
                    if ((upperText.Contains("OPERATION") && upperText.Contains("NO")) ||
                        upperText == "OPS (OPTIONAL)" || upperText == "OPERATION NO.")
                        continue;

                    bool isRev17_19Ops = (box.Left > 140 && box.Left < 155 && box.Top > 498 && box.Top < 505);
                    bool isRev15_16Ops = (box.Left > 185 && box.Left < 195 && box.Top > 555 && box.Top < 565);

                    if ((isRev17_19Ops || isRev15_16Ops) && text.Length > 1 && text.Length < 40)
                    {
                        data["Operation_No"] = text;
                    }
                }

                // Extract Product Line
                if (string.IsNullOrEmpty(GetValue(data, "Product_Line")))
                {
                    if (upperText == "PRODUCT LINE")
                        continue;

                    bool isRev17_19PL = (box.Left > 210 && box.Left < 230 && box.Top > 498 && box.Top < 505);
                    bool isRev15_16PL = (box.Left > 460 && box.Left < 515 && box.Top > 555 && box.Top < 565);

                    if ((isRev17_19PL || isRev15_16PL) &&
                        text.Length >= 2 && text.Length < 30 &&
                        !upperText.Contains("PAGE") &&
                        System.Text.RegularExpressions.Regex.IsMatch(text, @"[A-Z0-9]"))
                    {
                        data["Product_Line"] = text;
                    }
                }

                // Extract Subject
                if (string.IsNullOrEmpty(GetValue(data, "Subject")))
                {
                    if (upperText == "SUBJECT" ||
                        upperText == "SUBJECT:" ||
                        upperText.Contains("COMPANY") ||
                        System.Text.RegularExpressions.Regex.IsMatch(text, @"^\<?#?\>?\s*OF\s*\d+$", System.Text.RegularExpressions.RegexOptions.IgnoreCase))
                        continue;

                    bool isRev15_16Subject = (box.Left > 420 && box.Left < 430 && box.Top > 520 && box.Top < 525);

                    bool isRev17_19Subject = (box.Top > 495 && box.Top < 510) &&
                                             (box.Left > 315 && box.Left < 640) &&
                                             (box.Height > 10 && box.Height < 30) &&
                                             (box.Width > 200 && box.Width < 400) &&
                                             text.Length > 2 &&
                                             text.Length < 60 &&
                                             text != GetValue(data, "WI_Number") &&
                                             text != GetValue(data, "WI_Title") &&
                                             text != GetValue(data, "Product_Line") &&
                                             text != GetValue(data, "Operation_No") &&
                                             text != GetValue(data, "BOM_ASSY_DWG_NO");

                    if (isRev15_16Subject || isRev17_19Subject)
                    {
                        data["Subject"] = text;
                    }
                }

                // Extract Template Revision
                if (upperText.Contains("FM-ME") || upperText.Contains("FM ME") || upperText.Contains("FMME"))
                {
                    var revMatch = System.Text.RegularExpressions.Regex.Match(text,
                        @"FM-?[\s]?ME-?\d+.*?rev\.?\s*(\d+)",
                        System.Text.RegularExpressions.RegexOptions.IgnoreCase);

                    if (revMatch.Success && revMatch.Groups.Count > 1)
                    {
                        data["RevisionType"] = revMatch.Groups[1].Value;
                    }
                }
            }
        }

        private string GetValue(Dictionary<string, string> dict, string key)
        {
            return dict.ContainsKey(key) ? dict[key] : "";
        }

        private void WriteToExcel(List<Dictionary<string, string>> headerData,
            List<Dictionary<string, string>> imageData,
            List<Dictionary<string, string>> textData,
            string excelPath)
        {
            if (File.Exists(excelPath))
                File.Delete(excelPath);

            using (var package = new ExcelPackage())
            {
                // Header Data sheet
                var worksheet = package.Workbook.Worksheets.Add("Header Data");

                var headers = new string[] {
                    "Document ID", "Source File Name", "WI Number", "WI Title", "Revision",
                    "BOM/ASSY DWG NO", "Operation No", "Product Line", "Subject", "Revision Type",
                    "Total Pages", "Total Images"
                };

                for (int i = 0; i < headers.Length; i++)
                {
                    worksheet.Cells[1, i + 1].Value = headers[i];
                }

                using (var range = worksheet.Cells[1, 1, 1, headers.Length])
                {
                    range.Style.Font.Bold = true;
                    range.Style.Fill.PatternType = OfficeOpenXml.Style.ExcelFillStyle.Solid;
                    range.Style.Fill.BackgroundColor.SetColor(System.Drawing.Color.LightGray);
                    range.Style.HorizontalAlignment = OfficeOpenXml.Style.ExcelHorizontalAlignment.Center;
                }

                int row = 2;
                foreach (var record in headerData)
                {
                    worksheet.Cells[row, 1].Value = GetValue(record, "DocumentID");
                    worksheet.Cells[row, 2].Value = GetValue(record, "SourceFileName");
                    worksheet.Cells[row, 3].Value = GetValue(record, "WI_Number");
                    worksheet.Cells[row, 4].Value = GetValue(record, "WI_Title");
                    worksheet.Cells[row, 5].Value = GetValue(record, "Revision");
                    worksheet.Cells[row, 6].Value = GetValue(record, "BOM_ASSY_DWG_NO");
                    worksheet.Cells[row, 7].Value = GetValue(record, "Operation_No");
                    worksheet.Cells[row, 8].Value = GetValue(record, "Product_Line");
                    worksheet.Cells[row, 9].Value = GetValue(record, "Subject");
                    worksheet.Cells[row, 10].Value = GetValue(record, "RevisionType");
                    worksheet.Cells[row, 11].Value = GetValue(record, "TotalPages");
                    worksheet.Cells[row, 12].Value = GetValue(record, "TotalImages");
                    row++;
                }

                worksheet.Cells[worksheet.Dimension.Address].AutoFitColumns();

                // Images sheet
                if (imageData.Count > 0)
                {
                    var imgWorksheet = package.Workbook.Worksheets.Add("Images");

                    var imgHeaders = new string[] {
                        "Document ID", "WI Number", "Source File Name", "Slide Number", "Image Number",
                        "Image Type", "Image File Name", "Image Path", "Is Grouped", "Width", "Height"
                    };

                    for (int i = 0; i < imgHeaders.Length; i++)
                    {
                        imgWorksheet.Cells[1, i + 1].Value = imgHeaders[i];
                    }

                    using (var range = imgWorksheet.Cells[1, 1, 1, imgHeaders.Length])
                    {
                        range.Style.Font.Bold = true;
                        range.Style.Fill.PatternType = OfficeOpenXml.Style.ExcelFillStyle.Solid;
                        range.Style.Fill.BackgroundColor.SetColor(System.Drawing.Color.LightGray);
                        range.Style.HorizontalAlignment = OfficeOpenXml.Style.ExcelHorizontalAlignment.Center;
                    }

                    row = 2;
                    foreach (var img in imageData)
                    {
                        imgWorksheet.Cells[row, 1].Value = GetValue(img, "DocumentID");
                        imgWorksheet.Cells[row, 2].Value = GetValue(img, "WI_Number");
                        imgWorksheet.Cells[row, 3].Value = GetValue(img, "SourceFileName");
                        imgWorksheet.Cells[row, 4].Value = GetValue(img, "SlideNumber");
                        imgWorksheet.Cells[row, 5].Value = GetValue(img, "ImageNumber");
                        imgWorksheet.Cells[row, 6].Value = GetValue(img, "ImageType");
                        imgWorksheet.Cells[row, 7].Value = GetValue(img, "ImageFileName");
                        imgWorksheet.Cells[row, 8].Value = GetValue(img, "ImagePath");
                        imgWorksheet.Cells[row, 9].Value = GetValue(img, "IsGrouped");
                        imgWorksheet.Cells[row, 10].Value = GetValue(img, "Width");
                        imgWorksheet.Cells[row, 11].Value = GetValue(img, "Height");
                        row++;
                    }

                    imgWorksheet.Cells[imgWorksheet.Dimension.Address].AutoFitColumns();
                }

                // Text Content sheet
                if (textData.Count > 0)
                {
                    var textWorksheet = package.Workbook.Worksheets.Add("Text Content");

                    var textHeaders = new string[] {
                        "Document ID", "WI Number", "Source File Name", "Slide Number",
                        "Slide Subject", "TextBox Number", "Text Content"
                    };

                    for (int i = 0; i < textHeaders.Length; i++)
                    {
                        textWorksheet.Cells[1, i + 1].Value = textHeaders[i];
                    }

                    using (var range = textWorksheet.Cells[1, 1, 1, textHeaders.Length])
                    {
                        range.Style.Font.Bold = true;
                        range.Style.Fill.PatternType = OfficeOpenXml.Style.ExcelFillStyle.Solid;
                        range.Style.Fill.BackgroundColor.SetColor(System.Drawing.Color.LightGray);
                        range.Style.HorizontalAlignment = OfficeOpenXml.Style.ExcelHorizontalAlignment.Center;
                    }

                    row = 2;
                    foreach (var txt in textData)
                    {
                        textWorksheet.Cells[row, 1].Value = GetValue(txt, "DocumentID");
                        textWorksheet.Cells[row, 2].Value = GetValue(txt, "WI_Number");
                        textWorksheet.Cells[row, 3].Value = GetValue(txt, "SourceFileName");
                        textWorksheet.Cells[row, 4].Value = GetValue(txt, "SlideNumber");
                        textWorksheet.Cells[row, 5].Value = GetValue(txt, "SlideSubject");
                        textWorksheet.Cells[row, 6].Value = GetValue(txt, "TextBoxNumber");
                        textWorksheet.Cells[row, 7].Value = GetValue(txt, "TextContent");

                        textWorksheet.Cells[row, 7].Style.WrapText = true;

                        row++;
                    }

                    textWorksheet.Column(7).Width = 80;
                    textWorksheet.Cells[textWorksheet.Dimension.Address].AutoFitColumns();
                }

                FileInfo fileInfo = new FileInfo(excelPath);
                package.SaveAs(fileInfo);
            }
        }
    }

    // Helper classes
    public class ExtractionResult
    {
        public string ExcelPath { get; set; } = string.Empty;
        public string BaseImagesFolder { get; set; } = string.Empty;
        public string ComposedImagesFolder { get; set; } = string.Empty;
        public string WINumber { get; set; } = string.Empty;
    }

    internal class TextBoxInfo
    {
        public string Text { get; set; } = string.Empty;
        public float Left { get; set; }
        public float Top { get; set; }
        public float Width { get; set; }
        public float Height { get; set; }
    }
}
----------

extract tables python
"""
Work Instruction PowerPoint Data Extractor
Extracts tables and images from PowerPoint files to Excel
"""

import os
from pptx import Presentation
import pandas as pd
from datetime import datetime
from openpyxl import load_workbook
from openpyxl.styles import Font, PatternFill, Alignment, numbers
import re
from PIL import Image
import io

def identify_revision_type(prs):
    """Identifies revision type from FM-ME-07 text box at bottom right"""
    if len(prs.slides) > 0:
        slide = prs.slides[0]
        
        # Look for FM-ME-07 text in all shapes (including grouped shapes)
        for shape in slide.shapes:
            if shape.has_text_frame:
                text = shape.text.lower()
                if 'fm-me-' in text or 'fm me' in text or 'fmme' in text:
                    # Check for revision numbers
                    if 'rev15' in text or 'rev16' in text or 'rev 15' in text or 'rev 16' in text:
                        return '15-16'
                    elif 'rev17' in text or 'rev18' in text or 'rev19' in text or 'rev 17' in text or 'rev 18' in text or 'rev 19' in text:
                        return '17-19'
    
    return 'Unknown'

def clean_cell_value(value):
    """Cleans cell values to remove illegal characters for Excel"""
    if not value or not isinstance(value, str):
        return value
    
    # Replace newlines with spaces
    value = value.replace('\n', ' ').replace('\r', ' ')
    
    # Replace tabs with spaces
    value = value.replace('\t', ' ')
    
    # Remove other control characters (ASCII 0-31 except tab, newline, carriage return)
    value = ''.join(char for char in value if ord(char) >= 32 or char in '\t\n\r')
    
    # Clean up multiple spaces
    value = ' '.join(value.split())
    
    return value.strip()

def parse_date(date_str):
    """Parses various date formats and returns MM/DD/YYYY format"""
    if not date_str or not isinstance(date_str, str):
        return ""
    
    date_str = date_str.strip()
    
    if not date_str or date_str == '':
        return ""
    
    # Common date patterns
    patterns = [
        r'(\d{1,2})/(\d{1,2})/(\d{4})',  # MM/DD/YYYY or M/D/YYYY
        r'(\d{1,2})/(\d{1,2})/(\d{2})',  # MM/DD/YY or M/D/YY
        r'(\d{4})-(\d{1,2})-(\d{1,2})',  # YYYY-MM-DD
        r'(\d{1,2})-(\d{1,2})-(\d{4})',  # MM-DD-YYYY or DD-MM-YYYY
    ]
    
    for pattern in patterns:
        match = re.search(pattern, date_str)
        if match:
            try:
                if len(match.groups()) == 3:
                    part1, part2, part3 = match.groups()
                    
                    # Handle YYYY-MM-DD format
                    if len(part1) == 4:
                        year = int(part1)
                        month = int(part2)
                        day = int(part3)
                    # Handle YY format
                    elif len(part3) == 2:
                        month = int(part1)
                        day = int(part2)
                        year = 2000 + int(part3)
                    # Handle MM/DD/YYYY or MM-DD-YYYY
                    else:
                        month = int(part1)
                        day = int(part2)
                        year = int(part3)
                    
                    # Validate and format
                    if 1 <= month <= 12 and 1 <= day <= 31 and 1900 <= year <= 2100:
                        return f"{month:02d}/{day:02d}/{year:04d}"
            except:
                pass
    
    return date_str  # Return original if can't parse

def find_table_by_header(slide, header_text):
    """Finds a table by looking for header text"""
    for shape in slide.shapes:
        if shape.has_table:
            table = shape.table
            # Check first row for header
            first_row_text = ' '.join([cell.text for cell in table.rows[0].cells])
            if header_text.upper() in first_row_text.upper():
                return table
    return None

def extract_bom_table(slide, doc_id):
    """Extracts BOM/Configuration table from slide"""
    bom_data = []
    
    print(f"    Searching for BOM table...")
    
    # Look for BOM/CONFIGURATION TABLE
    table = find_table_by_header(slide, 'BOM/CONFIGURATION TABLE')
    if not table:
        table = find_table_by_header(slide, 'BOM/CONFIGURATION')
    if not table:
        table = find_table_by_header(slide, 'CONFIGURATION TABLE')
    if not table:
        table = find_table_by_header(slide, 'BOM')
    if not table:
        table = find_table_by_header(slide, 'CONFIGURATION')
    
    if table:
        print(f"    Found BOM table with {len(table.rows)} rows")
        
        # Look for the actual column headers row (Part Number, Description)
        header_row_index = None
        for idx, row in enumerate(table.rows):
            row_text = ' '.join([cell.text for cell in row.cells]).upper()
            if 'PART NUMBER' in row_text or 'DESCRIPTION' in row_text:
                header_row_index = idx
                break
        
        if header_row_index is not None:
            # Extract data rows after the column header row
            data_row_count = 0
            for idx, row in enumerate(list(table.rows)[header_row_index + 1:], start=1):
                if len(row.cells) >= 2:
                    part_num = row.cells[0].text.strip()
                    description = row.cells[1].text.strip()
                    
                    # Only add if both part number and description have content
                    if part_num and description and len(part_num) > 0 and len(description) > 0:
                        bom_data.append({
                            'DocumentID': doc_id,
                            'PartNumber': clean_cell_value(part_num),
                            'Description': clean_cell_value(description),
                            'RowOrder': idx
                        })
                        data_row_count += 1
            
            print(f"    Extracted {data_row_count} BOM entries")
    else:
        print(f"    No BOM/CONFIGURATION table found")
    
    return bom_data

def extract_equipment_and_parts(slide, doc_id):
    """Extracts Equipment Required and Parts Required tables from slide 2"""
    equipment_data = []
    parts_data = []
    
    print(f"    Searching for Equipment and Parts tables on slide 2...")
    
    # Look for Equipment Required table
    equipment_table = find_table_by_header(slide, 'EQUIPMENT REQUIRED')
    if not equipment_table:
        equipment_table = find_table_by_header(slide, 'Equipment Required')
    
    if equipment_table:
        print(f"    Found Equipment Required table")
        # Find header row with Qty, Part No, Description
        header_row_index = None
        for idx, row in enumerate(equipment_table.rows):
            row_text = ' '.join([cell.text for cell in row.cells]).upper()
            if 'QTY' in row_text and ('PART NO' in row_text or 'DESCRIPTION' in row_text):
                header_row_index = idx
                break
        
        if header_row_index is not None:
            data_row_count = 0
            for idx, row in enumerate(list(equipment_table.rows)[header_row_index + 1:], start=1):
                if len(row.cells) >= 3:
                    qty = clean_cell_value(row.cells[0].text.strip())
                    part_no = clean_cell_value(row.cells[1].text.strip())
                    description = clean_cell_value(row.cells[2].text.strip())
                    
                    # Only add if has content
                    if qty or part_no or description:
                        equipment_data.append({
                            'DocumentID': doc_id,
                            'Quantity': qty,
                            'PartNumber': part_no,
                            'Description': description,
                            'RowOrder': idx
                        })
                        data_row_count += 1
            
            print(f"    Extracted {data_row_count} equipment entries")
    else:
        print(f"    No Equipment Required table found")
    
    # Look for Parts Required table
    parts_table = find_table_by_header(slide, 'PARTS REQUIRED')
    if not parts_table:
        parts_table = find_table_by_header(slide, 'Parts Required')
    
    if parts_table:
        print(f"    Found Parts Required table")
        # Find header row with Qty, Part No, Description
        header_row_index = None
        for idx, row in enumerate(parts_table.rows):
            row_text = ' '.join([cell.text for cell in row.cells]).upper()
            if 'QTY' in row_text and ('PART NO' in row_text or 'DESCRIPTION' in row_text):
                header_row_index = idx
                break
        
        if header_row_index is not None:
            data_row_count = 0
            for idx, row in enumerate(list(parts_table.rows)[header_row_index + 1:], start=1):
                if len(row.cells) >= 3:
                    qty = clean_cell_value(row.cells[0].text.strip())
                    part_no = clean_cell_value(row.cells[1].text.strip())
                    description = clean_cell_value(row.cells[2].text.strip())
                    
                    # Only add if has content
                    if qty or part_no or description:
                        parts_data.append({
                            'DocumentID': doc_id,
                            'Quantity': qty,
                            'PartNumber': part_no,
                            'Description': description,
                            'RowOrder': idx
                        })
                        data_row_count += 1
            
            print(f"    Extracted {data_row_count} parts entries")
    else:
        print(f"    No Parts Required table found")
    
    return equipment_data, parts_data

def extract_revision_history(slide, doc_id):
    """Extracts Revision History table from slide"""
    rev_data = []
    
    table = find_table_by_header(slide, 'REVISION HISTORY')
    
    if table:
        # Skip first row (header) and get data
        for idx, row in enumerate(list(table.rows)[1:], start=1):
            if len(row.cells) >= 3:
                rev_num = row.cells[0].text.strip()
                rev_desc = row.cells[1].text.strip()
                rev_date = row.cells[2].text.strip()
                
                # Skip header row and empty rows
                if rev_num and 'Rev' not in rev_num and rev_num != '#' and 'Description' not in rev_desc:
                    # Format date
                    formatted_date = parse_date(rev_date)
                    
                    rev_data.append({
                        'DocumentID': doc_id,
                        'RevNumber': rev_num,
                        'ChangeDescription': rev_desc,
                        'ChangeDate': formatted_date,
                        'RowOrder': idx
                    })
    
    return rev_data

def extract_drafting_and_approvals(slide, doc_id):
    """Extracts both Drafting and Approvals from combined table"""
    drafting_data = []
    approvals_data = []
    
    for shape in slide.shapes:
        if shape.has_table:
            table = shape.table
            
            # Check if this table has both Drafting and Approvals
            all_text = ' '.join([cell.text for row in table.rows for cell in row.cells]).upper()
            
            if 'DRAFTING' in all_text and 'APPROVALS' in all_text:
                # This is the combined table
                in_approvals_section = False
                
                for row_idx, row in enumerate(table.rows):
                    if len(row.cells) >= 3:
                        first_cell = row.cells[0].text.strip()
                        
                        # Check if we've reached Approvals section
                        if 'Approvals' in first_cell:
                            in_approvals_section = True
                            continue
                        
                        # Skip header rows
                        if first_cell in ['Drafting', 'Signatures', 'Date']:
                            continue
                        
                        # Extract data
                        col1 = row.cells[0].text.strip()
                        col2 = row.cells[1].text.strip()
                        col3 = row.cells[2].text.strip()
                        
                        # Format date
                        formatted_date = parse_date(col3)
                        
                        if col1:  # Has data
                            if in_approvals_section:
                                # Approvals section
                                approvals_data.append({
                                    'DocumentID': doc_id,
                                    'Department': col1,
                                    'Signature': col2,
                                    'ApprovalDate': formatted_date
                                })
                            else:
                                # Drafting section
                                drafting_data.append({
                                    'DocumentID': doc_id,
                                    'Role': col1,
                                    'Signature': col2,
                                    'SignatureDate': formatted_date
                                })
                
                break
    
    return drafting_data, approvals_data

def format_excel_sheet(worksheet):
    """Formats Excel sheet with gray headers and auto-fit columns"""
    # Format header row
    gray_fill = PatternFill(start_color="D3D3D3", end_color="D3D3D3", fill_type="solid")
    bold_font = Font(bold=True)
    center_alignment = Alignment(horizontal="center")
    
    for cell in worksheet[1]:
        cell.fill = gray_fill
        cell.font = bold_font
        cell.alignment = center_alignment
    
    # Auto-fit columns
    for column in worksheet.columns:
        max_length = 0
        column_letter = column[0].column_letter
        
        for cell in column:
            try:
                if cell.value:
                    max_length = max(max_length, len(str(cell.value)))
            except:
                pass
        
        adjusted_width = min(max_length + 2, 50)  # Cap at 50 characters
        worksheet.column_dimensions[column_letter].width = adjusted_width

def process_powerpoint_files(folder_path, output_excel):
    """Main function to process PowerPoint files"""
    
    # Initialize data containers
    bom_data_all = []
    equipment_data_all = []
    parts_data_all = []
    rev_history_all = []
    drafting_all = []
    approvals_all = []
    
    doc_id = 1
    
    # Process each PowerPoint file
    for filename in os.listdir(folder_path):
        if filename.endswith('.pptx') or filename.endswith('.ppt'):
            if filename.startswith('~$'):  # Skip temp files
                continue
            
            print(f"Processing: {filename}")
            
            filepath = os.path.join(folder_path, filename)
            
            try:
                prs = Presentation(filepath)
                
                # Identify revision type
                rev_type = identify_revision_type(prs)
                print(f"  Revision type: {rev_type}")
                
                # Get first slide
                if len(prs.slides) > 0:
                    first_slide = prs.slides[0]
                    
                    # Extract tables from first slide
                    bom_data_all.extend(extract_bom_table(first_slide, doc_id))
                    
                    rev_history_all.extend(extract_revision_history(first_slide, doc_id))
                    
                    # Extract drafting and approvals (from combined table)
                    drafting, approvals = extract_drafting_and_approvals(first_slide, doc_id)
                    drafting_all.extend(drafting)
                    approvals_all.extend(approvals)
                    
                    print(f"  Extracted from slide 1: {len(drafting)} drafting, {len(approvals)} approvals")
                
                # Get second slide for Equipment and Parts
                if len(prs.slides) > 1:
                    second_slide = prs.slides[1]
                    equipment, parts = extract_equipment_and_parts(second_slide, doc_id)
                    equipment_data_all.extend(equipment)
                    parts_data_all.extend(parts)
                    print(f"  Extracted from slide 2: {len(equipment)} equipment, {len(parts)} parts")
                
                doc_id += 1
                
            except Exception as e:
                print(f"  ERROR processing {filename}: {str(e)}")
                import traceback
                traceback.print_exc()
    
    # Create Excel file
    print(f"\nCreating Excel file: {output_excel}")
    
    with pd.ExcelWriter(output_excel, engine='openpyxl') as writer:
        # BOM sheet
        if bom_data_all:
            df_bom = pd.DataFrame(bom_data_all)
            df_bom.to_excel(writer, sheet_name='BOM', index=False)
        else:
            df_bom = pd.DataFrame(columns=['DocumentID', 'PartNumber', 'Description', 'RowOrder'])
            df_bom.to_excel(writer, sheet_name='BOM', index=False)
        
        # Equipment Required sheet
        if equipment_data_all:
            df_equipment = pd.DataFrame(equipment_data_all)
            df_equipment.to_excel(writer, sheet_name='EquipmentRequired', index=False)
        else:
            df_equipment = pd.DataFrame(columns=['DocumentID', 'Quantity', 'PartNumber', 'Description', 'RowOrder'])
            df_equipment.to_excel(writer, sheet_name='EquipmentRequired', index=False)
        
        # Parts Required sheet
        if parts_data_all:
            df_parts = pd.DataFrame(parts_data_all)
            df_parts.to_excel(writer, sheet_name='PartsRequired', index=False)
        else:
            df_parts = pd.DataFrame(columns=['DocumentID', 'Quantity', 'PartNumber', 'Description', 'RowOrder'])
            df_parts.to_excel(writer, sheet_name='PartsRequired', index=False)
        
        # Revision History sheet
        if rev_history_all:
            df_rev = pd.DataFrame(rev_history_all)
            df_rev.to_excel(writer, sheet_name='RevisionHistory', index=False)
        else:
            df_rev = pd.DataFrame(columns=['DocumentID', 'RevNumber', 'ChangeDescription', 'ChangeDate', 'RowOrder'])
            df_rev.to_excel(writer, sheet_name='RevisionHistory', index=False)
        
        # Drafting sheet
        if drafting_all:
            df_draft = pd.DataFrame(drafting_all)
            df_draft.to_excel(writer, sheet_name='Drafting', index=False)
        else:
            df_draft = pd.DataFrame(columns=['DocumentID', 'Role', 'Signature', 'SignatureDate'])
            df_draft.to_excel(writer, sheet_name='Drafting', index=False)
        
        # Approvals sheet
        if approvals_all:
            df_approve = pd.DataFrame(approvals_all)
            df_approve.to_excel(writer, sheet_name='Approvals', index=False)
        else:
            df_approve = pd.DataFrame(columns=['DocumentID', 'Department', 'Signature', 'ApprovalDate'])
            df_approve.to_excel(writer, sheet_name='Approvals', index=False)
    
    # Apply formatting to all sheets
    print("Applying formatting...")
    workbook = load_workbook(output_excel)
    
    for sheet_name in workbook.sheetnames:
        worksheet = workbook[sheet_name]
        format_excel_sheet(worksheet)
    
    workbook.save(output_excel)
    
    print(f"\nExtraction complete!")
    print(f"Processed {doc_id - 1} documents")
    print(f"Total BOM entries: {len(bom_data_all)}")
    print(f"Total Equipment entries: {len(equipment_data_all)}")
    print(f"Total Parts entries: {len(parts_data_all)}")
    print(f"Total Revision History entries: {len(rev_history_all)}")
    print(f"Total Drafting entries: {len(drafting_all)}")
    print(f"Total Approval entries: {len(approvals_all)}")
    print(f"Saved to: {output_excel}")

if __name__ == "__main__":
    # CONFIGURE THESE PATHS
    input_folder = r"C:\Users\U309011\Desktop\New folder"
    output_excel = r"C:\Users\U309011\Desktop\WorkInstructions_Extracted.xlsx"
    
    print("=" * 70)
    print("WORK INSTRUCTION POWERPOINT TABLE EXTRACTOR")
    print("=" * 70)
    print(f"Input folder: {input_folder}")
    print(f"Output Excel: {output_excel}")
    print("=" * 70)
    
    # Run extraction
    process_powerpoint_files(input_folder, output_excel)
    
    print("\n" + "=" * 70)
    print("DONE! Open the Excel file to review extracted data.")
    print("=" * 70)
