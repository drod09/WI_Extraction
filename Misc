Ah, I see the issue! The `ExtractSlideSubject` method is separate from the header extraction logic. We need to update it to use the same position-based detection for Rev 15-16 vs Rev 17-19. Let me fix that:

```csharp
private string ExtractSlideSubject(Slide slide)
{
    try
    {
        // First, collect all text boxes from the slide
        var textBoxes = new List<TextBoxInfo>();
        CollectTextBoxes(slide.Shapes, textBoxes);

        // Detect revision type from the first slide (if we have it cached, use it)
        // For now, we'll detect it from each slide's master/layout
        string revisionType = DetectRevisionTypeFromSlide(slide);

        Console.WriteLine($"Slide {slide.SlideIndex}: Detected revision {revisionType}");

        // Extract subject based on revision type using position
        string subject = "";

        if (revisionType == "15" || revisionType == "16")
        {
            // Rev 15/16: Subject position - Left 420-430, Top 520-525 (or similar)
            // But for other slides, subject might be in title position
            subject = ExtractSubjectRev15_16(textBoxes);
        }
        else if (revisionType == "17" || revisionType == "18" || revisionType == "19")
        {
            // Rev 17/19: Subject position - Left 315-640, Top 495-510
            subject = ExtractSubjectRev17_19(textBoxes);
        }
        else
        {
            // Unknown revision - try standard title placeholder
            subject = ExtractSubjectFallback(slide);
        }

        if (!string.IsNullOrWhiteSpace(subject))
        {
            Console.WriteLine($"  Found subject: {subject}");
            return subject.ToUpper();
        }

        // If still not found, try the standard placeholder method
        subject = ExtractSubjectFallback(slide);
        
        if (!string.IsNullOrWhiteSpace(subject))
            return subject.ToUpper();

        return "UNTITLED SLIDE";
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Error extracting slide subject: {ex.Message}");
        return "UNTITLED SLIDE";
    }
}

private string DetectRevisionTypeFromSlide(Slide slide)
{
    try
    {
        // Check master shapes for FM-ME text
        var textBoxes = new List<TextBoxInfo>();
        
        try { CollectTextBoxes(slide.Master.Shapes, textBoxes); } catch { }
        try { CollectTextBoxes(slide.Design.SlideMaster.Shapes, textBoxes); } catch { }
        try { CollectTextBoxes(slide.CustomLayout.Shapes, textBoxes); } catch { }
        
        return DetectRevisionType(textBoxes);
    }
    catch
    {
        return "Unknown";
    }
}

private string ExtractSubjectRev15_16(List<TextBoxInfo> textBoxes)
{
    // For Rev 15/16, subject is typically in a specific position
    // Check multiple possible positions

    // Position 1: Left 420-430, Top 520-525 (header area)
    foreach (var box in textBoxes)
    {
        string text = box.Text.Trim();
        string upper = text.ToUpper();

        if (IsLabel(upper) || string.IsNullOrWhiteSpace(text)) continue;

        Console.WriteLine($"  Rev15-16 Subject check: Text='{text}', Left={box.Left:F1}, Top={box.Top:F1}");

        // Header position
        if (box.Left > 415 && box.Left < 435 && box.Top > 515 && box.Top < 530 &&
            text.Length > 3 && text.Length < 80)
        {
            return text;
        }
    }

    // Position 2: Top of slide (for subsequent slides) - Left 50-500, Top 30-80
    foreach (var box in textBoxes)
    {
        string text = box.Text.Trim();
        string upper = text.ToUpper();

        if (IsLabel(upper) || string.IsNullOrWhiteSpace(text)) continue;

        // Top of slide position
        if (box.Top > 25 && box.Top < 85 &&
            box.Left > 45 && box.Left < 505 &&
            text.Length > 3 && text.Length < 100)
        {
            return text;
        }
    }

    // Position 3: Largest font at top
    var topShapes = textBoxes
        .Where(b => b.Top < 100 && b.Text.Trim().Length > 3 && b.Text.Trim().Length < 100)
        .OrderByDescending(b => b.Height)
        .ThenBy(b => b.Top)
        .FirstOrDefault();

    if (topShapes != null)
        return topShapes.Text.Trim();

    return "";
}

private string ExtractSubjectRev17_19(List<TextBoxInfo> textBoxes)
{
    // For Rev 17/19, subject is typically in a specific position
    
    // Position 1: Left 315-640, Top 495-510 (header area)
    foreach (var box in textBoxes)
    {
        string text = box.Text.Trim();
        string upper = text.ToUpper();

        if (IsLabel(upper) || string.IsNullOrWhiteSpace(text)) continue;

        Console.WriteLine($"  Rev17-19 Subject check: Text='{text}', Left={box.Left:F1}, Top={box.Top:F1}");

        // Header position
        if (box.Left > 310 && box.Left < 645 && box.Top > 490 && box.Top < 515 &&
            text.Length > 3 && text.Length < 80)
        {
            return text;
        }
    }

    // Position 2: Top of slide (for subsequent slides) - Left 50-650, Top 30-100
    foreach (var box in textBoxes)
    {
        string text = box.Text.Trim();
        string upper = text.ToUpper();

        if (IsLabel(upper) || string.IsNullOrWhiteSpace(text)) continue;

        // Top of slide position
        if (box.Top > 25 && box.Top < 105 &&
            box.Left > 45 && box.Left < 655 &&
            text.Length > 3 && text.Length < 100)
        {
            return text;
        }
    }

    // Position 3: Largest font at top
    var topShapes = textBoxes
        .Where(b => b.Top < 120 && b.Text.Trim().Length > 3 && b.Text.Trim().Length < 100)
        .OrderByDescending(b => b.Height)
        .ThenBy(b => b.Top)
        .FirstOrDefault();

    if (topShapes != null)
        return topShapes.Text.Trim();

    return "";
}

private string ExtractSubjectFallback(Slide slide)
{
    try
    {
        // Check for title placeholder
        foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Shapes)
        {
            try
            {
                if (shape.Type == MsoShapeType.msoPlaceholder)
                {
                    var placeholder = shape.PlaceholderFormat;
                    if (placeholder.Type == PpPlaceholderType.ppPlaceholderTitle ||
                        placeholder.Type == PpPlaceholderType.ppPlaceholderCenterTitle)
                    {
                        if (shape.HasTextFrame == MsoTriState.msoTrue)
                        {
                            string titleText = shape.TextFrame.TextRange.Text.Trim();
                            if (!string.IsNullOrWhiteSpace(titleText))
                                return titleText;
                        }
                    }
                }
            }
            catch { }
        }

        // Find largest font at top of slide
        var topShapes = new List<(string text, float top, float fontSize)>();
        foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Shapes)
        {
            try
            {
                if (shape.HasTextFrame == MsoTriState.msoTrue && shape.Top < 100)
                {
                    string text = shape.TextFrame.TextRange.Text.Trim();
                    if (!string.IsNullOrWhiteSpace(text) && text.Length < 100)
                    {
                        float fontSize = 12;
                        try { fontSize = shape.TextFrame.TextRange.Font.Size; } catch { }
                        topShapes.Add((text, shape.Top, fontSize));
                    }
                }
            }
            catch { }
        }

        if (topShapes.Count > 0)
        {
            var largestFont = topShapes.OrderByDescending(s => s.fontSize).ThenBy(s => s.top).First();
            return largestFont.text;
        }

        return "";
    }
    catch
    {
        return "";
    }
}
```

The key changes:

1. **`ExtractSlideSubject` now detects revision type** for each slide and uses position-based extraction
1. **Separate methods for Rev 15-16 vs 17-19** subject extraction with specific position ranges
1. **Multiple position checks**:

- First checks the header area position (where subject appears on slide 1)
- Then checks top of slide (where subject typically appears on slides 2+)
- Finally falls back to largest font at top

1. **Console logging** to help debug which positions are being detected

The subject should now be consistent across Header Data, Table of Contents, and Text Content sheets. Test it and let me know if the positions need adjustment based on your actual slide layouts!​​​​​​​​​​​​​​​​