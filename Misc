Here’s the complete code for all the classes that have been revised:

## **1. MainWindow.xaml.cs** (Complete File)

```csharp
using CsvHelper;
using Microsoft.Office.Core;
using Microsoft.Office.Interop.PowerPoint;
using Microsoft.Win32;
using Ookii.Dialogs.Wpf;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Shapes;

namespace WorkInstructionLabeler
{
    public partial class MainWindow : Window
    {
        private List<PowerPointFileInfo> _powerPointFiles = new List<PowerPointFileInfo>();
        private PowerPointFileInfo _currentFile;
        private int _currentSlideIndex = 0;
        private List<LabeledTextBox> _allLabeledBoxes = new List<LabeledTextBox>();
        private LabeledTextBox _selectedTextBox;
        private Dictionary<Border, LabeledTextBox> _borderToTextBoxMap = new Dictionary<Border, LabeledTextBox>();
        private double _zoomLevel = 1.0;

        public MainWindow()
        {
            InitializeComponent();
        }

        private void BtnMarkComplete_Click(object sender, RoutedEventArgs e)
        {
            if (_currentFile == null)
            {
                MessageBox.Show("No file is currently loaded.", "No File",
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            // Check if required fields are labeled
            var missingLabels = CheckRequiredLabels();

            if (missingLabels.Count > 0)
            {
                var result = MessageBox.Show(
                    $"The following fields are not labeled:\n\n{string.Join("\n", missingLabels)}\n\n" +
                    "Do you want to mark this file as complete anyway?",
                    "Missing Labels",
                    MessageBoxButton.YesNo,
                    MessageBoxImage.Warning);

                if (result == MessageBoxResult.No)
                    return;
            }

            // Mark as completed
            _currentFile.IsCompleted = true;
            _currentFile.IsLabeled = true;

            UpdateProgress();

            // Show success message
            MessageBox.Show(
                $"✓ File marked as complete!\n\n{_currentFile.FileName}\n\n" +
                "You can now move to the next file.",
                "File Completed",
                MessageBoxButton.OK,
                MessageBoxImage.Information);

            // Auto-select next file
            int currentIndex = _powerPointFiles.IndexOf(_currentFile);
            if (currentIndex < _powerPointFiles.Count - 1)
            {
                lstFiles.SelectedIndex = currentIndex + 1;
            }
        }

        private List<string> CheckRequiredLabels()
        {
            var missingLabels = new List<string>();
            var requiredLabels = new[]
            {
                "WI_Number",
                "WI_Title",
                "Revision",
                "BOM_ASSY_DWG_NO",
                "Operation_No",
                "Product_Line",
                "Subject",
                "Template_Revision"
            };

            var labeledFields = _allLabeledBoxes
                .Where(b => b.SourceFile == _currentFile.FilePath && !b.IsHidden)
                .Select(b => b.AssignedLabel)
                .Where(l => !string.IsNullOrEmpty(l) && l != "Ignore")
                .Distinct()
                .ToList();

            var labelNameMap = new Dictionary<string, string>
            {
                { "WI_Number", "WI Number" },
                { "WI_Title", "WI Title" },
                { "Revision", "Revision" },
                { "BOM_ASSY_DWG_NO", "BOM/ASSY DWG NO" },
                { "Operation_No", "Operation No" },
                { "Product_Line", "Product Line" },
                { "Subject", "Subject" },
                { "Template_Revision", "Template Revision" }
            };

            foreach (var required in requiredLabels)
            {
                if (!labeledFields.Contains(required))
                {
                    missingLabels.Add("  • " + labelNameMap[required]);
                }
            }

            return missingLabels;
        }

        private void BtnHideBox_Click(object sender, RoutedEventArgs e)
        {
            if (_selectedTextBox == null)
            {
                MessageBox.Show("Please select a text box first", "No Selection",
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            // Mark as hidden
            _selectedTextBox.IsHidden = true;

            // Refresh display
            DisplaySlide(_currentSlideIndex);

            // Clear selection
            _selectedTextBox = null;
            txtSelectedText.Text = "Text box hidden";
            txtPosition.Text = "";
        }

        private List<string> CheckRequiredLabelsForFile(string filePath)
        {
            var missingLabels = new List<string>();
            var requiredLabels = new[]
            {
                "WI_Number",
                "WI_Title",
                "Revision",
                "BOM_ASSY_DWG_NO",
                "Operation_No",
                "Product_Line",
                "Subject",
                "Template_Revision"
            };

            var labeledFields = _allLabeledBoxes
                .Where(b => b.SourceFile == filePath && !b.IsHidden)
                .Select(b => b.AssignedLabel)
                .Where(l => !string.IsNullOrEmpty(l) && l != "Ignore")
                .Distinct()
                .ToList();

            var labelNameMap = new Dictionary<string, string>
            {
                { "WI_Number", "WI Number" },
                { "WI_Title", "WI Title" },
                { "Revision", "Revision" },
                { "BOM_ASSY_DWG_NO", "BOM/ASSY DWG NO" },
                { "Operation_No", "Operation No" },
                { "Product_Line", "Product Line" },
                { "Subject", "Subject" },
                { "Template_Revision", "Template Revision" }
            };

            foreach (var required in requiredLabels)
            {
                if (!labeledFields.Contains(required))
                {
                    missingLabels.Add("  • " + labelNameMap[required]);
                }
            }

            return missingLabels;
        }

        private void BtnLoadFolder_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new VistaFolderBrowserDialog
            {
                Description = "Select folder containing PowerPoint work instructions",
                UseDescriptionForTitle = true
            };

            if (dialog.ShowDialog(this) == true)
            {
                LoadPowerPointFiles(dialog.SelectedPath);
            }
        }

        private void BtnZoomIn_Click(object sender, RoutedEventArgs e)
        {
            _zoomLevel = Math.Min(_zoomLevel + 0.25, 3.0);
            ApplyZoom();
        }

        private void BtnZoomOut_Click(object sender, RoutedEventArgs e)
        {
            _zoomLevel = Math.Max(_zoomLevel - 0.25, 0.5);
            ApplyZoom();
        }

        private void BtnZoomFit_Click(object sender, RoutedEventArgs e)
        {
            _zoomLevel = 1.0;
            ApplyZoom();
        }

        private void ApplyZoom()
        {
            var scaleTransform = new ScaleTransform(_zoomLevel, _zoomLevel);
            slideCanvas.LayoutTransform = scaleTransform;
            slideCanvas.Width = 960 * _zoomLevel;
            slideCanvas.Height = 720 * _zoomLevel;
            txtZoom.Text = $"{_zoomLevel * 100:F0}%";
        }

        private void LoadPowerPointFiles(string folderPath)
        {
            _powerPointFiles.Clear();
            lstFiles.Items.Clear();

            var files = Directory.GetFiles(folderPath, "*.pptx")
                .Where(f => !System.IO.Path.GetFileName(f).StartsWith("~$"))
                .ToList();

            foreach (var file in files)
            {
                var fileInfo = new PowerPointFileInfo
                {
                    FilePath = file,
                    FileName = System.IO.Path.GetFileName(file),
                    IsLabeled = false,
                    IsCompleted = false
                };

                _powerPointFiles.Add(fileInfo);
                lstFiles.Items.Add(fileInfo);
            }

            UpdateProgress();

            if (_powerPointFiles.Count > 0)
            {
                lstFiles.SelectedIndex = 0;
            }
        }

        private void LstFiles_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            // Check if user is leaving a file without completing it
            if (e.RemovedItems.Count > 0 && e.RemovedItems[0] is PowerPointFileInfo previousFile)
            {
                // Check if previous file was completed
                if (!previousFile.IsCompleted)
                {
                    var missingLabels = CheckRequiredLabelsForFile(previousFile.FilePath);

                    if (missingLabels.Count > 0)
                    {
                        var result = MessageBox.Show(
                            $"You haven't completed labeling the previous file:\n{previousFile.FileName}\n\n" +
                            $"Missing labels:\n{string.Join("\n", missingLabels)}\n\n" +
                            "Do you want to continue to the next file without completing it?",
                            "Incomplete File",
                            MessageBoxButton.YesNo,
                            MessageBoxImage.Warning);

                        if (result == MessageBoxResult.No)
                        {
                            // Prevent changing selection
                            lstFiles.SelectionChanged -= LstFiles_SelectionChanged;
                            lstFiles.SelectedItem = previousFile;
                            lstFiles.SelectionChanged += LstFiles_SelectionChanged;
                            return;
                        }
                    }
                }
            }

            // Load the newly selected file
            if (lstFiles.SelectedItem is PowerPointFileInfo fileInfo)
            {
                LoadPowerPointFile(fileInfo);
            }
        }

        private void LoadPowerPointFile(PowerPointFileInfo fileInfo)
        {
            _currentFile = fileInfo;
            _currentSlideIndex = 0;

            txtFileName.Text = fileInfo.FileName;

            // Extract text boxes from PowerPoint
            ExtractTextBoxesFromPowerPoint(fileInfo.FilePath);

            // Display first slide
            DisplaySlide(_currentSlideIndex);
        }

        private void ExtractTextBoxesFromPowerPoint(string filePath)
        {
            var pptApp = new Microsoft.Office.Interop.PowerPoint.Application();

            try
            {
                Presentation ppt = pptApp.Presentations.Open(filePath,
                    MsoTriState.msoFalse, MsoTriState.msoFalse, MsoTriState.msoFalse);

                // Detect revision type
                string revType = DetectRevisionType(ppt);
                
                if (revType == "Unknown")
                {
                    txtRevType.Text = "Template: Unknown";
                    txtRevType.Foreground = new SolidColorBrush(Colors.Orange);
                }
                else
                {
                    txtRevType.Text = $"Template: Rev {revType}";
                    txtRevType.Foreground = new SolidColorBrush(Color.FromRgb(76, 175, 80));
                }

                // Clear previous data for this file
                _allLabeledBoxes.RemoveAll(b => b.SourceFile == filePath);

                // Extract from first slide only (for header data)
                if (ppt.Slides.Count > 0)
                {
                    Slide slide = ppt.Slides[1];
                    var textBoxes = new List<TextBoxInfo>();

                    Console.WriteLine($"\n=== Extracting text boxes from {System.IO.Path.GetFileName(filePath)} ===");

                    // 1. Collect from SLIDE SHAPES (directly on slide)
                    Console.WriteLine("Collecting from Slide Shapes...");
                    CollectTextBoxes(slide.Shapes, textBoxes, "Slide");

                    // 2. Collect from MASTER SLIDE
                    try
                    {
                        Console.WriteLine("Collecting from Master Slide...");
                        CollectTextBoxes(slide.Master.Shapes, textBoxes, "Master");
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"  Could not access Master: {ex.Message}");
                    }

                    // 3. Collect from SLIDE MASTER (Design)
                    try
                    {
                        Console.WriteLine("Collecting from Slide Master (Design)...");
                        CollectTextBoxes(slide.Design.SlideMaster.Shapes, textBoxes, "Design");
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"  Could not access Design: {ex.Message}");
                    }

                    // 4. Collect from CUSTOM LAYOUT
                    try
                    {
                        Console.WriteLine("Collecting from Custom Layout...");
                        CollectTextBoxes(slide.CustomLayout.Shapes, textBoxes, "CustomLayout");
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"  Could not access CustomLayout: {ex.Message}");
                    }

                    Console.WriteLine($"Total text boxes collected: {textBoxes.Count}");

                    // Remove duplicates (same text at same position)
                    var uniqueBoxes = textBoxes
                        .GroupBy(b => new { b.Text, Left = Math.Round(b.Left, 1), Top = Math.Round(b.Top, 1) })
                        .Select(g => g.First())
                        .ToList();

                    Console.WriteLine($"After removing duplicates: {uniqueBoxes.Count}");

                    // Convert to LabeledTextBox
                    foreach (var box in uniqueBoxes)
                    {
                        if (string.IsNullOrWhiteSpace(box.Text))
                            continue;

                        _allLabeledBoxes.Add(new LabeledTextBox
                        {
                            Text = box.Text,
                            Left = box.Left,
                            Top = box.Top,
                            Width = box.Width,
                            Height = box.Height,
                            RevisionType = revType,
                            SourceFile = filePath,
                            SlideNumber = 1,
                            AssignedLabel = null,
                            IsHidden = false
                        });

                        Console.WriteLine($"  Added: '{box.Text.Substring(0, Math.Min(30, box.Text.Length))}' at ({box.Left:F1}, {box.Top:F1})");
                    }
                }

                txtSlideInfo.Text = $"Slide 1 of {ppt.Slides.Count}";

                ppt.Close();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error loading PowerPoint:\n{ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                pptApp.Quit();
            }
        }

        private string DetectRevisionType(Presentation ppt)
        {
            if (ppt.Slides.Count > 0)
            {
                Slide slide = ppt.Slides[1];
                var candidateBoxes = new List<(string text, float left, float top)>();

                // Collect text from ALL sources (slide, master, custom layout)
                void CollectCandidates(Microsoft.Office.Interop.PowerPoint.Shapes shapes, string source)
                {
                    foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in shapes)
                    {
                        try
                        {
                            if (shape.Type == MsoShapeType.msoGroup)
                            {
                                try
                                {
                                    CollectCandidates(shape.GroupItems, source + "-Group");
                                }
                                catch { }
                            }
                            else if (shape.HasTextFrame == MsoTriState.msoTrue)
                            {
                                try
                                {
                                    string text = shape.TextFrame.TextRange.Text.Trim();
                                    if (!string.IsNullOrEmpty(text))
                                    {
                                        candidateBoxes.Add((text, shape.Left, shape.Top));
                                    }
                                }
                                catch { }
                            }
                        }
                        catch { }
                    }
                }

                Console.WriteLine("\n=== Searching for Template Revision ===");

                // Collect from all sources
                try { CollectCandidates(slide.Shapes, "Slide"); } catch { }
                try { CollectCandidates(slide.Master.Shapes, "Master"); } catch { }
                try { CollectCandidates(slide.Design.SlideMaster.Shapes, "Design"); } catch { }
                try { CollectCandidates(slide.CustomLayout.Shapes, "CustomLayout"); } catch { }

                Console.WriteLine($"\nTotal text boxes found: {candidateBoxes.Count}");

                // Show ALL boxes sorted by position (for debugging)
                var sortedBoxes = candidateBoxes
                    .OrderByDescending(b => b.top)
                    .ThenByDescending(b => b.left)
                    .ToList();

                Console.WriteLine("\nAll text boxes (sorted by position, bottom-to-top, right-to-left):");
                foreach (var box in sortedBoxes.Take(20)) // Show first 20
                {
                    Console.WriteLine($"  Left:{box.left,7:F1} Top:{box.top,7:F1} | '{box.text.Substring(0, Math.Min(40, box.text.Length))}'");
                }

                // Filter for bottom-right area
                var bottomRightBoxes = candidateBoxes
                    .Where(b => b.left > 300 && b.top > 450)
                    .OrderByDescending(b => b.left)
                    .ThenByDescending(b => b.top)
                    .ToList();

                Console.WriteLine($"\n=== Bottom-Right Area (Left > 300, Top > 450) ===");
                Console.WriteLine($"Found {bottomRightBoxes.Count} text boxes:");
                foreach (var box in bottomRightBoxes)
                {
                    Console.WriteLine($"  Left:{box.left,7:F1} Top:{box.top,7:F1} | '{box.text}'");
                }

                // Search patterns
                var fmmePatterns = new[]
                {
                    @"fm[-_\s]*me[-_\s]*\d+",
                    @"fm[-_\s]*\d+",
                    @"fmme",
                };

                var revPatterns = new[]
                {
                    @"rev\.?\s*(\d+)",
                    @"revision\s*(\d+)",
                    @"r\.?\s*(\d+)",
                    @"-(\d+)$",
                    @"\b(\d{2})\b",
                };

                // Strategy 1: Look for FM-ME pattern in bottom-right
                Console.WriteLine("\n--- Strategy 1: FM-ME text with revision ---");
                foreach (var box in bottomRightBoxes)
                {
                    string text = box.text.ToLower();
                    bool hasFMME = fmmePatterns.Any(p => Regex.IsMatch(text, p, RegexOptions.IgnoreCase));

                    if (hasFMME)
                    {
                        Console.WriteLine($"✓ Found FM-ME text: '{box.text}'");

                        foreach (var pattern in revPatterns)
                        {
                            var match = Regex.Match(text, pattern, RegexOptions.IgnoreCase);
                            if (match.Success && match.Groups.Count > 1)
                            {
                                string revNum = match.Groups[1].Value;
                                if (int.TryParse(revNum, out int num) && num >= 10 && num <= 30)
                                {
                                    Console.WriteLine($"✓✓ FOUND TEMPLATE REVISION: {revNum}");
                                    return revNum;
                                }
                            }
                        }
                    }
                }

                // Strategy 2: Look for separate revision box near FM-ME
                Console.WriteLine("\n--- Strategy 2: Separate revision box ---");
                var fmmeBox = bottomRightBoxes.FirstOrDefault(b =>
                    fmmePatterns.Any(p => Regex.IsMatch(b.text.ToLower(), p, RegexOptions.IgnoreCase)));

                if (fmmeBox.text != null)
                {
                    Console.WriteLine($"✓ Found FM-ME box at Left:{fmmeBox.left:F1}, Top:{fmmeBox.top:F1}");
                    Console.WriteLine($"  Text: '{fmmeBox.text}'");
                    Console.WriteLine("  Looking for nearby revision box...");

                    var nearbyBoxes = candidateBoxes
                        .Where(b => b.left < fmmeBox.left &&
                                   b.left > fmmeBox.left - 300 &&
                                   Math.Abs(b.top - fmmeBox.top) < 100)
                        .OrderByDescending(b => b.left)
                        .ToList();

                    Console.WriteLine($"  Found {nearbyBoxes.Count} nearby boxes:");
                    foreach (var box in nearbyBoxes)
                    {
                        Console.WriteLine($"    Left:{box.left,7:F1} Top:{box.top,7:F1} | '{box.text}'");

                        foreach (var pattern in revPatterns)
                        {
                            var match = Regex.Match(box.text, pattern, RegexOptions.IgnoreCase);
                            if (match.Success && match.Groups.Count > 1)
                            {
                                string revNum = match.Groups[1].Value;
                                if (int.TryParse(revNum, out int num) && num >= 10 && num <= 30)
                                {
                                    Console.WriteLine($"    ✓✓ FOUND TEMPLATE REVISION: {revNum}");
                                    return revNum;
                                }
                            }
                        }

                        if (Regex.IsMatch(box.text.Trim(), @"^\d{2}$"))
                        {
                            Console.WriteLine($"    ✓✓ FOUND TEMPLATE REVISION (number): {box.text.Trim()}");
                            return box.text.Trim();
                        }
                    }
                }

                // Strategy 3: Broader search in entire bottom area
                Console.WriteLine("\n--- Strategy 3: Broader bottom area search ---");
                var bottomBoxes = candidateBoxes.Where(b => b.top > 400).ToList();

                foreach (var box in bottomBoxes)
                {
                    string text = box.text.ToLower();
                    bool hasFMME = fmmePatterns.Any(p => Regex.IsMatch(text, p, RegexOptions.IgnoreCase));
                    bool hasRev = Regex.IsMatch(text, @"rev", RegexOptions.IgnoreCase);

                    if (hasFMME || hasRev)
                    {
                        Console.WriteLine($"  Checking: '{box.text}' at Left:{box.left:F1}, Top:{box.top:F1}");

                        foreach (var pattern in revPatterns)
                        {
                            var match = Regex.Match(text, pattern, RegexOptions.IgnoreCase);
                            if (match.Success && match.Groups.Count > 1)
                            {
                                string revNum = match.Groups[1].Value;
                                if (int.TryParse(revNum, out int num) && num >= 10 && num <= 30)
                                {
                                    Console.WriteLine($"  ✓✓ FOUND TEMPLATE REVISION: {revNum}");
                                    return revNum;
                                }
                            }
                        }
                    }
                }

                Console.WriteLine("\n✗✗ Template revision NOT FOUND");
            }

            return "Unknown";
        }

        private void CollectTextBoxes(Microsoft.Office.Interop.PowerPoint.Shapes shapes,
            List<TextBoxInfo> textBoxes, string source = "Unknown")
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in shapes)
            {
                try
                {
                    if (shape.Type == MsoShapeType.msoGroup)
                    {
                        CollectTextBoxesFromGroup(shape.GroupItems, textBoxes, source);
                    }
                    else if (shape.HasTextFrame == MsoTriState.msoTrue)
                    {
                        try
                        {
                            string text = shape.TextFrame.TextRange.Text.Trim();
                            if (!string.IsNullOrEmpty(text))
                            {
                                textBoxes.Add(new TextBoxInfo
                                {
                                    Text = text,
                                    Left = shape.Left,
                                    Top = shape.Top,
                                    Width = shape.Width,
                                    Height = shape.Height
                                });

                                Console.WriteLine($"  [{source}] '{text.Substring(0, Math.Min(20, text.Length))}...' at ({shape.Left:F1}, {shape.Top:F1})");
                            }
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"  [{source}] Error reading text: {ex.Message}");
                        }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"  [{source}] Error processing shape: {ex.Message}");
                }
            }
        }

        private void CollectTextBoxesFromGroup(Microsoft.Office.Interop.PowerPoint.GroupShapes groupShapes,
            List<TextBoxInfo> textBoxes, string source = "Unknown")
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in groupShapes)
            {
                try
                {
                    if (shape.Type == MsoShapeType.msoGroup)
                    {
                        CollectTextBoxesFromGroup(shape.GroupItems, textBoxes, source);
                    }
                    else if (shape.HasTextFrame == MsoTriState.msoTrue)
                    {
                        try
                        {
                            string text = shape.TextFrame.TextRange.Text.Trim();
                            if (!string.IsNullOrEmpty(text))
                            {
                                textBoxes.Add(new TextBoxInfo
                                {
                                    Text = text,
                                    Left = shape.Left,
                                    Top = shape.Top,
                                    Width = shape.Width,
                                    Height = shape.Height
                                });
                            }
                        }
                        catch { }
                    }
                }
                catch { }
            }
        }

        private bool IsLabel(string upperText)
        {
            var labels = new[] {
                "WORK INSTRUCTION TITLE", "WORK INSTRUCTION", "DESCRIPTION", "DESCRIPTION:",
                "W.I. NUMBER", "WI NUMBER", "BOM/ASSY DWG NO", "BOM DWG NO", "ASSY DWG NO",
                "OPS (OPTIONAL)", "OPERATION NO", "OPERATION NO.", "PRODUCT LINE",
                "SUBJECT", "SUBJECT:", "PAGE", "REV", "REV:", "REVISION", "REVISION:"
            };

            return labels.Any(label => upperText == label || (upperText.Contains(label) && upperText.Length < 40)) ||
                   (upperText.EndsWith(":") && upperText.Length < 25);
        }

        private void DisplaySlide(int slideIndex)
        {
            slideCanvas.Children.Clear();
            _borderToTextBoxMap.Clear();

            var slideBoxes = _allLabeledBoxes
                .Where(b => b.SourceFile == _currentFile.FilePath &&
                            b.SlideNumber == slideIndex + 1 &&
                            !b.IsHidden)
                .ToList();

            Console.WriteLine($"\nDisplaying {slideBoxes.Count} text boxes on canvas (hidden boxes excluded)");

            float scaleFactor = 1.0f;

            foreach (var box in slideBoxes)
            {
                var border = new Border
                {
                    Width = Math.Max(box.Width * scaleFactor, 50),
                    Height = Math.Max(box.Height * scaleFactor, 20),
                    Cursor = System.Windows.Input.Cursors.Hand,
                    ToolTip = box.Text
                };

                border.Style = GetStyleForLabel(box.AssignedLabel);

                var textBlock = new TextBlock
                {
                    Text = box.Text,
                    TextWrapping = TextWrapping.Wrap,
                    Padding = new Thickness(3),
                    FontSize = 9,
                    TextTrimming = TextTrimming.CharacterEllipsis,
                    VerticalAlignment = VerticalAlignment.Center
                };

                border.Child = textBlock;

                Canvas.SetLeft(border, box.Left * scaleFactor);
                Canvas.SetTop(border, box.Top * scaleFactor);

                border.MouseDown += (s, e) =>
                {
                    SelectTextBox(box, border);
                };

                slideCanvas.Children.Add(border);
                _borderToTextBoxMap[border] = box;

                Console.WriteLine($"  Displayed '{box.Text.Substring(0, Math.Min(15, box.Text.Length))}' at ({box.Left:F1}, {box.Top:F1})");
            }

            Console.WriteLine($"Canvas updated with {slideCanvas.Children.Count} visual elements");
        }

        private Style GetStyleForLabel(string label)
        {
            if (string.IsNullOrEmpty(label))
                return (Style)FindResource("UnlabeledBox");

            return label switch
            {
                "WI_Number" => (Style)FindResource("WINumberBox"),
                "WI_Title" => (Style)FindResource("TitleBox"),
                "Revision" => (Style)FindResource("RevisionBox"),
                "BOM_ASSY_DWG_NO" => (Style)FindResource("BOMBox"),
                "Operation_No" => (Style)FindResource("OperationBox"),
                "Product_Line" => (Style)FindResource("ProductLineBox"),
                "Subject" => (Style)FindResource("SubjectBox"),
                "Template_Revision" => (Style)FindResource("TemplateRevisionBox"),
                _ => (Style)FindResource("UnlabeledBox")
            };
        }

        private void SelectTextBox(LabeledTextBox box, Border border)
        {
            _selectedTextBox = box;

            foreach (var kvp in _borderToTextBoxMap)
            {
                if (kvp.Value == box)
                    kvp.Key.BorderThickness = new Thickness(4);
                else
                    kvp.Key.BorderThickness = new Thickness(2);
            }

            txtSelectedText.Text = box.Text;
            txtPosition.Text = $"Left: {box.Left:F1}, Top: {box.Top:F1}, W: {box.Width:F1}, H: {box.Height:F1}";
        }

        private​​​​​​​​​​​​​​​​
```
```csharp
        private void BtnLabel_Click(object sender, RoutedEventArgs e)
        {
            if (_selectedTextBox == null)
            {
                MessageBox.Show("Please select a text box first", "No Selection",
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            var button = sender as Button;
            string label = button.Tag.ToString();

            _selectedTextBox.AssignedLabel = label;

            // Refresh display
            DisplaySlide(_currentSlideIndex);

            // Mark file as having changes
            _currentFile.IsLabeled = true;

            // CAPTURE THE ACTUAL VALUE
            CaptureExtractedValue(label, _selectedTextBox.Text);

            UpdateProgress();
        }

        private void CaptureExtractedValue(string label, string value)
        {
            if (_currentFile == null) return;

            switch (label)
            {
                case "WI_Number":
                    _currentFile.ExtractedWINumber = value;
                    break;
                case "WI_Title":
                    _currentFile.ExtractedTitle = value;
                    break;
                case "Revision":
                    _currentFile.ExtractedRevision = value;
                    break;
                case "BOM_ASSY_DWG_NO":
                    _currentFile.ExtractedBOM = value;
                    break;
                case "Operation_No":
                    _currentFile.ExtractedOperationNo = value;
                    break;
                case "Product_Line":
                    _currentFile.ExtractedProductLine = value;
                    break;
                case "Subject":
                    _currentFile.ExtractedSubject = value;
                    break;
                case "Page_No":
                    _currentFile.ExtractedPageNo = ParsePageNumber(value);
                    break;
                case "Template_Revision":
                    _currentFile.ExtractedTemplateRev = ParseTemplateRevision(value);
                    break;
            }

            Console.WriteLine($"Captured: {label} = '{value}'");
        }

        private string ParseTemplateRevision(string templateText)
        {
            if (string.IsNullOrWhiteSpace(templateText))
                return "";

            Console.WriteLine($"\n=== Parsing Template Revision ===");
            Console.WriteLine($"Input: '{templateText}'");

            // Pattern: FM-ME-07revX or FM-ME-07 revX or FM-ME-07 rev X
            var revMatch = Regex.Match(templateText,
                @"fm[-_\s]*me[-_\s]*\d+\s*rev\.?\s*(\d+)",
                RegexOptions.IgnoreCase);

            if (revMatch.Success && revMatch.Groups.Count > 1)
            {
                string revision = revMatch.Groups[1].Value;
                Console.WriteLine($"✓ Extracted revision: {revision}");
                return revision;
            }

            // Fallback: Look for any 2-digit number after "rev"
            revMatch = Regex.Match(templateText, @"rev\.?\s*(\d{1,2})", RegexOptions.IgnoreCase);
            if (revMatch.Success && revMatch.Groups.Count > 1)
            {
                string revision = revMatch.Groups[1].Value;
                Console.WriteLine($"✓ Extracted revision (fallback): {revision}");
                return revision;
            }

            // If no pattern found, just return first 2-digit number
            revMatch = Regex.Match(templateText, @"\b(\d{2})\b");
            if (revMatch.Success)
            {
                Console.WriteLine($"✓ Extracted revision (number only): {revMatch.Groups[1].Value}");
                return revMatch.Groups[1].Value;
            }

            Console.WriteLine($"✗ Could not parse revision");
            return templateText; // Return original if can't parse
        }

        private string ParsePageNumber(string pageText)
        {
            if (string.IsNullOrWhiteSpace(pageText))
                return "";

            // Pattern: "Page X of Y" or "Page X"
            var match = Regex.Match(pageText, @"page\s*(\d+)", RegexOptions.IgnoreCase);
            if (match.Success)
                return match.Groups[1].Value;

            // Pattern: "X of Y" or "X/Y"
            match = Regex.Match(pageText, @"(\d+)\s*(?:of|/)\s*\d+", RegexOptions.IgnoreCase);
            if (match.Success)
                return match.Groups[1].Value;

            // Just return the text if no pattern
            return pageText;
        }

        private void BtnClearLabel_Click(object sender, RoutedEventArgs e)
        {
            if (_selectedTextBox == null) return;

            string previousLabel = _selectedTextBox.AssignedLabel;
            _selectedTextBox.AssignedLabel = null;

            // Clear the extracted value
            if (!string.IsNullOrEmpty(previousLabel))
            {
                ClearExtractedValue(previousLabel);
            }

            DisplaySlide(_currentSlideIndex);
        }

        private void ClearExtractedValue(string label)
        {
            if (_currentFile == null) return;

            switch (label)
            {
                case "WI_Number":
                    _currentFile.ExtractedWINumber = null;
                    break;
                case "WI_Title":
                    _currentFile.ExtractedTitle = null;
                    break;
                case "Revision":
                    _currentFile.ExtractedRevision = null;
                    break;
                case "BOM_ASSY_DWG_NO":
                    _currentFile.ExtractedBOM = null;
                    break;
                case "Operation_No":
                    _currentFile.ExtractedOperationNo = null;
                    break;
                case "Product_Line":
                    _currentFile.ExtractedProductLine = null;
                    break;
                case "Subject":
                    _currentFile.ExtractedSubject = null;
                    break;
                case "Page_No":
                    _currentFile.ExtractedPageNo = null;
                    break;
                case "Template_Revision":
                    _currentFile.ExtractedTemplateRev = null;
                    break;
            }
        }

        private void BtnPrevSlide_Click(object sender, RoutedEventArgs e)
        {
            if (_currentSlideIndex > 0)
            {
                _currentSlideIndex--;
                DisplaySlide(_currentSlideIndex);
                txtSlideInfo.Text = $"Slide {_currentSlideIndex + 1}";
            }
        }

        private void BtnNextSlide_Click(object sender, RoutedEventArgs e)
        {
            MessageBox.Show("Currently only labeling slide 1 (header data)", "Info");
        }

        private void BtnSaveTrainingData_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new SaveFileDialog
            {
                Filter = "CSV Files (*.csv)|*.csv",
                FileName = "training_data_with_values.csv"
            };

            if (dialog.ShowDialog() == true)
            {
                SaveTrainingDataToCSV(dialog.FileName);

                int filesWithData = _powerPointFiles.Count(f =>
                    !string.IsNullOrEmpty(f.ExtractedWINumber) ||
                    !string.IsNullOrEmpty(f.ExtractedTitle));

                int labeledBoxes = _allLabeledBoxes.Count(b =>
                    !string.IsNullOrEmpty(b.AssignedLabel) &&
                    !b.IsHidden &&
                    b.AssignedLabel != "Ignore");

                MessageBox.Show(
                    $"Training data saved!\n\n" +
                    $"File: {dialog.FileName}\n\n" +
                    $"Files with extracted values: {filesWithData}\n" +
                    $"Total labeled text boxes: {labeledBoxes}\n\n" +
                    $"This file contains:\n" +
                    $"• Extracted values (for human review)\n" +
                    $"• Text box positions (for ML training)",
                    "Success",
                    MessageBoxButton.OK,
                    MessageBoxImage.Information);
            }
        }

        private void SaveTrainingDataToCSV(string filePath)
        {
            using (var writer = new StreamWriter(filePath))
            using (var csv = new CsvWriter(writer, CultureInfo.InvariantCulture))
            {
                // Write comprehensive headers
                csv.WriteField("FileName");
                csv.WriteField("WI_Number");
                csv.WriteField("WI_Title");
                csv.WriteField("Revision");
                csv.WriteField("BOM_ASSY_DWG_NO");
                csv.WriteField("Operation_No");
                csv.WriteField("Product_Line");
                csv.WriteField("Subject");
                csv.WriteField("Page_No");
                csv.WriteField("Template_Rev");
                csv.WriteField("TextBoxText");
                csv.WriteField("Left");
                csv.WriteField("Top");
                csv.WriteField("Width");
                csv.WriteField("Height");
                csv.WriteField("TextLength");
                csv.WriteField("ContainsNumbers");
                csv.WriteField("ContainsHyphen");
                csv.WriteField("StartsWithWI");
                csv.WriteField("IsAllDigits");
                csv.WriteField("RevisionType");
                csv.WriteField("Label");
                csv.NextRecord();

                // Group labeled boxes by file
                var fileGroups = _allLabeledBoxes
                    .Where(b => !string.IsNullOrEmpty(b.AssignedLabel) &&
                               !b.IsHidden &&
                               b.AssignedLabel != "Ignore")
                    .GroupBy(b => b.SourceFile);

                foreach (var fileGroup in fileGroups)
                {
                    // Find the file info for this group
                    var fileInfo = _powerPointFiles.FirstOrDefault(f => f.FilePath == fileGroup.Key);

                    string fileName = fileInfo?.FileName ?? System.IO.Path.GetFileName(fileGroup.Key);
                    string wiNumber = fileInfo?.ExtractedWINumber ?? "";
                    string wiTitle = fileInfo?.ExtractedTitle ?? "";
                    string revision = fileInfo?.ExtractedRevision ?? "";
                    string bom = fileInfo?.ExtractedBOM ?? "";
                    string opNo = fileInfo?.ExtractedOperationNo ?? "";
                    string productLine = fileInfo?.ExtractedProductLine ?? "";
                    string subject = fileInfo?.ExtractedSubject ?? "";
                    string pageNo = fileInfo?.ExtractedPageNo ?? "";
                    string templateRev = fileInfo?.ExtractedTemplateRev ?? "";

                    // Write each labeled text box with the file's extracted values
                    foreach (var box in fileGroup)
                    {
                        csv.WriteField(fileName);
                        csv.WriteField(wiNumber);
                        csv.WriteField(wiTitle);
                        csv.WriteField(revision);
                        csv.WriteField(bom);
                        csv.WriteField(opNo);
                        csv.WriteField(productLine);
                        csv.WriteField(subject);
                        csv.WriteField(pageNo);
                        csv.WriteField(templateRev);
                        csv.WriteField(box.Text);
                        csv.WriteField(box.Left);
                        csv.WriteField(box.Top);
                        csv.WriteField(box.Width);
                        csv.WriteField(box.Height);
                        csv.WriteField(box.Text.Length);
                        csv.WriteField(Regex.IsMatch(box.Text, @"\d"));
                        csv.WriteField(box.Text.Contains("-"));
                        csv.WriteField(box.Text.StartsWith("WI", StringComparison.OrdinalIgnoreCase));
                        csv.WriteField(Regex.IsMatch(box.Text, @"^\d+$"));
                        csv.WriteField(box.RevisionType);
                        csv.WriteField(box.AssignedLabel);
                        csv.NextRecord();
                    }
                }
            }

            Console.WriteLine($"Combined training/verification CSV exported with labeled boxes");
        }

        private void BtnTrainModel_Click(object sender, RoutedEventArgs e)
        {
            // First save training data
            string tempTrainingFile = System.IO.Path.Combine(System.IO.Path.GetTempPath(), "temp_training.csv");
            SaveTrainingDataToCSV(tempTrainingFile);

            // Check if we have enough data
            int labeledCount = _allLabeledBoxes.Count(b => !string.IsNullOrEmpty(b.AssignedLabel) &&
                                                           !b.IsHidden &&
                                                           b.AssignedLabel != "Ignore");
            if (labeledCount < 20)
            {
                MessageBox.Show($"Not enough training data. You have {labeledCount} labeled examples.\n" +
                    "Please label at least 20 text boxes before training.",
                    "Insufficient Data", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            var dialog = new SaveFileDialog
            {
                Filter = "Model Files (*.zip)|*.zip",
                FileName = "wi_extractor_model.zip"
            };

            if (dialog.ShowDialog() == true)
            {
                try
                {
                    var trainer = new ModelTrainer();
                    trainer.TrainModel(tempTrainingFile, dialog.FileName);

                    MessageBox.Show($"Model trained successfully!\n\nModel saved to:\n{dialog.FileName}\n\n" +
                        $"Training samples: {labeledCount}\n\n" +
                        "You can now use this model in your PowerPointExtractor.",
                        "Training Complete", MessageBoxButton.OK, MessageBoxImage.Information);
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Error training model:\n{ex.Message}",
                        "Training Error", MessageBoxButton.OK, MessageBoxImage.Error);
                }
                finally
                {
                    try { File.Delete(tempTrainingFile); } catch { }
                }
            }
        }

        private void UpdateProgress()
        {
            int completed = _powerPointFiles.Count(f => f.IsCompleted);
            int labeled = _powerPointFiles.Count(f => f.IsLabeled);
            int total = _powerPointFiles.Count;

            txtProgress.Text = $"{completed} completed, {labeled} labeled of {total} files";
            progressBar.Maximum = total;
            progressBar.Value = completed;
        }
    }

    // Helper classes
    public class PowerPointFileInfo
    {
        public string FilePath { get; set; }
        public string FileName { get; set; }
        public bool IsLabeled { get; set; }
        public bool IsCompleted { get; set; }

        // Extracted values
        public string ExtractedWINumber { get; set; }
        public string ExtractedTitle { get; set; }
        public string ExtractedRevision { get; set; }
        public string ExtractedBOM { get; set; }
        public string ExtractedOperationNo { get; set; }
        public string ExtractedProductLine { get; set; }
        public string ExtractedSubject { get; set; }
        public string ExtractedPageNo { get; set; }
        public string ExtractedTemplateRev { get; set; }
    }

    public class TextBoxInfo
    {
        public string Text { get; set; }
        public float Left { get; set; }
        public float Top { get; set; }
        public float Width { get; set; }
        public float Height { get; set; }
    }

    public class LabeledTextBox
    {
        public string Text { get; set; }
        public float Left { get; set; }
        public float Top { get; set; }
        public float Width { get; set; }
        public float Height { get; set; }
        public string AssignedLabel { get; set; }
        public string RevisionType { get; set; }
        public string SourceFile { get; set; }
        public int SlideNumber { get; set; }
        public bool IsHidden { get; set; }
    }
}
```

## **2. TrainingDataModels.cs** (Complete File)

```csharp
using Microsoft.ML.Data;

namespace WorkInstructionLabeler
{
    public class TextBoxFeatures
    {
        // Skip the first 10 columns (FileName through Template_Rev)
        [LoadColumn(10)]  // TextBoxText
        public string TextBoxText { get; set; }

        [LoadColumn(11)]
        public float Left { get; set; }

        [LoadColumn(12)]
        public float Top { get; set; }

        [LoadColumn(13)]
        public float Width { get; set; }

        [LoadColumn(14)]
        public float Height { get; set; }

        [LoadColumn(15)]
        public float TextLength { get; set; }

        [LoadColumn(16)]
        public bool ContainsNumbers { get; set; }

        [LoadColumn(17)]
        public bool ContainsHyphen { get; set; }

        [LoadColumn(18)]
        public bool StartsWithWI { get; set; }

        [LoadColumn(19)]
        public bool IsAllDigits { get; set; }

        [LoadColumn(20)]
        public string RevisionType { get; set; }

        [LoadColumn(21)]
        [ColumnName("Label")]
        public string FieldType { get; set; }
    }

    public class TextBoxPrediction
    {
        [ColumnName("PredictedLabel")]
        public string FieldType { get; set; }

        public float[] Score { get; set; }
    }
}
```

## **3. ModelTrainer.cs** (Complete File)

```csharp
using System;
using System.Linq;
using Microsoft.ML;
using Microsoft.ML.Data;

namespace WorkInstructionLabeler
{
    public class ModelTrainer
    {
        public void TrainModel(string trainingDataPath, string modelPath)
        {
            var mlContext = new MLContext(seed: 0);

            Console.WriteLine("Loading training data...");

            // Load training data with the new column structure
            IDataView dataView = mlContext.Data.LoadFromTextFile<TextBoxFeatures>(
                trainingDataPath,
                hasHeader: true,
                separatorChar: ',');

            // Check data distribution
            var preview = dataView.Preview(maxRows: 10);
            Console.WriteLine($"Loaded {preview.RowView.Count} sample rows");

            // Split for training and testing (80/20)
            var split = mlContext.Data.TrainTestSplit(dataView, testFraction: 0.2);

            Console.WriteLine("Building training pipeline...");

            // Define training pipeline
            var pipeline = mlContext.Transforms.Conversion.MapValueToKey("Label", "Label")
                .Append(mlContext.Transforms.Categorical.OneHotEncoding("RevisionTypeEncoded", "RevisionType"))
                .Append(mlContext.Transforms.Concatenate("Features",
                    "Left", "Top", "Width", "Height", "TextLength",
                    "ContainsNumbers", "ContainsHyphen", "StartsWithWI",
                    "IsAllDigits", "RevisionTypeEncoded"))
                .Append(mlContext.MulticlassClassification.Trainers.SdcaMaximumEntropy(
                    labelColumnName: "Label",
                    featureColumnName: "Features"))
                .Append(mlContext.Transforms.Conversion.MapKeyToValue("PredictedLabel"));

            Console.WriteLine("Training model...");
            var model = pipeline.Fit(split.TrainSet);

            Console.WriteLine("Evaluating model...");
            var predictions = model.Transform(split.TestSet);
            var metrics = mlContext.MulticlassClassification.Evaluate(predictions, labelColumnName: "Label");

            Console.WriteLine("\n=== Model Evaluation Metrics ===");
            Console.WriteLine($"Macro Accuracy: {metrics.MacroAccuracy:P2}");
            Console.WriteLine($"Micro Accuracy: {metrics.MicroAccuracy:P2}");
            Console.WriteLine($"Log Loss: {metrics.LogLoss:F4}");
            Console.WriteLine($"Log Loss Reduction: {metrics.LogLossReduction:F4}");

            // Per-class metrics
            Console.WriteLine("\n=== Per-Class Metrics ===");
            for (int i = 0; i < metrics.PerClassLogLoss.Count; i++)
            {
                Console.WriteLine($"Class {i}: Log Loss = {metrics.PerClassLogLoss[i]:F4}");
            }

            // Confusion matrix
            var confusionMatrix = metrics.ConfusionMatrix;
            Console.WriteLine("\n=== Confusion Matrix ===");
            Console.WriteLine(confusionMatrix.GetFormattedConfusionTable());

            // Save the model
            Console.WriteLine($"\nSaving model to {modelPath}...");
            mlContext.Model.Save(model, dataView.Schema, modelPath);

            Console.WriteLine("Model training complete!");
        }
    }
}
```

-----

That’s all the complete revised classes! The key changes are:

1. **PowerPointFileInfo** - Added 9 properties to store extracted values
1. **MainWindow.xaml.cs** - Added value capture, parsing, and combined CSV export
1. **SaveTrainingDataToCSV** - Now exports both human-readable values AND ML training features
1. **TextBoxFeatures** - Updated LoadColumn indices to skip first 10 CSV columns
1. **ParseTemplateRevision** - Extracts just the revision number from template text
1. **ParsePageNumber** - Extracts page number from various formats

The CSV will now have both verification columns (first 10) and ML training columns (remaining), all in one file!​​​​​​​​​​​​​​​​
