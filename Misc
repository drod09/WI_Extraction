Great question! Yes, we can use WPF with Blend-style visuals to create an interactive training data labeling tool. Let me create a complete [ML.NET](http://ML.NET) training pipeline with a visual labeling interface.

## **Complete ML.NET Training Pipeline with Visual Labeling Tool**

### **Step 1: Create the Training Data Labeler (WPF Application)**

First, let’s create a new WPF project called `WorkInstructionLabeler`:

**TrainingDataModels.cs**

```csharp
using System;
using Microsoft.ML.Data;

namespace WorkInstructionLabeler
{
    public class TextBoxFeatures
    {
        [LoadColumn(0)]
        public float Left { get; set; }
        
        [LoadColumn(1)]
        public float Top { get; set; }
        
        [LoadColumn(2)]
        public float Width { get; set; }
        
        [LoadColumn(3)]
        public float Height { get; set; }
        
        [LoadColumn(4)]
        public float TextLength { get; set; }
        
        [LoadColumn(5)]
        public bool ContainsNumbers { get; set; }
        
        [LoadColumn(6)]
        public bool ContainsHyphen { get; set; }
        
        [LoadColumn(7)]
        public bool StartsWithWI { get; set; }
        
        [LoadColumn(8)]
        public bool IsAllDigits { get; set; }
        
        [LoadColumn(9)]
        public string RevisionType { get; set; }
        
        [LoadColumn(10)]
        [ColumnName("Label")]
        public string FieldType { get; set; }
    }
    
    public class TextBoxPrediction
    {
        [ColumnName("PredictedLabel")]
        public string FieldType { get; set; }
        
        public float[] Score { get; set; }
    }
    
    // For the visual labeler
    public class LabeledTextBox
    {
        public string Text { get; set; }
        public float Left { get; set; }
        public float Top { get; set; }
        public float Width { get; set; }
        public float Height { get; set; }
        public string AssignedLabel { get; set; }
        public string RevisionType { get; set; }
        public string SourceFile { get; set; }
        public int SlideNumber { get; set; }
    }
}
```

**MainWindow.xaml** - Visual Labeling Interface

```xml
<Window x:Class="WorkInstructionLabeler.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Work Instruction Training Data Labeler" 
        Height="800" Width="1400"
        WindowState="Maximized">
    <Window.Resources>
        <!-- Text Box Styles for Different Labels -->
        <Style x:Key="WINumberBox" TargetType="Border">
            <Setter Property="BorderBrush" Value="#2196F3"/>
            <Setter Property="BorderThickness" Value="3"/>
            <Setter Property="Background" Value="#E3F2FD"/>
        </Style>
        <Style x:Key="TitleBox" TargetType="Border">
            <Setter Property="BorderBrush" Value="#4CAF50"/>
            <Setter Property="BorderThickness" Value="3"/>
            <Setter Property="Background" Value="#E8F5E9"/>
        </Style>
        <Style x:Key="RevisionBox" TargetType="Border">
            <Setter Property="BorderBrush" Value="#FF9800"/>
            <Setter Property="BorderThickness" Value="3"/>
            <Setter Property="Background" Value="#FFF3E0"/>
        </Style>
        <Style x:Key="BOMBox" TargetType="Border">
            <Setter Property="BorderBrush" Value="#9C27B0"/>
            <Setter Property="BorderThickness" Value="3"/>
            <Setter Property="Background" Value="#F3E5F5"/>
        </Style>
        <Style x:Key="OperationBox" TargetType="Border">
            <Setter Property="BorderBrush" Value="#00BCD4"/>
            <Setter Property="BorderThickness" Value="3"/>
            <Setter Property="Background" Value="#E0F7FA"/>
        </Style>
        <Style x:Key="ProductLineBox" TargetType="Border">
            <Setter Property="BorderBrush" Value="#FF5722"/>
            <Setter Property="BorderThickness" Value="3"/>
            <Setter Property="Background" Value="#FBE9E7"/>
        </Style>
        <Style x:Key="SubjectBox" TargetType="Border">
            <Setter Property="BorderBrush" Value="#795548"/>
            <Setter Property="BorderThickness" Value="3"/>
            <Setter Property="Background" Value="#EFEBE9"/>
        </Style>
        <Style x:Key="UnlabeledBox" TargetType="Border">
            <Setter Property="BorderBrush" Value="#CCCCCC"/>
            <Setter Property="BorderThickness" Value="2"/>
            <Setter Property="Background" Value="#F5F5F5"/>
        </Style>
    </Window.Resources>
    
    <Grid>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="300"/>
            <ColumnDefinition Width="*"/>
            <ColumnDefinition Width="250"/>
        </Grid.ColumnDefinitions>
        
        <!-- Left Panel - File List -->
        <Border Grid.Column="0" Background="#FAFAFA" BorderBrush="#E0E0E0" BorderThickness="0,0,1,0">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="*"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>
                
                <StackPanel Grid.Row="0" Margin="10">
                    <TextBlock Text="PowerPoint Files" FontSize="16" FontWeight="Bold" Margin="0,0,0,10"/>
                    <Button x:Name="btnLoadFolder" Content="Load Folder..." Click="BtnLoadFolder_Click" 
                            Height="35" Background="#2196F3" Foreground="White" FontWeight="Bold"/>
                </StackPanel>
                
                <ListBox Grid.Row="1" x:Name="lstFiles" Margin="10,0,10,10" 
                         SelectionChanged="LstFiles_SelectionChanged"
                         ScrollViewer.HorizontalScrollBarVisibility="Disabled">
                    <ListBox.ItemTemplate>
                        <DataTemplate>
                            <StackPanel Orientation="Horizontal" Margin="5">
                                <TextBlock Text="📄" FontSize="16" Margin="0,0,5,0"/>
                                <TextBlock Text="{Binding FileName}" TextWrapping="Wrap"/>
                            </StackPanel>
                        </DataTemplate>
                    </ListBox.ItemTemplate>
                </ListBox>
                
                <StackPanel Grid.Row="2" Margin="10">
                    <TextBlock x:Name="txtProgress" Text="0 of 0 files labeled" 
                               FontSize="12" Foreground="#666" HorizontalAlignment="Center"/>
                    <ProgressBar x:Name="progressBar" Height="8" Margin="0,5,0,0"/>
                </StackPanel>
            </Grid>
        </Border>
        
        <!-- Center Panel - Slide Visualization -->
        <Border Grid.Column="1" Background="White">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="*"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>
                
                <!-- Toolbar -->
                <Border Grid.Row="0" Background="#263238" Padding="10">
                    <StackPanel Orientation="Horizontal">
                        <TextBlock x:Name="txtFileName" Text="No file loaded" 
                                   Foreground="White" FontSize="14" FontWeight="Bold" 
                                   VerticalAlignment="Center" Margin="0,0,20,0"/>
                        <TextBlock x:Name="txtRevType" Text="Rev: Unknown" 
                                   Foreground="#4CAF50" FontSize="12" 
                                   VerticalAlignment="Center" Margin="0,0,20,0"/>
                        <Button x:Name="btnPrevSlide" Content="◀ Previous" Click="BtnPrevSlide_Click" 
                                Margin="5" Padding="10,5"/>
                        <TextBlock x:Name="txtSlideInfo" Text="Slide 1 of 1" 
                                   Foreground="White" FontSize="12" 
                                   VerticalAlignment="Center" Margin="10,0"/>
                        <Button x:Name="btnNextSlide" Content="Next ▶" Click="BtnNextSlide_Click" 
                                Margin="5" Padding="10,5"/>
                    </StackPanel>
                </Border>
                
                <!-- Canvas for visualization -->
                <ScrollViewer Grid.Row="1" HorizontalScrollBarVisibility="Auto" 
                              VerticalScrollBarVisibility="Auto" Background="#E0E0E0">
                    <Canvas x:Name="slideCanvas" Width="800" Height="600" Background="White">
                        <!-- Text boxes will be drawn here dynamically -->
                    </Canvas>
                </ScrollViewer>
                
                <!-- Bottom Navigation -->
                <Border Grid.Row="2" Background="#FAFAFA" BorderBrush="#E0E0E0" BorderThickness="0,1,0,0" Padding="10">
                    <StackPanel Orientation="Horizontal" HorizontalAlignment="Center">
                        <Button x:Name="btnSaveTrainingData" Content="💾 Save Training Data" 
                                Click="BtnSaveTrainingData_Click" 
                                Height="40" Width="200" Margin="5"
                                Background="#4CAF50" Foreground="White" FontWeight="Bold" FontSize="14"/>
                        <Button x:Name="btnExportModel" Content="🎓 Train Model" 
                                Click="BtnTrainModel_Click" 
                                Height="40" Width="200" Margin="5"
                                Background="#FF9800" Foreground="White" FontWeight="Bold" FontSize="14"/>
                    </StackPanel>
                </Border>
            </Grid>
        </Border>
        
        <!-- Right Panel - Labeling Controls -->
        <Border Grid.Column="2" Background="#FAFAFA" BorderBrush="#E0E0E0" BorderThickness="1,0,0,0">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="*"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>
                
                <StackPanel Grid.Row="0" Margin="10">
                    <TextBlock Text="Selected Text Box" FontSize="16" FontWeight="Bold" Margin="0,0,0,10"/>
                    <Border Background="White" BorderBrush="#E0E0E0" BorderThickness="1" 
                            Padding="10" Margin="0,0,0,10">
                        <TextBlock x:Name="txtSelectedText" Text="Click a text box to select" 
                                   TextWrapping="Wrap" FontSize="12"/>
                    </Border>
                    
                    <TextBlock Text="Position Info" FontSize="12" Foreground="#666" Margin="0,0,0,5"/>
                    <TextBlock x:Name="txtPosition" Text="Left: -, Top: -" 
                               FontSize="11" Foreground="#999" Margin="0,0,0,15"/>
                    
                    <TextBlock Text="Assign Label:" FontSize="14" FontWeight="Bold" Margin="0,0,0,10"/>
                </StackPanel>
                
                <!-- Label Buttons -->
                <ScrollViewer Grid.Row="1" VerticalScrollBarVisibility="Auto">
                    <StackPanel Margin="10,0,10,10">
                        <Button x:Name="btnLabelWI" Content="WI Number" Click="BtnLabel_Click" Tag="WI_Number"
                                Height="50" Margin="0,0,0,10" Background="#2196F3" Foreground="White" 
                                FontSize="14" FontWeight="Bold"/>
                        
                        <Button x:Name="btnLabelTitle" Content="WI Title" Click="BtnLabel_Click" Tag="WI_Title"
                                Height="50" Margin="0,0,0,10" Background="#4CAF50" Foreground="White" 
                                FontSize="14" FontWeight="Bold"/>
                        
                        <Button x:Name="btnLabelRevision" Content="Revision" Click="BtnLabel_Click" Tag="Revision"
                                Height="50" Margin="0,0,0,10" Background="#FF9800" Foreground="White" 
                                FontSize="14" FontWeight="Bold"/>
                        
                        <Button x:Name="btnLabelBOM" Content="BOM/ASSY DWG NO" Click="BtnLabel_Click" Tag="BOM_ASSY_DWG_NO"
                                Height="50" Margin="0,0,0,10" Background="#9C27B0" Foreground="White" 
                                FontSize="14" FontWeight="Bold"/>
                        
                        <Button x:Name="btnLabelOperation" Content="Operation No" Click="BtnLabel_Click" Tag="Operation_No"
                                Height="50" Margin="0,0,0,10" Background="#00BCD4" Foreground="White" 
                                FontSize="14" FontWeight="Bold"/>
                        
                        <Button x:Name="btnLabelProductLine" Content="Product Line" Click="BtnLabel_Click" Tag="Product_Line"
                                Height="50" Margin="0,0,0,10" Background="#FF5722" Foreground="White" 
                                FontSize="14" FontWeight="Bold"/>
                        
                        <Button x:Name="btnLabelSubject" Content="Subject" Click="BtnLabel_Click" Tag="Subject"
                                Height="50" Margin="0,0,0,10" Background="#795548" Foreground="White" 
                                FontSize="14" FontWeight="Bold"/>
                        
                        <Separator Margin="0,10"/>
                        
                        <Button x:Name="btnLabelIgnore" Content="❌ Ignore (Label)" Click="BtnLabel_Click" Tag="Ignore"
                                Height="40" Margin="0,0,0,10" Background="#757575" Foreground="White" 
                                FontSize="12"/>
                        
                        <Button x:Name="btnClearLabel" Content="Clear Label" Click="BtnClearLabel_Click"
                                Height="40" Margin="0,0,0,10" Background="#F44336" Foreground="White" 
                                FontSize="12"/>
                    </StackPanel>
                </ScrollViewer>
                
                <!-- Legend -->
                <Border Grid.Row="2" Background="White" BorderBrush="#E0E0E0" 
                        BorderThickness="0,1,0,0" Padding="10">
                    <StackPanel>
                        <TextBlock Text="Color Legend:" FontSize="12" FontWeight="Bold" Margin="0,0,0,5"/>
                        <StackPanel Orientation="Horizontal" Margin="0,2">
                            <Border Width="20" Height="15" Background="#E3F2FD" BorderBrush="#2196F3" BorderThickness="2"/>
                            <TextBlock Text="WI Number" FontSize="10" Margin="5,0"/>
                        </StackPanel>
                        <StackPanel Orientation="Horizontal" Margin="0,2">
                            <Border Width="20" Height="15" Background="#E8F5E9" BorderBrush="#4CAF50" BorderThickness="2"/>
                            <TextBlock Text="Title" FontSize="10" Margin="5,0"/>
                        </StackPanel>
                        <StackPanel Orientation="Horizontal" Margin="0,2">
                            <Border Width="20" Height="15" Background="#FFF3E0" BorderBrush="#FF9800" BorderThickness="2"/>
                            <TextBlock Text="Revision" FontSize="10" Margin="5,0"/>
                        </StackPanel>
                        <StackPanel Orientation="Horizontal" Margin="0,2">
                            <Border Width="20" Height="15" Background="#F5F5F5" BorderBrush="#CCCCCC" BorderThickness="2"/>
                            <TextBlock Text="Unlabeled" FontSize="10" Margin="5,0"/>
                        </StackPanel>
                    </StackPanel>
                </Border>
            </Grid>
        </Border>
    </Grid>
</Window>
```

**MainWindow.xaml.cs** - Code Behind

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Shapes;
using Microsoft.Office.Interop.PowerPoint;
using Microsoft.Office.Core;
using Microsoft.Win32;
using System.Collections.ObjectModel;
using CsvHelper;
using System.Globalization;

namespace WorkInstructionLabeler
{
    public partial class MainWindow : Window
    {
        private List<PowerPointFileInfo> _powerPointFiles = new List<PowerPointFileInfo>();
        private PowerPointFileInfo _currentFile;
        private int _currentSlideIndex = 0;
        private List<LabeledTextBox> _allLabeledBoxes = new List<LabeledTextBox>();
        private LabeledTextBox _selectedTextBox;
        private Dictionary<Border, LabeledTextBox> _borderToTextBoxMap = new Dictionary<Border, LabeledTextBox>();
        
        public MainWindow()
        {
            InitializeComponent();
        }
        
        private void BtnLoadFolder_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new System.Windows.Forms.FolderBrowserDialog();
            dialog.Description = "Select folder containing PowerPoint work instructions";
            
            if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)
            {
                LoadPowerPointFiles(dialog.SelectedPath);
            }
        }
        
        private void LoadPowerPointFiles(string folderPath)
        {
            _powerPointFiles.Clear();
            lstFiles.Items.Clear();
            
            var files = Directory.GetFiles(folderPath, "*.pptx")
                .Where(f => !System.IO.Path.GetFileName(f).StartsWith("~$"))
                .ToList();
            
            foreach (var file in files)
            {
                var fileInfo = new PowerPointFileInfo
                {
                    FilePath = file,
                    FileName = System.IO.Path.GetFileName(file),
                    IsLabeled = false
                };
                
                _powerPointFiles.Add(fileInfo);
                lstFiles.Items.Add(fileInfo);
            }
            
            UpdateProgress();
            
            if (_powerPointFiles.Count > 0)
            {
                lstFiles.SelectedIndex = 0;
            }
        }
        
        private void LstFiles_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (lstFiles.SelectedItem is PowerPointFileInfo fileInfo)
            {
                LoadPowerPointFile(fileInfo);
            }
        }
        
        private void LoadPowerPointFile(PowerPointFileInfo fileInfo)
        {
            _currentFile = fileInfo;
            _currentSlideIndex = 0;
            
            txtFileName.Text = fileInfo.FileName;
            
            // Extract text boxes from PowerPoint
            ExtractTextBoxesFromPowerPoint(fileInfo.FilePath);
            
            // Display first slide
            DisplaySlide(_currentSlideIndex);
        }
        
        private void ExtractTextBoxesFromPowerPoint(string filePath)
        {
            var pptApp = new Microsoft.Office.Interop.PowerPoint.Application();
            
            try
            {
                Presentation ppt = pptApp.Presentations.Open(filePath,
                    MsoTriState.msoFalse, MsoTriState.msoFalse, MsoTriState.msoFalse);
                
                // Detect revision type
                string revType = DetectRevisionType(ppt);
                txtRevType.Text = $"Rev: {revType}";
                
                // Clear previous data for this file
                _allLabeledBoxes.RemoveAll(b => b.SourceFile == filePath);
                
                // Extract from first slide only (for header data)
                if (ppt.Slides.Count > 0)
                {
                    Slide slide = ppt.Slides[1];
                    var textBoxes = new List<TextBoxInfo>();
                    
                    CollectTextBoxes(slide.Shapes, textBoxes);
                    try { CollectTextBoxes(slide.Master.Shapes, textBoxes); } catch { }
                    try { CollectTextBoxes(slide.Design.SlideMaster.Shapes, textBoxes); } catch { }
                    try { CollectTextBoxes(slide.CustomLayout.Shapes, textBoxes); } catch { }
                    
                    // Convert to LabeledTextBox
                    foreach (var box in textBoxes)
                    {
                        if (string.IsNullOrWhiteSpace(box.Text) || IsLabel(box.Text.ToUpper()))
                            continue;
                        
                        _allLabeledBoxes.Add(new LabeledTextBox
                        {
                            Text = box.Text,
                            Left = box.Left,
                            Top = box.Top,
                            Width = box.Width,
                            Height = box.Height,
                            RevisionType = revType,
                            SourceFile = filePath,
                            SlideNumber = 1,
                            AssignedLabel = null // Not yet labeled
                        });
                    }
                }
                
                txtSlideInfo.Text = $"Slide 1 of {ppt.Slides.Count}";
                
                ppt.Close();
            }
            finally
            {
                pptApp.Quit();
            }
        }
        
        private string DetectRevisionType(Presentation ppt)
        {
            if (ppt.Slides.Count > 0)
            {
                Slide slide = ppt.Slides[1];
                
                foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Shapes)
                {
                    if (shape.HasTextFrame == MsoTriState.msoTrue)
                    {
                        string text = shape.TextFrame.TextRange.Text.ToLower();
                        if (text.Contains("fm-me-") || text.Contains("fm me") || text.Contains("fmme"))
                        {
                            var match = Regex.Match(text, @"rev\.?\s*(\d+)", RegexOptions.IgnoreCase);
                            if (match.Success)
                                return match.Groups[1].Value;
                        }
                    }
                }
            }
            return "Unknown";
        }
        
        private void CollectTextBoxes(Microsoft.Office.Interop.PowerPoint.Shapes shapes, List<TextBoxInfo> textBoxes)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in shapes)
            {
                try
                {
                    if (shape.Type == MsoShapeType.msoGroup)
                        CollectTextBoxesFromGroup(shape.GroupItems, textBoxes);
                    else if (shape.HasTextFrame == MsoTriState.msoTrue)
                    {
                        string text = shape.TextFrame.TextRange.Text.Trim();
                        if (!string.IsNullOrEmpty(text))
                        {
                            textBoxes.Add(new TextBoxInfo
                            {
                                Text = text,
                                Left = shape.Left,
                                Top = shape.Top,
                                Width = shape.Width,
                                Height = shape.Height
                            });
                        }
                    }
                }
                catch { }
            }
        }
        
        private void CollectTextBoxesFromGroup(Microsoft.Office.Interop.PowerPoint.GroupShapes groupShapes,
            List<TextBoxInfo> textBoxes)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in groupShapes)
            {
                try
                {
                    if (shape.Type == MsoShapeType.msoGroup)
                        CollectTextBoxesFromGroup(shape.GroupItems, textBoxes);
                    else if (shape.HasTextFrame == MsoTriState.msoTrue)
                    {
                        string text = shape.TextFrame.TextRange.Text.Trim();
                        if (!string.IsNullOrEmpty(text))
                        {
                            textBoxes.Add(new TextBoxInfo
                            {
                                Text = text,
                                Left = shape.Left,
                                Top = shape.Top,
                                Width = shape.Width,
                                Height = shape.Height
                            });
                        }
                    }
                }
                catch { }
            }
        }
        
        private bool IsLabel(string upperText)
        {
            var labels = new[] {
                "WORK INSTRUCTION TITLE", "WORK INSTRUCTION", "DESCRIPTION", "DESCRIPTION:",
                "W.I. NUMBER", "WI NUMBER", "BOM/ASSY DWG NO", "BOM DWG NO", "ASSY DWG NO",
                "OPS (OPTIONAL)", "OPERATION NO", "OPERATION NO.", "PRODUCT LINE",
                "SUBJECT", "SUBJECT:", "PAGE", "REV", "REV:", "REVISION", "REVISION:"
            };
            
            return labels.Any(label => upperText == label || (upperText.Contains(label) && upperText.Length < 40)) ||
                   (upperText.EndsWith(":") && upperText.Length < 25);
        }
        
        private void DisplaySlide(int slideIndex)
        {
            slideCanvas.Children.Clear();
            _borderToTextBoxMap.Clear();
            
            var slideBoxes = _allLabeledBoxes
                .Where(b => b.SourceFile == _currentFile.FilePath && b.SlideNumber == slideIndex + 1)
                .ToList();
            
            // Scale factor to fit canvas
            float scaleFactor = 1.0f;
            
            foreach (var box in slideBoxes)
            {
                // Create border for text box
                var border = new Border
                {
                    Width = box.Width * scaleFactor,
                    Height = box.Height * scaleFactor,
                    Cursor = System.Windows.Input.Cursors.Hand
                };
                
                // Apply style based on label
                border.Style = GetStyleForLabel(box.AssignedLabel);
                
                // Create text block
                var textBlock = new TextBlock
                {
                    Text = box.Text.Length > 50 ? box.Text.Substring(0, 50) + "..." : box.Text,
                    TextWrapping = TextWrapping.Wrap,
                    Padding = new Thickness(5),
                    FontSize = 10
                };
                
                border.Child = textBlock;
                
                // Position on canvas
                Canvas.SetLeft(border, box.Left * scaleFactor);
                Canvas.SetTop(border, box.Top * scaleFactor);
                
                // Add click handler
                border.MouseDown += (s, e) =>
                {
                    SelectTextBox(box, border);
                };
                
                slideCanvas.Children.Add(border);
                _borderToTextBoxMap[border] = box;
            }
        }
        
        private Style GetStyleForLabel(string label)
        {
            if (string.IsNullOrEmpty(label))
                return (Style)FindResource("UnlabeledBox");
            
            return label switch
            {
                "WI_Number" => (Style)FindResource("WINumberBox"),
                "WI_Title" => (Style)FindResource("TitleBox"),
                "Revision" => (Style)FindResource("RevisionBox"),
                "BOM_ASSY_DWG_NO" => (Style)FindResource("BOMBox"),
                "Operation_No" => (Style)FindResource("OperationBox"),
                "Product_Line" => (Style)FindResource("ProductLineBox"),
                "Subject" => (Style)FindResource("SubjectBox"),
                _ => (Style)FindResource("UnlabeledBox")
            };
        }
        
        private void SelectTextBox(LabeledTextBox box, Border border)
        {
            _selectedTextBox = box;
            
            // Highlight selected
            foreach (var kvp in _borderToTextBoxMap)
            {
                if (kvp.Value == box)
                    kvp.Key.BorderThickness = new Thickness(4);
                else
                    kvp.Key.BorderThickness = new Thickness(2);
            }
            
            txtSelectedText.Text = box.Text;
            txtPosition.Text = $"Left: {box.Left:F1}, Top: {box.Top:F1}, W: {box.Width:F1}, H: {box.Height:F1}";
        }
        
        private void BtnLabel_Click(object sender, RoutedEventArgs e)
        {
            if (_selectedTextBox == null)
            {
                MessageBox.Show("Please select a text box first", "No Selection", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            
            var button = sender as Button;
            string label = button.Tag.ToString();
            
            _selectedTextBox.AssignedLabel = label;
            
            // Refresh display
            DisplaySlide(_currentSlideIndex);
            
            // Mark file as having changes
            _currentFile.IsLabeled = true;
            UpdateProgress();
        }
        
        private void BtnClearLabel_Click(object sender, RoutedEventArgs e)
        {
            if (_selectedTextBox == null) return;
            
            _selectedTextBox.AssignedLabel = null;
            DisplaySlide(_currentSlideIndex);
        }
        
        private void BtnPrevSlide_Click(object sender, RoutedEventArgs e)
        {
            if (_currentSlideIndex > 0)
            {
                _currentSlideIndex--;
                DisplaySlide(_currentSlideIndex);
                txtSlideInfo.Text = $"Slide {_currentSlideIndex + 1}";
            }
        }
        
        private void BtnNextSlide_Click(object sender, RoutedEventArgs e)
        {
            // For now, only working with slide 1
            MessageBox.Show("Currently only labeling slide 1 (header data)", "Info");
        }
        
        private void BtnSaveTrainingData_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new SaveFileDialog
            {
                Filter = "CSV Files (*.csv)|*.csv",
                FileName = "training_data.csv"
            };
            
            if (dialog.ShowDialog() == true)
            {
                SaveTrainingDataToCSV(dialog.FileName);
                MessageBox.Show($"Training data saved to:\n{dialog.FileName}", 
                    "Success", MessageBoxButton.OK, MessageBoxImage.Information);
            }
        }
        
        private void SaveTrainingDataToCSV(string filePath)
        {
            using (var writer = new StreamWriter(filePath))
            using (var csv = new CsvWriter(writer, CultureInfo​​​​​​​​​​​​​​​​
```

```csharp
            using (var writer = new StreamWriter(filePath))
            using (var csv = new CsvWriter(writer, CultureInfo.InvariantCulture))
            {
                // Write header
                csv.WriteField("Left");
                csv.WriteField("Top");
                csv.WriteField("Width");
                csv.WriteField("Height");
                csv.WriteField("TextLength");
                csv.WriteField("ContainsNumbers");
                csv.WriteField("ContainsHyphen");
                csv.WriteField("StartsWithWI");
                csv.WriteField("IsAllDigits");
                csv.WriteField("RevisionType");
                csv.WriteField("Label");
                csv.NextRecord();
                
                // Write data
                foreach (var box in _allLabeledBoxes.Where(b => !string.IsNullOrEmpty(b.AssignedLabel)))
                {
                    csv.WriteField(box.Left);
                    csv.WriteField(box.Top);
                    csv.WriteField(box.Width);
                    csv.WriteField(box.Height);
                    csv.WriteField(box.Text.Length);
                    csv.WriteField(Regex.IsMatch(box.Text, @"\d"));
                    csv.WriteField(box.Text.Contains("-"));
                    csv.WriteField(box.Text.StartsWith("WI", StringComparison.OrdinalIgnoreCase));
                    csv.WriteField(Regex.IsMatch(box.Text, @"^\d+$"));
                    csv.WriteField(box.RevisionType);
                    csv.WriteField(box.AssignedLabel);
                    csv.NextRecord();
                }
            }
        }
        
        private void BtnTrainModel_Click(object sender, RoutedEventArgs e)
        {
            // First save training data
            string tempTrainingFile = System.IO.Path.Combine(System.IO.Path.GetTempPath(), "temp_training.csv");
            SaveTrainingDataToCSV(tempTrainingFile);
            
            // Check if we have enough data
            int labeledCount = _allLabeledBoxes.Count(b => !string.IsNullOrEmpty(b.AssignedLabel));
            if (labeledCount < 20)
            {
                MessageBox.Show($"Not enough training data. You have {labeledCount} labeled examples.\n" +
                    "Please label at least 20 text boxes before training.", 
                    "Insufficient Data", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            
            var dialog = new SaveFileDialog
            {
                Filter = "Model Files (*.zip)|*.zip",
                FileName = "wi_extractor_model.zip"
            };
            
            if (dialog.ShowDialog() == true)
            {
                try
                {
                    var trainer = new ModelTrainer();
                    trainer.TrainModel(tempTrainingFile, dialog.FileName);
                    
                    MessageBox.Show($"Model trained successfully!\n\nModel saved to:\n{dialog.FileName}\n\n" +
                        $"Training samples: {labeledCount}\n\n" +
                        "You can now use this model in your PowerPointExtractor.",
                        "Training Complete", MessageBoxButton.OK, MessageBoxImage.Information);
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Error training model:\n{ex.Message}", 
                        "Training Error", MessageBoxButton.OK, MessageBoxImage.Error);
                }
                finally
                {
                    try { File.Delete(tempTrainingFile); } catch { }
                }
            }
        }
        
        private void UpdateProgress()
        {
            int labeled = _powerPointFiles.Count(f => f.IsLabeled);
            int total = _powerPointFiles.Count;
            
            txtProgress.Text = $"{labeled} of {total} files labeled";
            progressBar.Maximum = total;
            progressBar.Value = labeled;
        }
    }
    
    // Helper classes
    public class PowerPointFileInfo
    {
        public string FilePath { get; set; }
        public string FileName { get; set; }
        public bool IsLabeled { get; set; }
    }
    
    public class TextBoxInfo
    {
        public string Text { get; set; }
        public float Left { get; set; }
        public float Top { get; set; }
        public float Width { get; set; }
        public float Height { get; set; }
    }
}
```

### **Step 2: ML.NET Model Trainer**

**ModelTrainer.cs**

```csharp
using System;
using System.IO;
using System.Linq;
using Microsoft.ML;
using Microsoft.ML.Data;

namespace WorkInstructionLabeler
{
    public class ModelTrainer
    {
        public void TrainModel(string trainingDataPath, string modelPath)
        {
            var mlContext = new MLContext(seed: 0);
            
            Console.WriteLine("Loading training data...");
            
            // Load training data
            IDataView dataView = mlContext.Data.LoadFromTextFile<TextBoxFeatures>(
                trainingDataPath,
                hasHeader: true,
                separatorChar: ',');
            
            // Check data distribution
            var preview = dataView.Preview(maxRows: 10);
            Console.WriteLine($"Loaded {preview.RowView.Length} sample rows");
            
            // Split for training and testing (80/20)
            var split = mlContext.Data.TrainTestSplit(dataView, testFraction: 0.2);
            
            Console.WriteLine("Building training pipeline...");
            
            // Define training pipeline
            var pipeline = mlContext.Transforms.Conversion.MapValueToKey("Label", "Label")
                .Append(mlContext.Transforms.Categorical.OneHotEncoding("RevisionTypeEncoded", "RevisionType"))
                .Append(mlContext.Transforms.Concatenate("Features",
                    "Left", "Top", "Width", "Height", "TextLength",
                    "ContainsNumbers", "ContainsHyphen", "StartsWithWI",
                    "IsAllDigits", "RevisionTypeEncoded"))
                .Append(mlContext.MulticlassClassification.Trainers.SdcaMaximumEntropy(
                    labelColumnName: "Label",
                    featureColumnName: "Features"))
                .Append(mlContext.Transforms.Conversion.MapKeyToValue("PredictedLabel"));
            
            Console.WriteLine("Training model...");
            var model = pipeline.Fit(split.TrainSet);
            
            Console.WriteLine("Evaluating model...");
            var predictions = model.Transform(split.TestSet);
            var metrics = mlContext.MulticlassClassification.Evaluate(predictions, labelColumnName: "Label");
            
            Console.WriteLine("\n=== Model Evaluation Metrics ===");
            Console.WriteLine($"Macro Accuracy: {metrics.MacroAccuracy:P2}");
            Console.WriteLine($"Micro Accuracy: {metrics.MicroAccuracy:P2}");
            Console.WriteLine($"Log Loss: {metrics.LogLoss:F4}");
            Console.WriteLine($"Log Loss Reduction: {metrics.LogLossReduction:F4}");
            
            // Per-class metrics
            Console.WriteLine("\n=== Per-Class Metrics ===");
            for (int i = 0; i < metrics.PerClassLogLoss.Length; i++)
            {
                Console.WriteLine($"Class {i}: Log Loss = {metrics.PerClassLogLoss[i]:F4}");
            }
            
            // Confusion matrix
            var confusionMatrix = metrics.ConfusionMatrix;
            Console.WriteLine("\n=== Confusion Matrix ===");
            Console.WriteLine(confusionMatrix.GetFormattedConfusionTable());
            
            // Save the model
            Console.WriteLine($"\nSaving model to {modelPath}...");
            mlContext.Model.Save(model, dataView.Schema, modelPath);
            
            Console.WriteLine("Model training complete!");
        }
    }
}
```

### **Step 3: Integrate into Your PowerPointExtractor**

Add this to your existing `PowerPointExtractor.cs`:

```csharp
using Microsoft.ML;
using Microsoft.ML.Data;

namespace WorkInstructionExtractor
{
    public class PowerPointExtractor
    {
        private MLContext _mlContext;
        private ITransformer _model;
        private PredictionEngine<MLTextBoxFeatures, MLTextBoxPrediction> _predictionEngine;
        
        static PowerPointExtractor()
        {
            ExcelPackage.LicenseContext = LicenseContext.NonCommercial;
        }
        
        // Constructor with optional model path
        public PowerPointExtractor(string modelPath = null)
        {
            // Try to load ML model if path provided or if default exists
            if (string.IsNullOrEmpty(modelPath))
            {
                modelPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "wi_extractor_model.zip");
            }
            
            if (File.Exists(modelPath))
            {
                try
                {
                    _mlContext = new MLContext();
                    _model = _mlContext.Model.Load(modelPath, out var modelSchema);
                    _predictionEngine = _mlContext.Model.CreatePredictionEngine<MLTextBoxFeatures, MLTextBoxPrediction>(_model);
                    Console.WriteLine($"✓ ML Model loaded from: {modelPath}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"⚠ Could not load ML model: {ex.Message}");
                    Console.WriteLine("  Using position-based extraction as fallback");
                }
            }
            else
            {
                Console.WriteLine("ℹ No ML model found, using position-based extraction");
            }
        }
        
        // ML.NET compatible classes
        public class MLTextBoxFeatures
        {
            public float Left { get; set; }
            public float Top { get; set; }
            public float Width { get; set; }
            public float Height { get; set; }
            public float TextLength { get; set; }
            public bool ContainsNumbers { get; set; }
            public bool ContainsHyphen { get; set; }
            public bool StartsWithWI { get; set; }
            public bool IsAllDigits { get; set; }
            public string RevisionType { get; set; }
        }
        
        public class MLTextBoxPrediction
        {
            [ColumnName("PredictedLabel")]
            public string FieldType { get; set; }
            
            public float[] Score { get; set; }
        }
        
        // Modified ExtractData to use ML when available
        private void ExtractData(List<TextBoxInfo> textBoxes, Dictionary<string, string> data)
        {
            // Initialize all fields
            data["WI_Number"] = "";
            data["WI_Title"] = "";
            data["Revision"] = "";
            data["BOM_ASSY_DWG_NO"] = "";
            data["Operation_No"] = "";
            data["Product_Line"] = "";
            data["Subject"] = "";
            data["RevisionType"] = "";
            
            // Detect revision type
            string revisionType = DetectRevisionType(textBoxes);
            data["RevisionType"] = revisionType;
            
            Console.WriteLine($"Detected Revision Type: {revisionType}");
            
            // Use ML model if available, otherwise fallback to position-based
            if (_predictionEngine != null)
            {
                Console.WriteLine("Using ML model for extraction");
                ExtractWithML(textBoxes, data, revisionType);
            }
            else
            {
                Console.WriteLine("Using position-based extraction");
                if (revisionType == "15" || revisionType == "16")
                    ExtractRev15_16(textBoxes, data);
                else if (revisionType == "17" || revisionType == "18" || revisionType == "19")
                    ExtractRev17_19(textBoxes, data);
                else
                    ExtractWithPatterns(textBoxes, data);
            }
        }
        
        private void ExtractWithML(List<TextBoxInfo> textBoxes, 
            Dictionary<string, string> data, string revisionType)
        {
            var predictions = new Dictionary<string, (string text, float confidence)>();
            
            Console.WriteLine("\n=== ML Predictions ===");
            
            foreach (var box in textBoxes)
            {
                string text = box.Text.Trim();
                
                // Skip labels and empty text
                if (IsLabel(text.ToUpper()) || string.IsNullOrWhiteSpace(text))
                    continue;
                
                // Create features
                var features = new MLTextBoxFeatures
                {
                    Left = box.Left,
                    Top = box.Top,
                    Width = box.Width,
                    Height = box.Height,
                    TextLength = text.Length,
                    ContainsNumbers = Regex.IsMatch(text, @"\d"),
                    ContainsHyphen = text.Contains("-"),
                    StartsWithWI = text.StartsWith("WI", StringComparison.OrdinalIgnoreCase),
                    IsAllDigits = Regex.IsMatch(text, @"^\d+$"),
                    RevisionType = revisionType
                };
                
                // Get prediction
                var prediction = _predictionEngine.Predict(features);
                
                if (prediction.Score != null && prediction.Score.Length > 0)
                {
                    float confidence = prediction.Score.Max();
                    string fieldType = prediction.FieldType;
                    
                    // Only use predictions with confidence > 60%
                    if (confidence > 0.60f && fieldType != "Ignore")
                    {
                        Console.WriteLine($"  {fieldType}: '{text}' (confidence: {confidence:P1})");
                        
                        // Keep the highest confidence prediction for each field
                        if (!predictions.ContainsKey(fieldType) || 
                            predictions[fieldType].confidence < confidence)
                        {
                            predictions[fieldType] = (text, confidence);
                        }
                    }
                }
            }
            
            Console.WriteLine("\n=== Final Predictions ===");
            
            // Apply predictions to data
            foreach (var kvp in predictions)
            {
                if (data.ContainsKey(kvp.Key))
                {
                    data[kvp.Key] = kvp.Value.text;
                    Console.WriteLine($"  {kvp.Key} = '{kvp.Value.text}' (confidence: {kvp.Value.confidence:P1})");
                }
            }
            
            // Fallback: Use pattern matching for critical fields if ML didn't find them
            if (string.IsNullOrEmpty(data["WI_Number"]))
            {
                Console.WriteLine("\n⚠ WI_Number not found by ML, using pattern fallback");
                ExtractWINumberPattern(textBoxes, data);
            }
            
            Console.WriteLine("===================\n");
        }
        
        private void ExtractWINumberPattern(List<TextBoxInfo> textBoxes, Dictionary<string, string> data)
        {
            foreach (var box in textBoxes)
            {
                var wiMatch = Regex.Match(box.Text,
                    @"W\.?\s*I\.?\s*-?\s*\d{2,}",
                    RegexOptions.IgnoreCase);
                    
                if (wiMatch.Success)
                {
                    string wiNum = wiMatch.Value.Replace(" ", "").Replace(".", "").ToUpper();
                    if (!wiNum.Contains("-"))
                        wiNum = wiNum.Replace("WI", "WI-");
                    data["WI_Number"] = wiNum;
                    Console.WriteLine($"  Pattern match: WI_Number = '{wiNum}'");
                    break;
                }
            }
        }
        
        // Rest of your existing methods remain the same...
    }
}
```

### **Step 4: Update Your Form to Support Model Path**

Modify `Form1.cs`:

```csharp
private void BackgroundWorker_DoWork(object sender, DoWorkEventArgs e)
{
    var worker = sender as BackgroundWorker;
    var data = e.Argument as ExtractionWorkData;

    try
    {
        worker.ReportProgress(10, "Extracting data from PowerPoint...");

        // Look for ML model
        string modelPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "wi_extractor_model.zip");
        
        var extractor = new PowerPointExtractor(modelPath);
        var extractResult = extractor.ExtractWorkInstruction(
            data.PowerPointPath,
            data.OutputFolder,
            (progress, message) => worker.ReportProgress(progress, message)
        );

        worker.ReportProgress(100, $"Complete! Data extracted to: {extractResult.ExcelPath}");
        e.Result = new ExtractionResultWrapper
        {
            Success = true,
            ExcelPath = extractResult.ExcelPath
        };
    }
    catch (Exception ex)
    {
        e.Result = new ExtractionResultWrapper
        {
            Success = false,
            ErrorMessage = ex.Message
        };
    }
}
```

### **Step 5: NuGet Packages Required**

Add these to your projects:

**WorkInstructionLabeler project:**

```xml
<PackageReference Include="Microsoft.ML" Version="3.0.1" />
<PackageReference Include="CsvHelper" Version="30.0.1" />
```

**WorkInstructionExtractor project:**

```xml
<PackageReference Include="Microsoft.ML" Version="3.0.1" />
```

### **Usage Workflow**

1. **Label Training Data:**

- Run `WorkInstructionLabeler.exe`
- Load a folder with 50-100 PowerPoint files
- Click through each file and label the text boxes using the color-coded buttons
- The visual interface shows exactly where each text box is positioned
- Click “Save Training Data” to export CSV
- Click “Train Model” to generate `wi_extractor_model.zip`

1. **Use the Model:**

- Copy `wi_extractor_model.zip` to your `WorkInstructionExtractor` application folder
- Run your extraction - it will automatically use ML when available
- Fall back to position-based extraction if model missing or low confidence

1. **Iterate:**

- Review extraction results
- Add problem files back to the labeler
- Correct labels and retrain
- Model improves over time

### **Advantages of This Approach:**

✅ **Visual feedback** - See exactly what you’re labeling in a Blend-style interface  
✅ **Color-coded** - Each field type has distinct colors  
✅ **Position-aware** - Shows actual text box positions from PowerPoint  
✅ **Hybrid approach** - ML + position rules for best accuracy  
✅ **Confidence scoring** - Know when predictions are uncertain  
✅ **Iterative improvement** - Easy to add more training data  
✅ **No Python dependency** - Pure .NET solution

Would you like me to add features like:

- Batch auto-labeling using your current position rules?
- Export confidence reports for your 300 files?
- A “suggest labels” feature that pre-fills based on position rules?​​​​​​​​​​​​​​​​






