Perfect! I can see your data structure. Now let’s create a **clean, ML-only PowerPointExtractor**.

## **Questions Before We Start:**

1. **What accuracy did you get?** (Check the Output window from when you trained - look for “Macro Accuracy” and “Micro Accuracy”)
1. **How many total rows** are in your CSV? (Just scroll to the bottom in Excel)
1. I notice the first 9 columns (WI_Number through Template_Rev) are **empty** in your sample. Is this because:

- You haven’t extracted those values yet from the labeler?
- Or they’re populated in other rows?

But I can proceed anyway! Here’s the simplified extractor:

-----

# **Simplified PowerPointExtractor.cs (ML-Only)**

Replace your entire `PowerPointExtractor.cs` with this clean version:

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using Microsoft.Office.Interop.PowerPoint;
using Microsoft.Office.Core;
using OfficeOpenXml;
using OfficeOpenXml.Drawing;
using Microsoft.ML;
using Microsoft.ML.Data;

namespace WorkInstructionExtractor
{
    public class PowerPointExtractor
    {
        private MLContext _mlContext;
        private ITransformer _model;
        private PredictionEngine<MLTextBoxFeatures, MLTextBoxPrediction> _predictionEngine;
        private readonly float _confidenceThreshold = 0.50f; // 50% confidence minimum

        static PowerPointExtractor()
        {
            ExcelPackage.LicenseContext = LicenseContext.NonCommercial;
        }

        public PowerPointExtractor(string modelPath = null)
        {
            // Try to load ML model
            if (string.IsNullOrEmpty(modelPath))
            {
                modelPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "wi_extractor_model.zip");
            }

            if (File.Exists(modelPath))
            {
                try
                {
                    _mlContext = new MLContext();
                    _model = _mlContext.Model.Load(modelPath, out var modelSchema);
                    _predictionEngine = _mlContext.Model.CreatePredictionEngine<MLTextBoxFeatures, MLTextBoxPrediction>(_model);
                    Console.WriteLine($"✓ ML Model loaded from: {modelPath}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"✗ Could not load ML model: {ex.Message}");
                    throw new Exception("ML model is required for extraction. Please ensure wi_extractor_model.zip is in the application folder.");
                }
            }
            else
            {
                throw new FileNotFoundException($"ML model not found at: {modelPath}");
            }
        }

        public void ProcessPowerPoint(string pptPath, string outputFolder)
        {
            Console.WriteLine($"\nProcessing: {Path.GetFileName(pptPath)}");
            Console.WriteLine("=".PadRight(60, '='));

            var pptApp = new Microsoft.Office.Interop.PowerPoint.Application();
            Presentation ppt = null;

            try
            {
                Console.WriteLine("Opening PowerPoint file...");
                ppt = pptApp.Presentations.Open(pptPath,
                    MsoTriState.msoFalse, MsoTriState.msoFalse, MsoTriState.msoFalse);

                // Extract text boxes from first slide
                var textBoxes = ExtractTextBoxes(ppt);
                Console.WriteLine($"Found {textBoxes.Count} text boxes");

                // Extract data using ML
                var data = new Dictionary<string, string>();
                ExtractDataWithML(textBoxes, data);

                // Create Excel output
                string excelPath = CreateExcelOutput(pptPath, outputFolder, data, ppt);
                Console.WriteLine($"✓ Excel created: {Path.GetFileName(excelPath)}");

                Console.WriteLine("=".PadRight(60, '='));
                Console.WriteLine("✓ Processing complete\n");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"✗ Error: {ex.Message}");
                throw;
            }
            finally
            {
                ppt?.Close();
                pptApp.Quit();
            }
        }

        private List<TextBoxInfo> ExtractTextBoxes(Presentation ppt)
        {
            var textBoxes = new List<TextBoxInfo>();

            if (ppt.Slides.Count == 0)
                return textBoxes;

            Slide firstSlide = ppt.Slides[1];

            // Collect from all shape sources
            CollectTextBoxes(firstSlide.Shapes, textBoxes);
            
            try { CollectTextBoxes(firstSlide.Master.Shapes, textBoxes); } catch { }
            try { CollectTextBoxes(firstSlide.Design.SlideMaster.Shapes, textBoxes); } catch { }
            try { CollectTextBoxes(firstSlide.CustomLayout.Shapes, textBoxes); } catch { }

            // Remove duplicates (same text at same position)
            var uniqueBoxes = textBoxes
                .GroupBy(b => new { b.Text, Left = Math.Round(b.Left, 1), Top = Math.Round(b.Top, 1) })
                .Select(g => g.First())
                .Where(b => !string.IsNullOrWhiteSpace(b.Text))
                .ToList();

            return uniqueBoxes;
        }

        private void CollectTextBoxes(Microsoft.Office.Interop.PowerPoint.Shapes shapes, List<TextBoxInfo> textBoxes)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in shapes)
            {
                try
                {
                    if (shape.Type == MsoShapeType.msoGroup)
                    {
                        CollectTextBoxesFromGroup(shape.GroupItems, textBoxes);
                    }
                    else if (shape.HasTextFrame == MsoTriState.msoTrue)
                    {
                        string text = shape.TextFrame.TextRange.Text.Trim();
                        if (!string.IsNullOrEmpty(text) && !IsLabel(text.ToUpper()))
                        {
                            textBoxes.Add(new TextBoxInfo
                            {
                                Text = text,
                                Left = shape.Left,
                                Top = shape.Top,
                                Width = shape.Width,
                                Height = shape.Height
                            });
                        }
                    }
                }
                catch { }
            }
        }

        private void CollectTextBoxesFromGroup(Microsoft.Office.Interop.PowerPoint.GroupShapes groupShapes, List<TextBoxInfo> textBoxes)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in groupShapes)
            {
                try
                {
                    if (shape.Type == MsoShapeType.msoGroup)
                    {
                        CollectTextBoxesFromGroup(shape.GroupItems, textBoxes);
                    }
                    else if (shape.HasTextFrame == MsoTriState.msoTrue)
                    {
                        string text = shape.TextFrame.TextRange.Text.Trim();
                        if (!string.IsNullOrEmpty(text) && !IsLabel(text.ToUpper()))
                        {
                            textBoxes.Add(new TextBoxInfo
                            {
                                Text = text,
                                Left = shape.Left,
                                Top = shape.Top,
                                Width = shape.Width,
                                Height = shape.Height
                            });
                        }
                    }
                }
                catch { }
            }
        }

        private bool IsLabel(string upperText)
        {
            var labels = new[] {
                "WORK INSTRUCTION TITLE", "WORK INSTRUCTION", "DESCRIPTION", "DESCRIPTION:",
                "W.I. NUMBER", "WI NUMBER", "BOM/ASSY DWG NO", "BOM DWG NO", "ASSY DWG NO",
                "OPS (OPTIONAL)", "OPERATION NO", "OPERATION NO.", "PRODUCT LINE",
                "SUBJECT", "SUBJECT:", "PAGE", "REV", "REV:", "REVISION", "REVISION:"
            };

            return labels.Any(label => upperText == label || 
                   (upperText.Contains(label) && upperText.Length < 40)) ||
                   (upperText.EndsWith(":") && upperText.Length < 25);
        }

        private void ExtractDataWithML(List<TextBoxInfo> textBoxes, Dictionary<string, string> data)
        {
            // Initialize all fields
            data["WI_Number"] = "";
            data["WI_Title"] = "";
            data["Revision"] = "";
            data["BOM_ASSY_DWG_NO"] = "";
            data["Operation_No"] = "";
            data["Product_Line"] = "";
            data["Subject"] = "";
            data["Template_Revision"] = "";

            // Detect revision type for ML feature
            string revisionType = DetectRevisionType(textBoxes);
            Console.WriteLine($"Detected Template Revision: {revisionType}");

            var predictions = new Dictionary<string, (string text, float confidence)>();

            Console.WriteLine("\n--- ML Predictions ---");

            foreach (var box in textBoxes)
            {
                string text = box.Text.Trim();

                // Create features for ML model
                var features = new MLTextBoxFeatures
                {
                    Left = box.Left,
                    Top = box.Top,
                    Width = box.Width,
                    Height = box.Height,
                    TextLength = text.Length,
                    ContainsNumbers = Regex.IsMatch(text, @"\d") ? 1f : 0f,
                    ContainsHyphen = text.Contains("-") ? 1f : 0f,
                    StartsWithWI = text.StartsWith("WI", StringComparison.OrdinalIgnoreCase) ? 1f : 0f,
                    IsAllDigits = Regex.IsMatch(text, @"^\d+$") ? 1f : 0f,
                    RevisionType = revisionType
                };

                // Get ML prediction
                var prediction = _predictionEngine.Predict(features);

                if (prediction.Score != null && prediction.Score.Length > 0)
                {
                    float confidence = prediction.Score.Max();
                    string fieldType = prediction.FieldType;

                    // Only accept predictions above confidence threshold
                    if (confidence >= _confidenceThreshold && fieldType != "Ignore")
                    {
                        Console.WriteLine($"  {fieldType}: '{text}' ({confidence:P1})");

                        // Keep the highest confidence prediction for each field
                        if (!predictions.ContainsKey(fieldType) ||
                            predictions[fieldType].confidence < confidence)
                        {
                            predictions[fieldType] = (text, confidence);
                        }
                    }
                }
            }

            Console.WriteLine("\n--- Final Extracted Values ---");

            // Apply predictions to data
            foreach (var kvp in predictions)
            {
                if (data.ContainsKey(kvp.Key))
                {
                    data[kvp.Key] = kvp.Value.text;
                    Console.WriteLine($"  ✓ {kvp.Key} = '{kvp.Value.text}' ({kvp.Value.confidence:P1})");
                }
            }

            // Critical fallback for WI_Number if ML missed it
            if (string.IsNullOrEmpty(data["WI_Number"]))
            {
                Console.WriteLine("\n⚠ WI_Number not found by ML, trying pattern matching...");
                foreach (var box in textBoxes)
                {
                    var wiMatch = Regex.Match(box.Text,
                        @"W\.?\s*I\.?\s*-?\s*\d{4,}",
                        RegexOptions.IgnoreCase);

                    if (wiMatch.Success)
                    {
                        string wiNum = wiMatch.Value.Replace(" ", "").Replace(".", "").ToUpper();
                        if (!wiNum.Contains("-"))
                            wiNum = wiNum.Insert(2, "-");
                        data["WI_Number"] = wiNum;
                        Console.WriteLine($"  ✓ WI_Number = '{wiNum}' (pattern match)");
                        break;
                    }
                }
            }

            // Parse template revision if found
            if (!string.IsNullOrEmpty(data["Template_Revision"]))
            {
                string parsed = ParseTemplateRevision(data["Template_Revision"]);
                if (parsed != data["Template_Revision"])
                {
                    Console.WriteLine($"  → Parsed Template_Revision: '{data["Template_Revision"]}' → '{parsed}'");
                    data["Template_Revision"] = parsed;
                }
            }

            Console.WriteLine("----------------------\n");
        }

        private string DetectRevisionType(List<TextBoxInfo> textBoxes)
        {
            // Look for template revision pattern in bottom-right area
            var bottomRightBoxes = textBoxes
                .Where(b => b.Left > 300 && b.Top > 450)
                .OrderByDescending(b => b.Left)
                .ThenByDescending(b => b.Top);

            foreach (var box in bottomRightBoxes)
            {
                var match = Regex.Match(box.Text,
                    @"fm[-_\s]*me[-_\s]*\d+\s*rev\.?\s*(\d+)",
                    RegexOptions.IgnoreCase);

                if (match.Success && match.Groups.Count > 1)
                {
                    return match.Groups[1].Value;
                }
            }

            return "Unknown";
        }

        private string ParseTemplateRevision(string templateText)
        {
            if (string.IsNullOrWhiteSpace(templateText))
                return "";

            // Extract just the revision number from "FM-ME-07rev17" format
            var match = Regex.Match(templateText,
                @"rev\.?\s*(\d{1,2})",
                RegexOptions.IgnoreCase);

            if (match.Success)
                return match.Groups[1].Value;

            return templateText;
        }

        private string CreateExcelOutput(string pptPath, string outputFolder, 
            Dictionary<string, string> data, Presentation ppt)
        {
            string fileName = Path.GetFileNameWithoutExtension(pptPath);
            string excelPath = Path.Combine(outputFolder, $"{fileName}_extracted.xlsx");

            using (var package = new ExcelPackage())
            {
                // Header Data Sheet
                var headerSheet = package.Workbook.Worksheets.Add("Header Data");
                
                headerSheet.Cells["A1"].Value = "Field";
                headerSheet.Cells["B1"].Value = "Value";
                headerSheet.Cells["A1:B1"].Style.Font.Bold = true;

                int row = 2;
                foreach (var kvp in data)
                {
                    headerSheet.Cells[row, 1].Value = kvp.Key;
                    headerSheet.Cells[row, 2].Value = kvp.Value;
                    row++;
                }

                headerSheet.Cells[headerSheet.Dimension.Address].AutoFitColumns();

                // Images Sheet
                var imageSheet = package.Workbook.Worksheets.Add("Images");
                ExtractImages(ppt, imageSheet);

                package.SaveAs(new FileInfo(excelPath));
            }

            return excelPath;
        }

        private void ExtractImages(Presentation ppt, OfficeOpenXml.ExcelWorksheet worksheet)
        {
            int row = 1;
            int col = 1;
            int imagesPerRow = 2;
            int imageHeight = 300;

            foreach (Slide slide in ppt.Slides)
            {
                foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Shapes)
                {
                    try
                    {
                        if (shape.Type == MsoShapeType.msoPicture || 
                            shape.Type == MsoShapeType.msoLinkedPicture)
                        {
                            string tempImagePath = Path.Combine(Path.GetTempPath(), 
                                $"temp_image_{Guid.NewGuid()}.png");

                            try
                            {
                                shape.Export(tempImagePath, Microsoft.Office.Interop.PowerPoint.PpShapeFormat.ppShapeFormatPNG);

                                if (File.Exists(tempImagePath))
                                {
                                    var picture = worksheet.Drawings.AddPicture($"Image_{row}_{col}", 
                                        new FileInfo(tempImagePath));
                                    picture.SetPosition((row - 1) * imageHeight, 0, (col - 1) * 10, 0);
                                    picture.SetSize(400, 300);

                                    col++;
                                    if (col > imagesPerRow)
                                    {
                                        col = 1;
                                        row++;
                                    }

                                    File.Delete(tempImagePath);
                                }
                            }
                            catch { }
                        }
                    }
                    catch { }
                }
            }
        }

        // ML Model Classes
        public class MLTextBoxFeatures
        {
            public float Left { get; set; }
            public float Top { get; set; }
            public float Width { get; set; }
            public float Height { get; set; }
            public float TextLength { get; set; }
            public float ContainsNumbers { get; set; }
            public float ContainsHyphen { get; set; }
            public float StartsWithWI { get; set; }
            public float IsAllDigits { get; set; }
            public string RevisionType { get; set; }
        }

        public class MLTextBoxPrediction
        {
            [ColumnName("PredictedLabel")]
            public string FieldType { get; set; }

            public float[] Score { get; set; }
        }

        public class TextBoxInfo
        {
            public string Text { get; set; }
            public float Left { get; set; }
            public float Top { get; set; }
            public float Width { get; set; }
            public float Height { get; set; }
        }
    }
}
```

-----

## **What Changed:**

✅ **Removed 700+ lines** of position-based extraction code  
✅ **Single extraction method** (`ExtractDataWithML`) - uses ML for everything  
✅ **Confidence threshold** (50%) - only accepts predictions above this  
✅ **Pattern fallback** only for WI_Number (critical field)  
✅ **Cleaner console output** showing ML predictions and confidence  
✅ **Template revision parsing** built-in  
✅ **No revision-specific code** - works for all revisions automatically

## **Next Steps:**

1. **Copy model** to your extractor folder: `wi_extractor_model.zip`
1. **Test** on a single file
1. **Check accuracy** - are the predictions correct?
1. **Share results** - what confidence scores are you seeing?

If accuracy is high (>85%), you’re ready to process all 300 files! 🚀​​​​​​​​​​​​​​​​