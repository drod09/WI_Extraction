Form1.cs

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Reflection.Emit;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using static System.Windows.Forms.VisualStyles.VisualStyleElement;

namespace WorkInstructionExtractor
{
    public partial class Form1 : Form
    {
        private BackgroundWorker backgroundWorker;
        private bool isSingleFileMode = true;

        public Form1()
        {
            InitializeComponent();
            InitializeBackgroundWorker();
        }

        private void InitializeBackgroundWorker()
        {
            backgroundWorker = new BackgroundWorker
            {
                WorkerReportsProgress = true,
                WorkerSupportsCancellation = true
            };

            backgroundWorker.DoWork += BackgroundWorker_DoWork;
            backgroundWorker.ProgressChanged += BackgroundWorker_ProgressChanged;
            backgroundWorker.RunWorkerCompleted += BackgroundWorker_RunWorkerCompleted;
        }

        private void rbSingleFile_CheckedChanged(object sender, EventArgs e)
        {
            if (rbSingleFile.Checked)
            {
                isSingleFileMode = true;
                btnSelectFile.Visible = true;
                btnSelectFolder.Visible = false;
                txtPowerPointPath.Text = "";
                lblFileCount.Text = "";
                label1.Text = "Input File:";
                LogMessage("Mode: Single File Processing");
            }
        }

        private void rbBulkFolder_CheckedChanged(object sender, EventArgs e)
        {
            if (rbBulkFolder.Checked)
            {
                isSingleFileMode = false;
                btnSelectFile.Visible = false;
                btnSelectFolder.Visible = true;
                txtPowerPointPath.Text = "";
                lblFileCount.Text = "";
                label1.Text = "Input Folder:";
                LogMessage("Mode: Bulk Folder Processing");
            }
        }

        private void btnSelectFile_Click(object sender, EventArgs e)
        {
            using (OpenFileDialog openFileDialog = new OpenFileDialog())
            {
                openFileDialog.Filter = "PowerPoint Files (*.pptx;*.ppt)|*.pptx;*.ppt|All Files (*.*)|*.*";
                openFileDialog.Title = "Select PowerPoint Work Instruction";

                if (openFileDialog.ShowDialog() == DialogResult.OK)
                {
                    txtPowerPointPath.Text = openFileDialog.FileName;
                    lblFileCount.Text = "";
                    LogMessage($"Selected file: {Path.GetFileName(openFileDialog.FileName)}");

                    // Auto-set output folder to same directory as input file
                    if (string.IsNullOrEmpty(txtOutputFolder.Text))
                    {
                        string autoOutputFolder = Path.GetDirectoryName(openFileDialog.FileName);
                        txtOutputFolder.Text = autoOutputFolder;
                        LogMessage($"Auto-set output folder: {autoOutputFolder}");
                    }
                }
            }
        }

        private void btnSelectFolder_Click(object sender, EventArgs e)
        {
            using (FolderBrowserDialog folderDialog = new FolderBrowserDialog())
            {
                folderDialog.Description = "Select Folder Containing PowerPoint Files";

                if (folderDialog.ShowDialog() == DialogResult.OK)
                {
                    txtPowerPointPath.Text = folderDialog.SelectedPath;

                    // Count .pptx and .ppt files in folder
                    string[] files = Directory.GetFiles(folderDialog.SelectedPath, "*.ppt*")
                        .Where(f => !Path.GetFileName(f).StartsWith("~$"))
                        .ToArray();

                    lblFileCount.Text = $"({files.Length} PowerPoint file{(files.Length != 1 ? "s" : "")} found)";
                    lblFileCount.ForeColor = files.Length > 0 ? Color.DarkGreen : Color.Red;

                    LogMessage($"Selected folder: {folderDialog.SelectedPath}");
                    LogMessage($"Found {files.Length} PowerPoint file(s)");

                    // Auto-set output folder to same directory
                    if (string.IsNullOrEmpty(txtOutputFolder.Text))
                    {
                        txtOutputFolder.Text = folderDialog.SelectedPath;
                        LogMessage($"Auto-set output folder: {folderDialog.SelectedPath}");
                    }
                }
            }
        }

        private void btnSelectOutputFolder_Click(object sender, EventArgs e)
        {
            using (FolderBrowserDialog folderDialog = new FolderBrowserDialog())
            {
                folderDialog.Description = "Select Output Folder";

                if (folderDialog.ShowDialog() == DialogResult.OK)
                {
                    txtOutputFolder.Text = folderDialog.SelectedPath;
                    LogMessage($"Output folder: {folderDialog.SelectedPath}");
                }
            }
        }

        private void btnExtract_Click(object sender, EventArgs e)
        {
            // Validation
            if (string.IsNullOrWhiteSpace(txtPowerPointPath.Text))
            {
                MessageBox.Show(
                    isSingleFileMode ?
                    "Please select a PowerPoint file." :
                    "Please select a folder containing PowerPoint files.",
                    "Validation Error",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Warning);
                return;
            }

            if (string.IsNullOrWhiteSpace(txtOutputFolder.Text))
            {
                MessageBox.Show("Please select an output folder.", "Validation Error",
                    MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            // Additional validation for folder mode
            if (!isSingleFileMode)
            {
                string[] files = Directory.GetFiles(txtPowerPointPath.Text, "*.ppt*")
                    .Where(f => !Path.GetFileName(f).StartsWith("~$"))
                    .ToArray();

                if (files.Length == 0)
                {
                    MessageBox.Show("No PowerPoint files found in the selected folder.",
                        "Validation Error",
                        MessageBoxButtons.OK, MessageBoxIcon.Warning);
                    return;
                }
            }

            // Disable UI during processing
            SetUIEnabled(false);
            txtLog.Clear();
            progressBar.Value = 0;

            // Start background processing
            var workData = new ExtractionWorkData
            {
                InputPath = txtPowerPointPath.Text,
                OutputFolder = txtOutputFolder.Text,
                IsSingleFile = isSingleFileMode
            };

            LogMessage("=".PadRight(60, '='));
            LogMessage("STARTING EXTRACTION PROCESS");
            LogMessage("=".PadRight(60, '='));

            backgroundWorker.RunWorkerAsync(workData);
        }

        private void BackgroundWorker_DoWork(object sender, DoWorkEventArgs e)
        {
            var worker = sender as BackgroundWorker;
            var data = e.Argument as ExtractionWorkData;

            try
            {
                if (data.IsSingleFile)
                {
                    // Process single file
                    e.Result = ProcessSingleFile(worker, data);
                }
                else
                {
                    // Process multiple files
                    e.Result = ProcessMultipleFiles(worker, data);
                }
            }
            catch (Exception ex)
            {
                e.Result = new ExtractionResultWrapper
                {
                    Success = false,
                    ErrorMessage = ex.Message,
                    StackTrace = ex.StackTrace
                };
            }
        }

        private ExtractionResultWrapper ProcessSingleFile(BackgroundWorker worker, ExtractionWorkData data)
        {
            worker.ReportProgress(5, "Processing single file...");

            string fileName = Path.GetFileNameWithoutExtension(data.InputPath);

            // Create output subfolder with timestamp
            string timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
            string outputSubFolder = Path.Combine(data.OutputFolder, $"ExtractedData_{fileName}_{timestamp}");
            Directory.CreateDirectory(outputSubFolder);

            worker.ReportProgress(10, $"Extracting: {Path.GetFileName(data.InputPath)}");

            var extractor = new PowerPointExtractor();
            var extractResult = extractor.ExtractWorkInstruction(
                data.InputPath,
                outputSubFolder,
                (progress, message) => worker.ReportProgress(progress, message)
            );

            worker.ReportProgress(100, "Extraction complete!");

            return new ExtractionResultWrapper
            {
                Success = true,
                ExcelPath = extractResult.ExcelPath,
                OutputFolder = outputSubFolder,
                ProcessedCount = 1,
                FailedCount = 0
            };
        }

        private ExtractionResultWrapper ProcessMultipleFiles(BackgroundWorker worker, ExtractionWorkData data)
        {
            worker.ReportProgress(5, "Scanning for PowerPoint files...");

            string[] files = Directory.GetFiles(data.InputPath, "*.ppt*")
                .Where(f => !Path.GetFileName(f).StartsWith("~$"))
                .ToArray();

            worker.ReportProgress(10, $"Found {files.Length} file(s) to process");

            // Create main output folder with timestamp
            string timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
            string mainOutputFolder = Path.Combine(data.OutputFolder, $"ExtractedData_Bulk_{timestamp}");
            Directory.CreateDirectory(mainOutputFolder);

            int successCount = 0;
            var failures = new List<(string fileName, string error)>();

            var extractor = new PowerPointExtractor();

            for (int i = 0; i < files.Length; i++)
            {
                string file = files[i];
                string fileName = Path.GetFileName(file);

                try
                {
                    int baseProgress = 10 + (i * 80 / files.Length);
                    worker.ReportProgress(baseProgress, $"Processing {i + 1}/{files.Length}: {fileName}");

                    // Create subfolder for each file
                    string fileOutputFolder = Path.Combine(mainOutputFolder, Path.GetFileNameWithoutExtension(fileName));
                    Directory.CreateDirectory(fileOutputFolder);

                    var extractResult = extractor.ExtractWorkInstruction(
                        file,
                        fileOutputFolder,
                        (progress, message) =>
                        {
                            // Scale progress to current file's portion
                            int scaledProgress = baseProgress + (progress * 80 / files.Length / 100);
                            worker.ReportProgress(scaledProgress, $"[{i + 1}/{files.Length}] {message}");
                        }
                    );

                    successCount++;
                    worker.ReportProgress(baseProgress + (80 / files.Length), $"✓ Completed: {fileName}");
                }
                catch (Exception ex)
                {
                    failures.Add((fileName, ex.Message));
                    worker.ReportProgress(0, $"✗ Failed: {fileName} - {ex.Message}");
                }
            }

            worker.ReportProgress(95, "Creating summary report...");

            // Create summary report
            CreateSummaryReport(mainOutputFolder, files.Length, successCount, failures);

            worker.ReportProgress(100, $"Bulk processing complete! {successCount}/{files.Length} succeeded");

            return new ExtractionResultWrapper
            {
                Success = true,
                OutputFolder = mainOutputFolder,
                ProcessedCount = successCount,
                FailedCount = failures.Count,
                Failures = failures,
                IsBulk = true
            };
        }

        private void CreateSummaryReport(string outputFolder, int totalFiles, int successCount, List<(string fileName, string error)> failures)
        {
            string summaryPath = Path.Combine(outputFolder, "EXTRACTION_SUMMARY.txt");

            using (StreamWriter writer = new StreamWriter(summaryPath))
            {
                writer.WriteLine("=".PadRight(80, '='));
                writer.WriteLine("WORK INSTRUCTION EXTRACTION SUMMARY");
                writer.WriteLine("=".PadRight(80, '='));
                writer.WriteLine();
                writer.WriteLine($"Extraction Date: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
                writer.WriteLine($"Total Files Found: {totalFiles}");
                writer.WriteLine($"Successfully Processed: {successCount}");
                writer.WriteLine($"Failed: {failures.Count}");
                writer.WriteLine($"Success Rate: {(successCount * 100.0 / totalFiles):F1}%");
                writer.WriteLine();

                if (failures.Count > 0)
                {
                    writer.WriteLine("=".PadRight(80, '='));
                    writer.WriteLine("FAILED FILES");
                    writer.WriteLine("=".PadRight(80, '='));
                    writer.WriteLine();

                    foreach (var (fileName, error) in failures)
                    {
                        writer.WriteLine($"File: {fileName}");
                        writer.WriteLine($"Error: {error}");
                        writer.WriteLine();
                    }
                }

                writer.WriteLine("=".PadRight(80, '='));
                writer.WriteLine("OUTPUT STRUCTURE");
                writer.WriteLine("=".PadRight(80, '='));
                writer.WriteLine();
                writer.WriteLine("Each successfully processed file has a subfolder containing:");
                writer.WriteLine("  - Extracted_Data.xlsx (all extracted data)");
                writer.WriteLine("  - BaseImages/ (individual images)");
                writer.WriteLine("  - ComposedImages/ (grouped images)");
                writer.WriteLine();
            }
        }

        private void BackgroundWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            progressBar.Value = Math.Min(e.ProgressPercentage, 100);
            lblStatus.Text = e.UserState?.ToString() ?? "Processing...";

            if (!string.IsNullOrEmpty(e.UserState?.ToString()))
            {
                LogMessage(e.UserState.ToString());
            }
        }

        private void BackgroundWorker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            SetUIEnabled(true);

            var result = e.Result as ExtractionResultWrapper;

            if (result != null && result.Success)
            {
                LogMessage("");
                LogMessage("=".PadRight(60, '='));

                if (result.IsBulk)
                {
                    LogMessage($"✓ BULK EXTRACTION COMPLETED!", Color.Green);
                    LogMessage($"  Successfully processed: {result.ProcessedCount} file(s)", Color.Green);

                    if (result.FailedCount > 0)
                    {
                        LogMessage($"  Failed: {result.FailedCount} file(s)", Color.Red);
                    }

                    LogMessage("");
                    LogMessage($"Output location: {result.OutputFolder}");

                    var message = $"Bulk extraction completed!\n\n" +
                                  $"Successfully processed: {result.ProcessedCount}\n" +
                                  $"Failed: {result.FailedCount}\n\n" +
                                  $"Output folder: {result.OutputFolder}\n\n" +
                                  $"A summary report has been created.";

                    var openFolder = MessageBox.Show(
                        message + "\n\nWould you like to open the output folder?",
                        "Bulk Extraction Complete",
                        MessageBoxButtons.YesNo,
                        MessageBoxIcon.Information
                    );

                    if (openFolder == DialogResult.Yes)
                    {
                        System.Diagnostics.Process.Start("explorer.exe", result.OutputFolder);
                    }
                }
                else
                {
                    LogMessage("✓ EXTRACTION COMPLETED SUCCESSFULLY!", Color.Green);
                    LogMessage($"  Excel file: {Path.GetFileName(result.ExcelPath)}", Color.Green);
                    LogMessage($"  Output folder: {result.OutputFolder}");

                    var message = $"Data extracted successfully!\n\n" +
                                  $"Excel file: {Path.GetFileName(result.ExcelPath)}\n" +
                                  $"Output folder: {result.OutputFolder}";

                    var openFolder = MessageBox.Show(
                        message + "\n\nWould you like to open the output folder?",
                        "Extraction Complete",
                        MessageBoxButtons.YesNo,
                        MessageBoxIcon.Information
                    );

                    if (openFolder == DialogResult.Yes)
                    {
                        System.Diagnostics.Process.Start("explorer.exe", result.OutputFolder);
                    }
                }

                LogMessage("=".PadRight(60, '='));
            }
            else if (result != null && !result.Success)
            {
                LogMessage("");
                LogMessage("=".PadRight(60, '='));
                LogMessage($"✗ ERROR OCCURRED", Color.Red);
                LogMessage($"  {result.ErrorMessage}", Color.Red);
                LogMessage("=".PadRight(60, '='));

                MessageBox.Show($"An error occurred during extraction:\n\n{result.ErrorMessage}",
                    "Extraction Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void SetUIEnabled(bool enabled)
        {
            btnSelectFile.Enabled = enabled;
            btnSelectFolder.Enabled = enabled;
            btnSelectOutputFolder.Enabled = enabled;
            btnExtract.Enabled = enabled;
            rbSingleFile.Enabled = enabled;
            rbBulkFolder.Enabled = enabled;
        }

        private void LogMessage(string message, Color? color = null)
        {
            if (txtLog.InvokeRequired)
            {
                txtLog.Invoke(new Action(() => LogMessage(message, color)));
                return;
            }

            txtLog.SelectionStart = txtLog.TextLength;
            txtLog.SelectionLength = 0;
            txtLog.SelectionColor = color ?? Color.Black;
            txtLog.AppendText($"[{DateTime.Now:HH:mm:ss}] {message}\n");
            txtLog.SelectionColor = txtLog.ForeColor;
            txtLog.ScrollToCaret();
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            LogMessage("Work Instruction Data Extractor ready.");
            LogMessage("Select a single file or folder, then click 'Extract Data' to begin.");
        }
    }

    // Helper classes
    public class ExtractionWorkData
    {
        public string InputPath { get; set; }
        public string OutputFolder { get; set; }
        public bool IsSingleFile { get; set; }
    }

    public class ExtractionResultWrapper
    {
        public bool Success { get; set; }
        public string ExcelPath { get; set; }
        public string OutputFolder { get; set; }
        public string ErrorMessage { get; set; }
        public string StackTrace { get; set; }
        public int ProcessedCount { get; set; }
        public int FailedCount { get; set; }
        public List<(string fileName, string error)> Failures { get; set; } = new List<(string, string)>();
        public bool IsBulk { get; set; }
    }
}

-------------------------------------

Form1.Designer.cs

namespace WorkInstructionExtractor
{
    partial class Form1
    {
        private System.ComponentModel.IContainer components = null;

        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        private void InitializeComponent()
        {
            this.txtPowerPointPath = new System.Windows.Forms.TextBox();
            this.txtOutputFolder = new System.Windows.Forms.TextBox();
            this.btnSelectFile = new System.Windows.Forms.Button();
            this.btnSelectFolder = new System.Windows.Forms.Button();
            this.btnSelectOutputFolder = new System.Windows.Forms.Button();
            this.btnExtract = new System.Windows.Forms.Button();
            this.progressBar = new System.Windows.Forms.ProgressBar();
            this.txtLog = new System.Windows.Forms.RichTextBox();
            this.lblStatus = new System.Windows.Forms.Label();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.lblFileCount = new System.Windows.Forms.Label();
            this.rbBulkFolder = new System.Windows.Forms.RadioButton();
            this.rbSingleFile = new System.Windows.Forms.RadioButton();
            this.groupBox2 = new System.Windows.Forms.GroupBox();
            this.groupBox3 = new System.Windows.Forms.GroupBox();
            this.label4 = new System.Windows.Forms.Label();
            this.groupBox1.SuspendLayout();
            this.groupBox2.SuspendLayout();
            this.groupBox3.SuspendLayout();
            this.SuspendLayout();
            // 
            // txtPowerPointPath
            // 
            this.txtPowerPointPath.Location = new System.Drawing.Point(150, 60);
            this.txtPowerPointPath.Name = "txtPowerPointPath";
            this.txtPowerPointPath.ReadOnly = true;
            this.txtPowerPointPath.Size = new System.Drawing.Size(550, 22);
            this.txtPowerPointPath.TabIndex = 0;
            // 
            // txtOutputFolder
            // 
            this.txtOutputFolder.Location = new System.Drawing.Point(150, 95);
            this.txtOutputFolder.Name = "txtOutputFolder";
            this.txtOutputFolder.ReadOnly = true;
            this.txtOutputFolder.Size = new System.Drawing.Size(550, 22);
            this.txtOutputFolder.TabIndex = 2;
            // 
            // btnSelectFile
            // 
            this.btnSelectFile.Location = new System.Drawing.Point(720, 58);
            this.btnSelectFile.Name = "btnSelectFile";
            this.btnSelectFile.Size = new System.Drawing.Size(100, 26);
            this.btnSelectFile.TabIndex = 3;
            this.btnSelectFile.Text = "Browse...";
            this.btnSelectFile.UseVisualStyleBackColor = true;
            this.btnSelectFile.Click += new System.EventHandler(this.btnSelectFile_Click);
            // 
            // btnSelectFolder
            // 
            this.btnSelectFolder.Location = new System.Drawing.Point(720, 58);
            this.btnSelectFolder.Name = "btnSelectFolder";
            this.btnSelectFolder.Size = new System.Drawing.Size(100, 26);
            this.btnSelectFolder.TabIndex = 4;
            this.btnSelectFolder.Text = "Browse...";
            this.btnSelectFolder.UseVisualStyleBackColor = true;
            this.btnSelectFolder.Visible = false;
            this.btnSelectFolder.Click += new System.EventHandler(this.btnSelectFolder_Click);
            // 
            // btnSelectOutputFolder
            // 
            this.btnSelectOutputFolder.Location = new System.Drawing.Point(720, 93);
            this.btnSelectOutputFolder.Name = "btnSelectOutputFolder";
            this.btnSelectOutputFolder.Size = new System.Drawing.Size(100, 26);
            this.btnSelectOutputFolder.TabIndex = 5;
            this.btnSelectOutputFolder.Text = "Browse...";
            this.btnSelectOutputFolder.UseVisualStyleBackColor = true;
            this.btnSelectOutputFolder.Click += new System.EventHandler(this.btnSelectOutputFolder_Click);
            // 
            // btnExtract
            // 
            this.btnExtract.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(120)))), ((int)(((byte)(215)))));
            this.btnExtract.FlatAppearance.BorderSize = 0;
            this.btnExtract.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.btnExtract.Font = new System.Drawing.Font("Segoe UI", 11F, System.Drawing.FontStyle.Bold);
            this.btnExtract.ForeColor = System.Drawing.Color.White;
            this.btnExtract.Location = new System.Drawing.Point(295, 25);
            this.btnExtract.Name = "btnExtract";
            this.btnExtract.Size = new System.Drawing.Size(250, 45);
            this.btnExtract.TabIndex = 6;
            this.btnExtract.Text = "Extract Data";
            this.btnExtract.UseVisualStyleBackColor = false;
            this.btnExtract.Click += new System.EventHandler(this.btnExtract_Click);
            // 
            // progressBar
            // 
            this.progressBar.Location = new System.Drawing.Point(20, 80);
            this.progressBar.Name = "progressBar";
            this.progressBar.Size = new System.Drawing.Size(800, 25);
            this.progressBar.TabIndex = 7;
            // 
            // txtLog
            // 
            this.txtLog.BackColor = System.Drawing.Color.White;
            this.txtLog.Dock = System.Windows.Forms.DockStyle.Fill;
            this.txtLog.Font = new System.Drawing.Font("Consolas", 9F);
            this.txtLog.Location = new System.Drawing.Point(3, 18);
            this.txtLog.Name = "txtLog";
            this.txtLog.ReadOnly = true;
            this.txtLog.Size = new System.Drawing.Size(834, 239);
            this.txtLog.TabIndex = 8;
            this.txtLog.Text = "";
            // 
            // lblStatus
            // 
            this.lblStatus.Font = new System.Drawing.Font("Segoe UI", 9F);
            this.lblStatus.Location = new System.Drawing.Point(565, 35);
            this.lblStatus.Name = "lblStatus";
            this.lblStatus.Size = new System.Drawing.Size(255, 25);
            this.lblStatus.TabIndex = 10;
            this.lblStatus.Text = "Ready";
            this.lblStatus.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(20, 63);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(95, 16);
            this.label1.TabIndex = 13;
            this.label1.Text = "Input File/Folder:";
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(20, 30);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(108, 16);
            this.label2.TabIndex = 14;
            this.label2.Text = "Processing Mode:";
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(20, 98);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(93, 16);
            this.label3.TabIndex = 15;
            this.label3.Text = "Output Folder:";
            // 
            // groupBox1
            // 
            this.groupBox1.Controls.Add(this.lblFileCount);
            this.groupBox1.Controls.Add(this.rbBulkFolder);
            this.groupBox1.Controls.Add(this.rbSingleFile);
            this.groupBox1.Controls.Add(this.label2);
            this.groupBox1.Controls.Add(this.label1);
            this.groupBox1.Controls.Add(this.label3);
            this.groupBox1.Controls.Add(this.txtPowerPointPath);
            this.groupBox1.Controls.Add(this.txtOutputFolder);
            this.groupBox1.Controls.Add(this.btnSelectFile);
            this.groupBox1.Controls.Add(this.btnSelectFolder);
            this.groupBox1.Controls.Add(this.btnSelectOutputFolder);
            this.groupBox1.Location = new System.Drawing.Point(20, 70);
            this.groupBox1.Name = "groupBox1";
            this.groupBox1.Size = new System.Drawing.Size(840, 135);
            this.groupBox1.TabIndex = 16;
            this.groupBox1.TabStop = false;
            this.groupBox1.Text = "Input Configuration";
            // 
            // lblFileCount
            // 
            this.lblFileCount.AutoSize = true;
            this.lblFileCount.Font = new System.Drawing.Font("Segoe UI", 9F, System.Drawing.FontStyle.Italic);
            this.lblFileCount.ForeColor = System.Drawing.Color.DarkGreen;
            this.lblFileCount.Location = new System.Drawing.Point(440, 30);
            this.lblFileCount.Name = "lblFileCount";
            this.lblFileCount.Size = new System.Drawing.Size(0, 15);
            this.lblFileCount.TabIndex = 18;
            // 
            // rbBulkFolder
            // 
            this.rbBulkFolder.AutoSize = true;
            this.rbBulkFolder.Location = new System.Drawing.Point(260, 28);
            this.rbBulkFolder.Name = "rbBulkFolder";
            this.rbBulkFolder.Size = new System.Drawing.Size(165, 20);
            this.rbBulkFolder.TabIndex = 17;
            this.rbBulkFolder.Text = "Bulk Process (Folder)";
            this.rbBulkFolder.UseVisualStyleBackColor = true;
            this.rbBulkFolder.CheckedChanged += new System.EventHandler(this.rbBulkFolder_CheckedChanged);
            // 
            // rbSingleFile
            // 
            this.rbSingleFile.AutoSize = true;
            this.rbSingleFile.Checked = true;
            this.rbSingleFile.Location = new System.Drawing.Point(150, 28);
            this.rbSingleFile.Name = "rbSingleFile";
            this.rbSingleFile.Size = new System.Drawing.Size(91, 20);
            this.rbSingleFile.TabIndex = 16;
            this.rbSingleFile.TabStop = true;
            this.rbSingleFile.Text = "Single File";
            this.rbSingleFile.UseVisualStyleBackColor = true;
            this.rbSingleFile.CheckedChanged += new System.EventHandler(this.rbSingleFile_CheckedChanged);
            // 
            // groupBox2
            // 
            this.groupBox2.Controls.Add(this.btnExtract);
            this.groupBox2.Controls.Add(this.lblStatus);
            this.groupBox2.Controls.Add(this.progressBar);
            this.groupBox2.Location = new System.Drawing.Point(20, 210);
            this.groupBox2.Name = "groupBox2";
            this.groupBox2.Size = new System.Drawing.Size(840, 120);
            this.groupBox2.TabIndex = 17;
            this.groupBox2.TabStop = false;
            this.groupBox2.Text = "Extraction Progress";
            // 
            // groupBox3
            // 
            this.groupBox3.Controls.Add(this.txtLog);
            this.groupBox3.Location = new System.Drawing.Point(20, 340);
            this.groupBox3.Name = "groupBox3";
            this.groupBox3.Size = new System.Drawing.Size(840, 260);
            this.groupBox3.TabIndex = 18;
            this.groupBox3.TabStop = false;
            this.groupBox3.Text = "Activity Log";
            // 
            // label4
            // 
            this.label4.Font = new System.Drawing.Font("Segoe UI", 16F, System.Drawing.FontStyle.Bold);
            this.label4.Location = new System.Drawing.Point(20, 20);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(840, 40);
            this.label4.TabIndex = 19;
            this.label4.Text = "Work Instruction Data Extractor";
            this.label4.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
            // 
            // Form1
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(880, 620);
            this.Controls.Add(this.label4);
            this.Controls.Add(this.groupBox3);
            this.Controls.Add(this.groupBox2);
            this.Controls.Add(this.groupBox1);
            this.MinimumSize = new System.Drawing.Size(896, 659);
            this.Name = "Form1";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = "Work Instruction Data Extractor";
            this.Load += new System.EventHandler(this.Form1_Load);
            this.groupBox1.ResumeLayout(false);
            this.groupBox1.PerformLayout();
            this.groupBox2.ResumeLayout(false);
            this.groupBox3.ResumeLayout(false);
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.TextBox txtPowerPointPath;
        private System.Windows.Forms.TextBox txtOutputFolder;
        private System.Windows.Forms.Button btnSelectFile;
        private System.Windows.Forms.Button btnSelectFolder;
        private System.Windows.Forms.Button btnSelectOutputFolder;
        private System.Windows.Forms.Button btnExtract;
        private System.Windows.Forms.ProgressBar progressBar;
        private System.Windows.Forms.RichTextBox txtLog;
        private System.Windows.Forms.Label lblStatus;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.GroupBox groupBox1;
        private System.Windows.Forms.RadioButton rbSingleFile;
        private System.Windows.Forms.RadioButton rbBulkFolder;
        private System.Windows.Forms.GroupBox groupBox2;
        private System.Windows.Forms.GroupBox groupBox3;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.Label lblFileCount;
    }
}
---------------------------------------
powerpointextractor.cs

using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using PowerPointApp = Microsoft.Office.Interop.PowerPoint.Application;
using Microsoft.Office.Interop.PowerPoint;
using Microsoft.Office.Core;
using OfficeOpenXml;

namespace WorkInstructionExtractor
{
    public class PowerPointExtractor
    {
        static PowerPointExtractor()
        {
            ExcelPackage.License.SetNonCommercialPersonal("<Diana>");
        }

        public ExtractionResult ExtractWorkInstruction(
            string pptxPath,
            string outputFolder,
            Action<int, string> progressCallback = null)
        {
            progressCallback?.Invoke(0, "Starting extraction...");

            // Create output folders
            string baseImagesFolder = Path.Combine(outputFolder, "BaseImages");
            string composedImagesFolder = Path.Combine(outputFolder, "ComposedImages");

            if (!Directory.Exists(baseImagesFolder))
                Directory.CreateDirectory(baseImagesFolder);
            if (!Directory.Exists(composedImagesFolder))
                Directory.CreateDirectory(composedImagesFolder);

            string headerExcel = Path.Combine(outputFolder, "HeaderData.xlsx");
            string tablesExcel = Path.Combine(outputFolder, "TablesData.xlsx");
            string finalExcel = Path.Combine(outputFolder, "Extracted_Data.xlsx");

            // STEP 1: Extract header data and images with C#
            progressCallback?.Invoke(10, "Extracting header data and images...");
            var (headerData, tocData) = ExtractHeadersAndImages(pptxPath, headerExcel, baseImagesFolder, composedImagesFolder, progressCallback);

            // Safely get WI_Number with fallback to filename
            string wiNumber = "";
            if (headerData.Count > 0 && headerData[0].ContainsKey("WI_Number"))
            {
                wiNumber = headerData[0]["WI_Number"];
            }
            else
            {
                // Fallback: use filename without extension
                wiNumber = Path.GetFileNameWithoutExtension(pptxPath);
                progressCallback?.Invoke(0, $"⚠️ Warning: WI_Number not found, using filename: {wiNumber}");
            }

            // STEP 2: Run Python script to extract tables (pass the single file, not folder)
            progressCallback?.Invoke(40, "Extracting table data with Python...");
            bool pythonSuccess = RunPythonScript(pptxPath, tablesExcel, progressCallback);

            if (!pythonSuccess)
            {
                progressCallback?.Invoke(100, "⚠️ Warning: Table extraction failed. Only header data and images extracted.");
            }
            else
            {
                // STEP 3: Merge the data
                progressCallback?.Invoke(80, "Merging data into final Excel file...");
                MergeExcelFiles(headerExcel, tablesExcel, finalExcel);

                // Clean up intermediate files
                try
                {
                    File.Delete(headerExcel);
                    File.Delete(tablesExcel);
                }
                catch { }

                progressCallback?.Invoke(100, "Extraction complete!");
            }

            return new ExtractionResult
            {
                ExcelPath = finalExcel,
                BaseImagesFolder = baseImagesFolder,
                ComposedImagesFolder = composedImagesFolder,
                WINumber = wiNumber
            };
        }

        private (List<Dictionary<string, string>> headerData, List<Dictionary<string, string>> tocData) ExtractHeadersAndImages(
            string filePath, string excelPath, string baseImagesFolder, string composedImagesFolder, Action<int, string> progressCallback)
        {
            var headerData = new List<Dictionary<string, string>>();
            var imageData = new List<Dictionary<string, string>>();
            var textData = new List<Dictionary<string, string>>();
            var tocData = new List<Dictionary<string, string>>();

            PowerPointApp pptApp = new PowerPointApp();
            int docCounter = 1;

            try
            {
                progressCallback?.Invoke(15, $"Opening PowerPoint file...");

                Presentation ppt = pptApp.Presentations.Open(filePath,
                    MsoTriState.msoFalse,
                    MsoTriState.msoFalse,
                    MsoTriState.msoFalse);

                if (ppt.Slides.Count > 0)
                {
                    progressCallback?.Invoke(20, "Extracting header data...");

                    Slide firstSlide = ppt.Slides[1];

                    var data = new Dictionary<string, string>();
                    data["DocumentID"] = docCounter.ToString();
                    data["SourceFileName"] = Path.GetFileName(filePath);

                    var allTextBoxes = new List<TextBoxInfo>();

                    CollectTextBoxes(firstSlide.Shapes, allTextBoxes);
                    try { CollectTextBoxes(firstSlide.Master.Shapes, allTextBoxes); } catch { }
                    try { CollectTextBoxes(firstSlide.Design.SlideMaster.Shapes, allTextBoxes); } catch { }
                    try { CollectTextBoxes(firstSlide.CustomLayout.Shapes, allTextBoxes); } catch { }

                    // CRITICAL: Extract data from the collected textboxes
                    ExtractData(allTextBoxes, data, ppt);

                    int totalPages = ppt.Slides.Count;
                    data["TotalPages"] = totalPages.ToString();

                    progressCallback?.Invoke(25, "Extracting images...");

                    var images = ExtractImagesFromPresentation(ppt, docCounter, GetValue(data, "WI_Number"),
                        Path.GetFileName(filePath), baseImagesFolder, composedImagesFolder);
                    imageData.AddRange(images);

                    data["TotalImages"] = images.Count.ToString();

                    progressCallback?.Invoke(30, "Extracting text content...");

                    var slideTexts = ExtractTextFromSlides(ppt, docCounter, GetValue(data, "WI_Number"),
                        Path.GetFileName(filePath));
                    textData.AddRange(slideTexts);

                    progressCallback?.Invoke(33, "Building table of contents...");

                    var tocEntries = ExtractTableOfContents(ppt, docCounter, GetValue(data, "WI_Number"),
                        Path.GetFileName(filePath));
                    tocData.AddRange(tocEntries);

                    // Extract subject from TOC if available
                    if (tocEntries.Count > 0 && string.IsNullOrEmpty(GetValue(data, "Subject")))
                    {
                        data["Subject"] = tocEntries[0]["SlideSubject"];
                    }

                    headerData.Add(data);

                    progressCallback?.Invoke(35, $"Extracted: {GetValue(data, "WI_Number")}");
                }

                ppt.Close();
            }
            finally
            {
                pptApp.Quit();
            }

            WriteToExcel(headerData, imageData, textData, tocData, excelPath);

            return (headerData, tocData);
        }

        private void ExtractDataWithPatterns(List<TextBoxInfo> textBoxes, Dictionary<string, string> data)
        {
            // Pattern-based extraction that doesn't rely on position
            foreach (var box in textBoxes)
            {
                string text = box.Text.Trim();
                string upperText = text.ToUpper();

                // Extract WI Number (pattern-based, position-independent)
                if (string.IsNullOrEmpty(GetValue(data, "WI_Number")))
                {
                    var wiMatch = System.Text.RegularExpressions.Regex.Match(text,
                        @"W\.?I\.?\s*-?\s*\d+",
                        System.Text.RegularExpressions.RegexOptions.IgnoreCase);

                    if (wiMatch.Success)
                    {
                        string wiNum = wiMatch.Value.Replace(" ", "").Replace(".", "");
                        if (!wiNum.Contains("-"))
                            wiNum = wiNum.Replace("WI", "WI-");
                        data["WI_Number"] = wiNum.ToUpper();
                    }
                }

                // Extract Revision (pattern-based)
                if (string.IsNullOrEmpty(GetValue(data, "Revision")))
                {
                    // Skip labels
                    if (upperText == "REV" || upperText == "REV:" || upperText == "REVISION:")
                        continue;

                    // Look for single/double digit revisions
                    if (text.Length >= 1 && text.Length <= 3 &&
                        System.Text.RegularExpressions.Regex.IsMatch(text, @"^[0-9]+$"))
                    {
                        // This could be a revision number - only set if not already set
                        if (string.IsNullOrEmpty(GetValue(data, "Revision")))
                        {
                            data["Revision"] = text;
                        }
                    }
                }

                // Extract Template Revision (pattern-based)
                if (upperText.Contains("FM-ME") || upperText.Contains("FM ME") || upperText.Contains("FMME"))
                {
                    var revMatch = System.Text.RegularExpressions.Regex.Match(text,
                        @"FM-?[\s]?ME-?\d+.*?rev\.?\s*(\d+)",
                        System.Text.RegularExpressions.RegexOptions.IgnoreCase);

                    if (revMatch.Success && revMatch.Groups.Count > 1)
                    {
                        data["RevisionType"] = revMatch.Groups[1].Value;
                    }
                }
            }
        }

        private List<Dictionary<string, string>> ExtractTextFromSlides(Presentation ppt, int docId, string wiNumber, string sourceFileName)
        {
            var textData = new List<Dictionary<string, string>>();

            for (int slideIdx = 2; slideIdx <= ppt.Slides.Count; slideIdx++)
            {
                try
                {
                    Slide slide = ppt.Slides[slideIdx];
                    string slideSubject = ExtractSlideSubject(slide);
                    int textBoxCounter = 1;

                    foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Shapes)
                    {
                        // Skip tables - we don't want to extract table data as text
                        if (shape.HasTable == MsoTriState.msoTrue)
                        {
                            continue;
                        }

                        string extractedText = ExtractTextFromShape(shape);
                        if (!string.IsNullOrWhiteSpace(extractedText))
                        {
                            // IMPORTANT: Skip if this text IS the slide subject (avoid duplication)
                            string normalizedExtracted = extractedText.Trim().ToUpper();
                            string normalizedSubject = slideSubject.Trim().ToUpper();

                            if (normalizedExtracted == normalizedSubject)
                            {
                                // This is the slide title/subject - skip it
                                continue;
                            }

                            textData.Add(new Dictionary<string, string>
                            {
                                ["DocumentID"] = docId.ToString(),
                                ["WI_Number"] = wiNumber,
                                ["SourceFileName"] = sourceFileName,
                                ["SlideNumber"] = slideIdx.ToString(),
                                ["SlideSubject"] = slideSubject,
                                ["TextBoxNumber"] = textBoxCounter.ToString(),
                                ["TextContent"] = extractedText.Trim()
                            });

                            textBoxCounter++;
                        }
                    }
                }
                catch { }
            }

            return textData;
        }

        private string ExtractSlideSubject(Slide slide)
        {
            try
            {
                var slideShapes = new List<(string text, float left, float top, float height, float width)>();
                var masterShapes = new List<(string text, float left, float top, float height, float width)>();

                // Collect shapes from slide (PRIORITY 1)
                foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Shapes)
                {
                    try
                    {
                        if (shape.HasTextFrame == MsoTriState.msoTrue)
                        {
                            string text = shape.TextFrame.TextRange.Text.Trim();
                            if (!string.IsNullOrWhiteSpace(text))
                            {
                                slideShapes.Add((text, shape.Left, shape.Top, shape.Height, shape.Width));
                            }
                        }
                    }
                    catch { }
                }

                // Collect shapes from master slide (PRIORITY 2)
                try
                {
                    foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Master.Shapes)
                    {
                        try
                        {
                            if (shape.HasTextFrame == MsoTriState.msoTrue)
                            {
                                string text = shape.TextFrame.TextRange.Text.Trim();
                                if (!string.IsNullOrWhiteSpace(text))
                                {
                                    masterShapes.Add((text, shape.Left, shape.Top, shape.Height, shape.Width));
                                }
                            }
                        }
                        catch { }
                    }
                }
                catch { }

                // Collect shapes from design master (PRIORITY 2)
                try
                {
                    foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Design.SlideMaster.Shapes)
                    {
                        try
                        {
                            if (shape.HasTextFrame == MsoTriState.msoTrue)
                            {
                                string text = shape.TextFrame.TextRange.Text.Trim();
                                if (!string.IsNullOrWhiteSpace(text))
                                {
                                    masterShapes.Add((text, shape.Left, shape.Top, shape.Height, shape.Width));
                                }
                            }
                        }
                        catch { }
                    }
                }
                catch { }

                // Collect shapes from custom layout (PRIORITY 2)
                try
                {
                    foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.CustomLayout.Shapes)
                    {
                        try
                        {
                            if (shape.HasTextFrame == MsoTriState.msoTrue)
                            {
                                string text = shape.TextFrame.TextRange.Text.Trim();
                                if (!string.IsNullOrWhiteSpace(text))
                                {
                                    masterShapes.Add((text, shape.Left, shape.Top, shape.Height, shape.Width));
                                }
                            }
                        }
                        catch { }
                    }
                }
                catch { }

                // FIRST: Try to find subject from slide shapes (takes precedence)
                foreach (var shape in slideShapes)
                {
                    string text = shape.text;
                    string upperText = text.ToUpper();

                    // Skip label fields and placeholders
                    if (upperText == "SUBJECT" || upperText == "SUBJECT:" ||
                        upperText.Contains("COMPANY") || upperText.Contains("WORK INSTRUCTION") ||
                        upperText.Contains("W.I. NUMBER") || upperText.Contains("BOM") ||
                        upperText.Contains("OPERATION NO") || upperText == "PRODUCT LINE" ||
                        upperText == "PAGE" || upperText == "REV" ||
                        upperText.Contains("FM-ME") || upperText.Contains("REVISION HISTORY") ||
                        upperText.Contains("DRAFTING") || upperText.Contains("APPROVALS") ||
                        upperText.Contains("SUBJECT OF SLIDE") || upperText.Contains("WORK PKG") ||
                        upperText.Contains("<SUBJECT OF SLIDE>") || upperText.Contains("< SUBJECT") ||
                        upperText.Contains("SUBJECT >") || upperText == "SUBJECT OF THIS SLIDE" ||
                        System.Text.RegularExpressions.Regex.IsMatch(text, @"^\s*\<?\#?\>?\s*OF\s+\d+\s*$", System.Text.RegularExpressions.RegexOptions.IgnoreCase) ||
                        System.Text.RegularExpressions.Regex.IsMatch(text, @"^\s*\d+\s+OF\s+\d+\s*$", System.Text.RegularExpressions.RegexOptions.IgnoreCase) ||
                        System.Text.RegularExpressions.Regex.IsMatch(text, @"^\s*PAGE\s+\d+", System.Text.RegularExpressions.RegexOptions.IgnoreCase))
                        continue;

                    // Position ranges for subject field at bottom of slide
                    // Rev 15-16 (5:4 aspect ratio) - X: 4.2-4.5" (302-324 pts), Y: 6.8-7.1" (490-511 pts)
                    bool isRev15_16Subject = (shape.left > 300 && shape.left < 330 &&
                                             shape.top > 488 && shape.top < 515);

                    // Rev 17-19 (4:3 aspect ratio) - X: 4.2-4.6" (302-331 pts), Y: 6.8-7.1" (490-511 pts)
                    bool isRev17_19Subject = (shape.left > 300 && shape.left < 335) &&
                                            (shape.top > 488 && shape.top < 515) &&
                                            text.Length > 2 && text.Length < 100;

                    if (isRev15_16Subject || isRev17_19Subject)
                    {
                        return text.ToUpper();
                    }
                }

                // SECOND: If not found on slide, try master/custom layout shapes
                foreach (var shape in masterShapes)
                {
                    string text = shape.text;
                    string upperText = text.ToUpper();

                    // Skip label fields and placeholders
                    if (upperText == "SUBJECT" || upperText == "SUBJECT:" ||
                        upperText.Contains("COMPANY") || upperText.Contains("WORK INSTRUCTION") ||
                        upperText.Contains("W.I. NUMBER") || upperText.Contains("BOM") ||
                        upperText.Contains("OPERATION NO") || upperText == "PRODUCT LINE" ||
                        upperText == "PAGE" || upperText == "REV" ||
                        upperText.Contains("FM-ME") || upperText.Contains("REVISION HISTORY") ||
                        upperText.Contains("DRAFTING") || upperText.Contains("APPROVALS") ||
                        upperText.Contains("SUBJECT OF SLIDE") || upperText.Contains("WORK PKG") ||
                        upperText.Contains("<SUBJECT OF SLIDE>") || upperText.Contains("< SUBJECT") ||
                        upperText.Contains("SUBJECT >") || upperText == "SUBJECT OF THIS SLIDE" ||
                        System.Text.RegularExpressions.Regex.IsMatch(text, @"^\s*\<?\#?\>?\s*OF\s+\d+\s*$", System.Text.RegularExpressions.RegexOptions.IgnoreCase) ||
                        System.Text.RegularExpressions.Regex.IsMatch(text, @"^\s*\d+\s+OF\s+\d+\s*$", System.Text.RegularExpressions.RegexOptions.IgnoreCase) ||
                        System.Text.RegularExpressions.Regex.IsMatch(text, @"^\s*PAGE\s+\d+", System.Text.RegularExpressions.RegexOptions.IgnoreCase))
                        continue;

                    // Position ranges for subject field at bottom of slide
                    // Rev 15-16 (5:4 aspect ratio) - X: 4.2-4.5" (302-324 pts), Y: 6.8-7.1" (490-511 pts)
                    bool isRev15_16Subject = (shape.left > 300 && shape.left < 330 &&
                                             shape.top > 488 && shape.top < 515);

                    // Rev 17-19 (4:3 aspect ratio) - X: 4.2-4.6" (302-331 pts), Y: 6.8-7.1" (490-511 pts)
                    bool isRev17_19Subject = (shape.left > 300 && shape.left < 335) &&
                                            (shape.top > 488 && shape.top < 515) &&
                                            text.Length > 2 && text.Length < 100;

                    if (isRev15_16Subject || isRev17_19Subject)
                    {
                        return text.ToUpper();
                    }
                }

                return "UNTITLED SLIDE";
            }
            catch
            {
                return "UNTITLED SLIDE";
            }
        }

        private string ExtractTextFromShape(Microsoft.Office.Interop.PowerPoint.Shape shape)
        {
            var text = new System.Text.StringBuilder();

            try
            {
                if (shape.Type == MsoShapeType.msoGroup)
                {
                    foreach (Microsoft.Office.Interop.PowerPoint.Shape groupShape in shape.GroupItems)
                    {
                        string groupText = ExtractTextFromShape(groupShape);
                        if (!string.IsNullOrWhiteSpace(groupText))
                        {
                            text.AppendLine(groupText);
                        }
                    }
                }
                else if (shape.HasTextFrame == MsoTriState.msoTrue)
                {
                    try
                    {
                        string shapeText = shape.TextFrame.TextRange.Text;
                        if (!string.IsNullOrWhiteSpace(shapeText))
                        {
                            text.AppendLine(shapeText.Trim());
                        }
                    }
                    catch { }
                }
            }
            catch { }

            return text.ToString().Trim();
        }

        private List<Dictionary<string, string>> ExtractTableOfContents(Presentation ppt, int docId, string wiNumber, string sourceFileName)
        {
            var tocData = new List<Dictionary<string, string>>();

            string currentSubject = null;
            int subjectStartSlide = 0;
            int slideCount = 0;

            for (int slideIdx = 1; slideIdx <= ppt.Slides.Count; slideIdx++)
            {
                try
                {
                    Slide slide = ppt.Slides[slideIdx];
                    string slideSubject = ExtractSlideSubject(slide);

                    // Convert to uppercase
                    slideSubject = slideSubject.ToUpper();

                    // Check if subject changed or if it's a new subject
                    if (currentSubject == null)
                    {
                        // First slide
                        currentSubject = slideSubject;
                        subjectStartSlide = slideIdx;
                        slideCount = 1;
                    }
                    else if (slideSubject == currentSubject)
                    {
                        // Same subject continues
                        slideCount++;
                    }
                    else
                    {
                        // Subject changed - save the previous subject entry
                        tocData.Add(new Dictionary<string, string>
                        {
                            ["DocumentID"] = docId.ToString(),
                            ["WI_Number"] = wiNumber,
                            ["SourceFileName"] = sourceFileName,
                            ["SlideNumber"] = subjectStartSlide.ToString(),
                            ["SlideSubject"] = currentSubject,
                            ["SlideTotal"] = slideCount.ToString()
                        });

                        // Start tracking new subject
                        currentSubject = slideSubject;
                        subjectStartSlide = slideIdx;
                        slideCount = 1;
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error processing slide {slideIdx} for TOC: {ex.Message}");
                }
            }

            // Don't forget to add the last subject
            if (currentSubject != null)
            {
                tocData.Add(new Dictionary<string, string>
                {
                    ["DocumentID"] = docId.ToString(),
                    ["WI_Number"] = wiNumber,
                    ["SourceFileName"] = sourceFileName,
                    ["SlideNumber"] = subjectStartSlide.ToString(),
                    ["SlideSubject"] = currentSubject,
                    ["SlideTotal"] = slideCount.ToString()
                });
            }

            return tocData;
        }

        private List<Dictionary<string, string>> ExtractImagesFromPresentation(Presentation ppt, int docId,
            string wiNumber, string sourceFileName, string baseImagesFolder, string composedImagesFolder)
        {
            var imageData = new List<Dictionary<string, string>>();
            int imageCounter = 1;

            string cleanWiNumber = wiNumber;
            if (wiNumber.StartsWith("WI-WI-"))
            {
                cleanWiNumber = wiNumber.Substring(3);
            }

            string docFolderName = !string.IsNullOrEmpty(cleanWiNumber) ? cleanWiNumber : $"Doc-{docId}";
            docFolderName = MakeValidFolderName(docFolderName);

            string baseDocFolder = Path.Combine(baseImagesFolder, docFolderName);
            string composedDocFolder = Path.Combine(composedImagesFolder, docFolderName);

            if (!Directory.Exists(baseDocFolder))
                Directory.CreateDirectory(baseDocFolder);
            if (!Directory.Exists(composedDocFolder))
                Directory.CreateDirectory(composedDocFolder);

            for (int slideIdx = 1; slideIdx <= ppt.Slides.Count; slideIdx++)
            {
                Slide slide = ppt.Slides[slideIdx];

                foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Shapes)
                {
                    try
                    {
                        if (shape.Type == MsoShapeType.msoPicture)
                        {
                            string imageFileName = $"{cleanWiNumber}_Slide{slideIdx:D2}_Img{imageCounter:D2}.png";
                            string imagePath = Path.Combine(baseDocFolder, imageFileName);

                            ExportShape(shape, imagePath);

                            imageData.Add(new Dictionary<string, string>
                            {
                                ["DocumentID"] = docId.ToString(),
                                ["WI_Number"] = cleanWiNumber,
                                ["SourceFileName"] = sourceFileName,
                                ["SlideNumber"] = slideIdx.ToString(),
                                ["ImageNumber"] = imageCounter.ToString(),
                                ["ImageType"] = "Base",
                                ["ImageFileName"] = imageFileName,
                                ["ImagePath"] = Path.Combine(docFolderName, imageFileName),
                                ["IsGrouped"] = "No",
                                ["Width"] = shape.Width.ToString("F2"),
                                ["Height"] = shape.Height.ToString("F2")
                            });

                            imageCounter++;
                        }
                        else if (shape.Type == MsoShapeType.msoGroup)
                        {
                            bool hasImages = ContainsPictures(shape.GroupItems);

                            if (hasImages)
                            {
                                string composedFileName = $"{cleanWiNumber}_Slide{slideIdx:D2}_Composed{imageCounter:D2}.png";
                                string composedPath = Path.Combine(composedDocFolder, composedFileName);

                                ExportShape(shape, composedPath);

                                imageData.Add(new Dictionary<string, string>
                                {
                                    ["DocumentID"] = docId.ToString(),
                                    ["WI_Number"] = cleanWiNumber,
                                    ["SourceFileName"] = sourceFileName,
                                    ["SlideNumber"] = slideIdx.ToString(),
                                    ["ImageNumber"] = imageCounter.ToString(),
                                    ["ImageType"] = "Composed",
                                    ["ImageFileName"] = composedFileName,
                                    ["ImagePath"] = Path.Combine(docFolderName, composedFileName),
                                    ["IsGrouped"] = "Yes",
                                    ["Width"] = shape.Width.ToString("F2"),
                                    ["Height"] = shape.Height.ToString("F2")
                                });

                                ExtractImagesFromGroup(shape.GroupItems, docId, cleanWiNumber, sourceFileName,
                                    slideIdx, ref imageCounter, baseDocFolder, docFolderName, imageData);

                                imageCounter++;
                            }
                        }
                    }
                    catch { }
                }
            }

            return imageData;
        }

        private void ExtractImagesFromGroup(Microsoft.Office.Interop.PowerPoint.GroupShapes groupShapes, int docId,
            string wiNumber, string sourceFileName, int slideIdx, ref int imageCounter,
            string baseDocFolder, string docFolderName, List<Dictionary<string, string>> imageData)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in groupShapes)
            {
                try
                {
                    if (shape.Type == MsoShapeType.msoPicture)
                    {
                        string imageFileName = $"{wiNumber}_Slide{slideIdx:D2}_Img{imageCounter:D2}_FromGroup.png";
                        string imagePath = Path.Combine(baseDocFolder, imageFileName);

                        ExportShape(shape, imagePath);

                        imageData.Add(new Dictionary<string, string>
                        {
                            ["DocumentID"] = docId.ToString(),
                            ["WI_Number"] = wiNumber,
                            ["SourceFileName"] = sourceFileName,
                            ["SlideNumber"] = slideIdx.ToString(),
                            ["ImageNumber"] = imageCounter.ToString(),
                            ["ImageType"] = "Base",
                            ["ImageFileName"] = imageFileName,
                            ["ImagePath"] = Path.Combine(docFolderName, imageFileName),
                            ["IsGrouped"] = "Yes (Extracted)",
                            ["Width"] = shape.Width.ToString("F2"),
                            ["Height"] = shape.Height.ToString("F2")
                        });

                        imageCounter++;
                    }
                    else if (shape.Type == MsoShapeType.msoGroup)
                    {
                        ExtractImagesFromGroup(shape.GroupItems, docId, wiNumber, sourceFileName,
                            slideIdx, ref imageCounter, baseDocFolder, docFolderName, imageData);
                    }
                }
                catch { }
            }
        }

        private bool ContainsPictures(Microsoft.Office.Interop.PowerPoint.GroupShapes groupShapes)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in groupShapes)
            {
                if (shape.Type == MsoShapeType.msoPicture)
                    return true;
                if (shape.Type == MsoShapeType.msoGroup && ContainsPictures(shape.GroupItems))
                    return true;
            }
            return false;
        }

        private void ExportShape(Microsoft.Office.Interop.PowerPoint.Shape shape, string outputPath)
        {
            try
            {
                shape.Export(outputPath, PpShapeFormat.ppShapeFormatPNG);
            }
            catch
            {
                try
                {
                    shape.Copy();
                    var img = System.Windows.Forms.Clipboard.GetImage();
                    if (img != null)
                    {
                        img.Save(outputPath, ImageFormat.Png);
                    }
                }
                catch { }
            }
        }

        private string MakeValidFolderName(string name)
        {
            char[] invalidChars = Path.GetInvalidFileNameChars();
            foreach (char c in invalidChars)
            {
                name = name.Replace(c, '_');
            }
            return name;
        }

        private bool RunPythonScript(string pptxFilePath, string outputExcel, Action<int, string> progressCallback)
        {
            try
            {
                progressCallback?.Invoke(45, "Looking for Python...");
                string pythonExe = FindPythonExecutable();

                if (string.IsNullOrEmpty(pythonExe))
                {
                    progressCallback?.Invoke(50, "Python not found");
                    return false;
                }

                string scriptPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "extract_tables.py");

                if (!File.Exists(scriptPath))
                {
                    progressCallback?.Invoke(50, $"Python script not found: extract_tables.py");
                    return false;
                }

                // Create a temporary folder with just this one file
                string tempFolder = Path.Combine(Path.GetTempPath(), "TempWI_" + Guid.NewGuid().ToString());
                Directory.CreateDirectory(tempFolder);

                string tempFilePath = Path.Combine(tempFolder, Path.GetFileName(pptxFilePath));
                File.Copy(pptxFilePath, tempFilePath, true);

                string tempScript = CreateTempPythonScript(tempFolder, outputExcel, scriptPath);

                progressCallback?.Invoke(50, "Running Python script...");

                ProcessStartInfo start = new ProcessStartInfo();
                start.FileName = pythonExe;
                start.Arguments = $"\"{tempScript}\"";
                start.UseShellExecute = false;
                start.RedirectStandardOutput = true;
                start.RedirectStandardError = true;
                start.CreateNoWindow = true;

                using (Process process = Process.Start(start))
                {
                    string output = process.StandardOutput.ReadToEnd();
                    string errors = process.StandardError.ReadToEnd();

                    process.WaitForExit();

                    if (!string.IsNullOrEmpty(errors))
                    {
                        progressCallback?.Invoke(55, $"Python errors: {errors}");
                    }

                    // Clean up temp files
                    try
                    {
                        File.Delete(tempScript);
                        File.Delete(tempFilePath);
                        Directory.Delete(tempFolder);
                    }
                    catch { }

                    return process.ExitCode == 0 && File.Exists(outputExcel);
                }
            }
            catch (Exception ex)
            {
                progressCallback?.Invoke(50, $"Error running Python: {ex.Message}");
                return false;
            }
        }

        private string FindPythonExecutable()
        {
            string[] possiblePaths = new string[]
            {
        "python",
        "python3",
        @"C:\Python39\python.exe",
        @"C:\Python310\python.exe",
        @"C:\Python311\python.exe",
        @"C:\Python313\python.exe",
        @"C:\Users\" + Environment.UserName + @"\AppData\Local\Programs\Python\Python39\python.exe",
        @"C:\Users\" + Environment.UserName + @"\AppData\Local\Programs\Python\Python310\python.exe",
        @"C:\Users\" + Environment.UserName + @"\AppData\Local\Programs\Python\Python311\python.exe",
        @"C:\Users\" + Environment.UserName + @"\AppData\Local\Programs\Python\Python313\python.exe"
            };

            foreach (string path in possiblePaths)
            {
                try
                {
                    ProcessStartInfo psi = new ProcessStartInfo();
                    psi.FileName = path;
                    psi.Arguments = "--version";
                    psi.UseShellExecute = false;
                    psi.RedirectStandardOutput = true;
                    psi.CreateNoWindow = true;

                    using (Process process = Process.Start(psi))
                    {
                        process.WaitForExit();
                        if (process.ExitCode == 0)
                        {
                            return path;
                        }
                    }
                }
                catch
                {
                    continue;
                }
            }

            return null;
        }

        private string CreateTempPythonScript(string inputFolder, string outputExcel, string originalScript)
        {
            string scriptContent = File.ReadAllText(originalScript);

            scriptContent = System.Text.RegularExpressions.Regex.Replace(
                scriptContent,
                @"input_folder = r"".*?""",
                $"input_folder = r\"{inputFolder}\""
            );

            scriptContent = System.Text.RegularExpressions.Regex.Replace(
                scriptContent,
                @"output_excel = r"".*?""",
                $"output_excel = r\"{outputExcel}\""
            );

            string tempScript = Path.Combine(Path.GetTempPath(), "temp_extract_tables.py");
            File.WriteAllText(tempScript, scriptContent);

            return tempScript;
        }

        private void MergeExcelFiles(string headerFile, string tablesFile, string outputFile)
        {
            using (var headerPackage = new ExcelPackage(new FileInfo(headerFile)))
            using (var tablesPackage = new ExcelPackage(new FileInfo(tablesFile)))
            using (var outputPackage = new ExcelPackage())
            {
                // Copy sheets from header file in correct order
                // Sheet 0: Header Data
                if (headerPackage.Workbook.Worksheets.Count > 0)
                {
                    var headerSheet = headerPackage.Workbook.Worksheets[0];
                    outputPackage.Workbook.Worksheets.Add("Header Data", headerSheet);
                }

                // Sheet 1: Images
                if (headerPackage.Workbook.Worksheets.Count > 1)
                {
                    var imagesSheet = headerPackage.Workbook.Worksheets[1];
                    outputPackage.Workbook.Worksheets.Add("Images", imagesSheet);
                }

                // Sheet 2: Table of Contents
                if (headerPackage.Workbook.Worksheets.Count > 2)
                {
                    var tocSheet = headerPackage.Workbook.Worksheets[2];
                    outputPackage.Workbook.Worksheets.Add("Table of Contents", tocSheet);
                }

                // Sheet 3: Text Content
                if (headerPackage.Workbook.Worksheets.Count > 3)
                {
                    var textSheet = headerPackage.Workbook.Worksheets[3];
                    outputPackage.Workbook.Worksheets.Add("Text Content", textSheet);
                }

                // Copy all sheets from tables file (BOM, Equipment, Parts, etc.)
                foreach (var sheet in tablesPackage.Workbook.Worksheets)
                {
                    outputPackage.Workbook.Worksheets.Add(sheet.Name, sheet);
                }

                FileInfo outputFileInfo = new FileInfo(outputFile);
                outputPackage.SaveAs(outputFileInfo);
            }
        }

        private void CollectTextBoxes(Microsoft.Office.Interop.PowerPoint.Shapes shapes, List<TextBoxInfo> textBoxes)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in shapes)
            {
                if (shape.Type == MsoShapeType.msoGroup)
                {
                    CollectTextBoxesFromGroup(shape.GroupItems, textBoxes);
                }
                else if (shape.HasTextFrame == MsoTriState.msoTrue)
                {
                    string text = shape.TextFrame.TextRange.Text.Trim();
                    if (!string.IsNullOrEmpty(text))
                    {
                        textBoxes.Add(new TextBoxInfo
                        {
                            Text = text,
                            Left = shape.Left,
                            Top = shape.Top,
                            Width = shape.Width,
                            Height = shape.Height
                        });
                    }
                }
            }
        }

        private void CollectTextBoxesFromGroup(Microsoft.Office.Interop.PowerPoint.GroupShapes groupShapes, List<TextBoxInfo> textBoxes)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in groupShapes)
            {
                if (shape.Type == MsoShapeType.msoGroup)
                {
                    CollectTextBoxesFromGroup(shape.GroupItems, textBoxes);
                }
                else if (shape.HasTextFrame == MsoTriState.msoTrue)
                {
                    string text = shape.TextFrame.TextRange.Text.Trim();
                    if (!string.IsNullOrEmpty(text))
                    {
                        textBoxes.Add(new TextBoxInfo
                        {
                            Text = text,
                            Left = shape.Left,
                            Top = shape.Top,
                            Width = shape.Width,
                            Height = shape.Height
                        });
                    }
                }
            }
        }

        private void ExtractData(List<TextBoxInfo> textBoxes, Dictionary<string, string> data, Presentation ppt)
        {
            foreach (var box in textBoxes)
            {
                string text = box.Text.Trim();
                string upperText = text.ToUpper();

                // Extract WI Number
                if (string.IsNullOrEmpty(GetValue(data, "WI_Number")))
                {
                    var wiMatch = System.Text.RegularExpressions.Regex.Match(text,
                        @"W\.?I\.?\s*-?\s*\d+",
                        System.Text.RegularExpressions.RegexOptions.IgnoreCase);

                    if (wiMatch.Success)
                    {
                        string wiNum = wiMatch.Value.Replace(" ", "").Replace(".", "");
                        if (!wiNum.Contains("-"))
                            wiNum = wiNum.Replace("WI", "WI-");
                        data["WI_Number"] = wiNum.ToUpper();
                    }
                }

                // Extract Title
                if (string.IsNullOrEmpty(GetValue(data, "WI_Title")))
                {
                    bool isLabel = upperText == "WORK INSTRUCTION TITLE" ||
                                  upperText == "WORK INSTRUCTION" ||
                                  upperText == "DESCRIPTION:" ||
                                  upperText.Contains("W.I. NUMBER") ||
                                  upperText.Contains("BOM") && upperText.Contains("DWG") ||
                                  upperText.Contains("OPS") && upperText.Contains("OPTIONAL") ||
                                  upperText.Contains("OPERATION NO") ||
                                  upperText == "PRODUCT LINE" ||
                                  upperText == "SUBJECT" ||
                                  upperText == "SUBJECT:" ||
                                  upperText == "PAGE" ||
                                  upperText == "REV" ||
                                  upperText.Contains("COMPANY") && upperText.Length > 20 ||
                                  upperText.Contains("FM-ME") ||
                                  upperText.Contains("TRAINING RECORD") ||
                                  upperText.Contains("REVISION HISTORY") ||
                                  upperText.Contains("NOTICE") ||
                                  upperText.Contains("STATEMENT") ||
                                  (text.EndsWith(":") && text.Length < 20);

                    if (isLabel) continue;

                    bool isRev17_19Title = (box.Left > 100 && box.Left < 110 && box.Top > 455 && box.Top < 470);
                    bool isRev15_16Title = (box.Left > 20 && box.Left < 80 && box.Top > 515 && box.Top < 525);

                    if ((isRev17_19Title || isRev15_16Title) && text.Length > 3 && text.Length < 100)
                    {
                        data["WI_Title"] = text;
                    }
                }

                // Extract Revision
                if (string.IsNullOrEmpty(GetValue(data, "Revision")))
                {
                    if (upperText == "REV" || upperText == "REV:" || upperText == "REVISION:")
                        continue;

                    bool isRev17_19Rev = (box.Left > 665 && box.Left < 680 && box.Top > 460 && box.Top < 470);
                    bool isRev15_16Rev = (box.Left > 595 && box.Left < 620 && box.Top > 555 && box.Top < 565);

                    if ((isRev17_19Rev || isRev15_16Rev) &&
                        text.Length >= 1 && text.Length <= 3 &&
                        System.Text.RegularExpressions.Regex.IsMatch(text, @"^[0-9]+$"))
                    {
                        data["Revision"] = text;
                    }
                }

                // Extract BOM/ASSY DWG NO
                if (string.IsNullOrEmpty(GetValue(data, "BOM_ASSY_DWG_NO")))
                {
                    if ((upperText.Contains("BOM") || upperText.Contains("ASSY") || upperText.Contains("DWG")) &&
                        upperText.Contains("NO"))
                        continue;

                    bool isRev17_19BOM = (box.Left > 0 && box.Left < 20 && box.Top > 498 && box.Top < 505);
                    bool isRev15_16BOM = (box.Left > 300 && box.Left < 315 && box.Top > 558 && box.Top < 565);

                    if ((isRev17_19BOM || isRev15_16BOM) &&
                        text.Length > 1 && text.Length < 50 &&
                        !text.StartsWith("WI-") && !text.StartsWith("W.I."))
                    {
                        data["BOM_ASSY_DWG_NO"] = text;
                    }
                }

                // Extract Operation Number
                if (string.IsNullOrEmpty(GetValue(data, "Operation_No")))
                {
                    if ((upperText.Contains("OPERATION") && upperText.Contains("NO")) ||
                        upperText == "OPS (OPTIONAL)" || upperText == "OPERATION NO.")
                        continue;

                    bool isRev17_19Ops = (box.Left > 140 && box.Left < 155 && box.Top > 498 && box.Top < 505);
                    bool isRev15_16Ops = (box.Left > 185 && box.Left < 195 && box.Top > 555 && box.Top < 565);

                    if ((isRev17_19Ops || isRev15_16Ops) && text.Length > 1 && text.Length < 40)
                    {
                        data["Operation_No"] = text;
                    }
                }

                // Extract Product Line
                if (string.IsNullOrEmpty(GetValue(data, "Product_Line")))
                {
                    if (upperText == "PRODUCT LINE")
                        continue;

                    bool isRev17_19PL = (box.Left > 210 && box.Left < 230 && box.Top > 498 && box.Top < 505);
                    bool isRev15_16PL = (box.Left > 460 && box.Left < 515 && box.Top > 555 && box.Top < 565);

                    if ((isRev17_19PL || isRev15_16PL) &&
                        text.Length >= 2 && text.Length < 30 &&
                        !upperText.Contains("PAGE") &&
                        System.Text.RegularExpressions.Regex.IsMatch(text, @"[A-Z0-9]"))
                    {
                        data["Product_Line"] = text;
                    }
                }

                // Extract Subject
                if (string.IsNullOrEmpty(GetValue(data, "Subject")))
                {
                    if (upperText == "SUBJECT" ||
                        upperText == "SUBJECT:" ||
                        upperText.Contains("COMPANY") ||
                        System.Text.RegularExpressions.Regex.IsMatch(text, @"^\<?#?\>?\s*OF\s*\d+$", System.Text.RegularExpressions.RegexOptions.IgnoreCase))
                        continue;

                    bool isRev15_16Subject = (box.Left > 420 && box.Left < 430 && box.Top > 520 && box.Top < 525);

                    bool isRev17_19Subject = (box.Top > 495 && box.Top < 510) &&
                                             (box.Left > 315 && box.Left < 640) &&
                                             (box.Height > 10 && box.Height < 30) &&
                                             (box.Width > 200 && box.Width < 400) &&
                                             text.Length > 2 &&
                                             text.Length < 60 &&
                                             text != GetValue(data, "WI_Number") &&
                                             text != GetValue(data, "WI_Title") &&
                                             text != GetValue(data, "Product_Line") &&
                                             text != GetValue(data, "Operation_No") &&
                                             text != GetValue(data, "BOM_ASSY_DWG_NO");

                    if (isRev15_16Subject || isRev17_19Subject)
                    {
                        data["Subject"] = text;
                    }
                }

                // Extract Template Revision
                if (upperText.Contains("FM-ME") || upperText.Contains("FM ME") || upperText.Contains("FMME"))
                {
                    var revMatch = System.Text.RegularExpressions.Regex.Match(text,
                        @"FM-?[\s]?ME-?\d+.*?rev\.?\s*(\d+)",
                        System.Text.RegularExpressions.RegexOptions.IgnoreCase);

                    if (revMatch.Success && revMatch.Groups.Count > 1)
                    {
                        data["RevisionType"] = revMatch.Groups[1].Value;
                    }
                }
            }
        }

        private string GetValue(Dictionary<string, string> dict, string key)
        {
            return dict.ContainsKey(key) ? dict[key] : "";
        }

        private void WriteToExcel(List<Dictionary<string, string>> headerData,
            List<Dictionary<string, string>> imageData,
            List<Dictionary<string, string>> textData,
            List<Dictionary<string, string>> tocData,
            string excelPath)
        {
            if (File.Exists(excelPath))
                File.Delete(excelPath);

            using (var package = new ExcelPackage())
            {
                // Header Data sheet
                var worksheet = package.Workbook.Worksheets.Add("Header Data");

                var headers = new string[] {
            "Document ID", "Source File Name", "WI Number", "WI Title", "Revision",
            "BOM/ASSY DWG NO", "Operation No", "Product Line", "Subject", "Revision Type",
            "Total Pages", "Total Images"
        };

                for (int i = 0; i < headers.Length; i++)
                {
                    worksheet.Cells[1, i + 1].Value = headers[i];
                }

                using (var range = worksheet.Cells[1, 1, 1, headers.Length])
                {
                    range.Style.Font.Bold = true;
                    range.Style.Fill.PatternType = OfficeOpenXml.Style.ExcelFillStyle.Solid;
                    range.Style.Fill.BackgroundColor.SetColor(System.Drawing.Color.LightGray);
                    range.Style.HorizontalAlignment = OfficeOpenXml.Style.ExcelHorizontalAlignment.Center;
                }

                int row = 2;
                foreach (var record in headerData)
                {
                    worksheet.Cells[row, 1].Value = GetValue(record, "DocumentID");
                    worksheet.Cells[row, 2].Value = GetValue(record, "SourceFileName");
                    worksheet.Cells[row, 3].Value = GetValue(record, "WI_Number");
                    worksheet.Cells[row, 4].Value = GetValue(record, "WI_Title");
                    worksheet.Cells[row, 5].Value = GetValue(record, "Revision");
                    worksheet.Cells[row, 6].Value = GetValue(record, "BOM_ASSY_DWG_NO");
                    worksheet.Cells[row, 7].Value = GetValue(record, "Operation_No");
                    worksheet.Cells[row, 8].Value = GetValue(record, "Product_Line");
                    worksheet.Cells[row, 9].Value = GetValue(record, "Subject");
                    worksheet.Cells[row, 10].Value = GetValue(record, "RevisionType");
                    worksheet.Cells[row, 11].Value = GetValue(record, "TotalPages");
                    worksheet.Cells[row, 12].Value = GetValue(record, "TotalImages");
                    row++;
                }

                worksheet.Cells[worksheet.Dimension.Address].AutoFitColumns();

                // Images sheet
                if (imageData.Count > 0)
                {
                    var imgWorksheet = package.Workbook.Worksheets.Add("Images");

                    var imgHeaders = new string[] {
                "Document ID", "WI Number", "Source File Name", "Slide Number", "Image Number",
                "Image Type", "Image File Name", "Image Path", "Is Grouped", "Width", "Height"
            };

                    for (int i = 0; i < imgHeaders.Length; i++)
                    {
                        imgWorksheet.Cells[1, i + 1].Value = imgHeaders[i];
                    }

                    using (var range = imgWorksheet.Cells[1, 1, 1, imgHeaders.Length])
                    {
                        range.Style.Font.Bold = true;
                        range.Style.Fill.PatternType = OfficeOpenXml.Style.ExcelFillStyle.Solid;
                        range.Style.Fill.BackgroundColor.SetColor(System.Drawing.Color.LightGray);
                        range.Style.HorizontalAlignment = OfficeOpenXml.Style.ExcelHorizontalAlignment.Center;
                    }

                    row = 2;
                    foreach (var img in imageData)
                    {
                        imgWorksheet.Cells[row, 1].Value = GetValue(img, "DocumentID");
                        imgWorksheet.Cells[row, 2].Value = GetValue(img, "WI_Number");
                        imgWorksheet.Cells[row, 3].Value = GetValue(img, "SourceFileName");
                        imgWorksheet.Cells[row, 4].Value = GetValue(img, "SlideNumber");
                        imgWorksheet.Cells[row, 5].Value = GetValue(img, "ImageNumber");
                        imgWorksheet.Cells[row, 6].Value = GetValue(img, "ImageType");
                        imgWorksheet.Cells[row, 7].Value = GetValue(img, "ImageFileName");
                        imgWorksheet.Cells[row, 8].Value = GetValue(img, "ImagePath");
                        imgWorksheet.Cells[row, 9].Value = GetValue(img, "IsGrouped");
                        imgWorksheet.Cells[row, 10].Value = GetValue(img, "Width");
                        imgWorksheet.Cells[row, 11].Value = GetValue(img, "Height");
                        row++;
                    }

                    imgWorksheet.Cells[imgWorksheet.Dimension.Address].AutoFitColumns();
                }

                // Table of Contents sheet
                if (tocData.Count > 0)
                {
                    var tocWorksheet = package.Workbook.Worksheets.Add("Table of Contents");

                    var tocHeaders = new string[] {
                "Document ID", "WI Number", "Source File Name", "Slide Number",
                "Slide Subject", "Slide Total"
            };

                    for (int i = 0; i < tocHeaders.Length; i++)
                    {
                        tocWorksheet.Cells[1, i + 1].Value = tocHeaders[i];
                    }

                    using (var range = tocWorksheet.Cells[1, 1, 1, tocHeaders.Length])
                    {
                        range.Style.Font.Bold = true;
                        range.Style.Fill.PatternType = OfficeOpenXml.Style.ExcelFillStyle.Solid;
                        range.Style.Fill.BackgroundColor.SetColor(System.Drawing.Color.LightGray);
                        range.Style.HorizontalAlignment = OfficeOpenXml.Style.ExcelHorizontalAlignment.Center;
                    }

                    row = 2;
                    foreach (var toc in tocData)
                    {
                        tocWorksheet.Cells[row, 1].Value = GetValue(toc, "DocumentID");
                        tocWorksheet.Cells[row, 2].Value = GetValue(toc, "WI_Number");
                        tocWorksheet.Cells[row, 3].Value = GetValue(toc, "SourceFileName");
                        tocWorksheet.Cells[row, 4].Value = GetValue(toc, "SlideNumber");
                        tocWorksheet.Cells[row, 5].Value = GetValue(toc, "SlideSubject");
                        tocWorksheet.Cells[row, 6].Value = GetValue(toc, "SlideTotal");
                        row++;
                    }

                    tocWorksheet.Cells[tocWorksheet.Dimension.Address].AutoFitColumns();
                }

                // Text Content sheet
                if (textData.Count > 0)
                {
                    var textWorksheet = package.Workbook.Worksheets.Add("Text Content");

                    var textHeaders = new string[] {
                "Document ID", "WI Number", "Source File Name", "Slide Number",
                "Slide Subject", "TextBox Number", "Text Content"
            };

                    for (int i = 0; i < textHeaders.Length; i++)
                    {
                        textWorksheet.Cells[1, i + 1].Value = textHeaders[i];
                    }

                    using (var range = textWorksheet.Cells[1, 1, 1, textHeaders.Length])
                    {
                        range.Style.Font.Bold = true;
                        range.Style.Fill.PatternType = OfficeOpenXml.Style.ExcelFillStyle.Solid;
                        range.Style.Fill.BackgroundColor.SetColor(System.Drawing.Color.LightGray);
                        range.Style.HorizontalAlignment = OfficeOpenXml.Style.ExcelHorizontalAlignment.Center;
                    }

                    row = 2;
                    foreach (var txt in textData)
                    {
                        textWorksheet.Cells[row, 1].Value = GetValue(txt, "DocumentID");
                        textWorksheet.Cells[row, 2].Value = GetValue(txt, "WI_Number");
                        textWorksheet.Cells[row, 3].Value = GetValue(txt, "SourceFileName");
                        textWorksheet.Cells[row, 4].Value = GetValue(txt, "SlideNumber");
                        textWorksheet.Cells[row, 5].Value = GetValue(txt, "SlideSubject");
                        textWorksheet.Cells[row, 6].Value = GetValue(txt, "TextBoxNumber");
                        textWorksheet.Cells[row, 7].Value = GetValue(txt, "TextContent");

                        textWorksheet.Cells[row, 7].Style.WrapText = true;

                        row++;
                    }

                    textWorksheet.Column(7).Width = 80;
                    textWorksheet.Cells[textWorksheet.Dimension.Address].AutoFitColumns();
                }

                FileInfo fileInfo = new FileInfo(excelPath);
                package.SaveAs(fileInfo);
            }
        }
    }

    // Helper classes
    public class ExtractionResult
    {
        public string ExcelPath { get; set; } = string.Empty;
        public string BaseImagesFolder { get; set; } = string.Empty;
        public string ComposedImagesFolder { get; set; } = string.Empty;
        public string WINumber { get; set; } = string.Empty;
    }

    public class TextBoxInfo
    {
        public string Text { get; set; } = string.Empty;
        public float Left { get; set; }
        public float Top { get; set; }
        public float Width { get; set; }
        public float Height { get; set; }
    }

}
---------------------------------
program.cs
using System;
using System.Windows.Forms;

namespace WorkInstructionExtractor
{
    static class Program
    {
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1());
        }
    }
}

--------------------------------------------

extract_tables.py
"""
Work Instruction PowerPoint Data Extractor
Extracts tables and images from PowerPoint files to Excel
"""

import os
from pptx import Presentation
import pandas as pd
from datetime import datetime
from openpyxl import load_workbook
from openpyxl.styles import Font, PatternFill, Alignment, numbers
import re
from PIL import Image
import io

def identify_revision_type(prs):
    """Identifies revision type from FM-ME-07 text box at bottom right"""
    if len(prs.slides) > 0:
        slide = prs.slides[0]
        
        # Look for FM-ME-07 text in all shapes (including grouped shapes)
        for shape in slide.shapes:
            if shape.has_text_frame:
                text = shape.text.lower()
                if 'fm-me-' in text or 'fm me' in text or 'fmme' in text:
                    # Check for revision numbers
                    if 'rev15' in text or 'rev16' in text or 'rev 15' in text or 'rev 16' in text:
                        return '15-16'
                    elif 'rev17' in text or 'rev18' in text or 'rev19' in text or 'rev 17' in text or 'rev 18' in text or 'rev 19' in text:
                        return '17-19'
    
    return 'Unknown'

def clean_cell_value(value):
    """Cleans cell values to remove illegal characters for Excel"""
    if not value or not isinstance(value, str):
        return value
    
    # Replace newlines with spaces
    value = value.replace('\n', ' ').replace('\r', ' ')
    
    # Replace tabs with spaces
    value = value.replace('\t', ' ')
    
    # Remove other control characters (ASCII 0-31 except tab, newline, carriage return)
    value = ''.join(char for char in value if ord(char) >= 32 or char in '\t\n\r')
    
    # Clean up multiple spaces
    value = ' '.join(value.split())
    
    return value.strip()

def parse_date(date_str):
    """Parses various date formats and returns MM/DD/YYYY format"""
    if not date_str or not isinstance(date_str, str):
        return ""
    
    date_str = date_str.strip()
    
    if not date_str or date_str == '':
        return ""
    
    # Common date patterns
    patterns = [
        r'(\d{1,2})/(\d{1,2})/(\d{4})',  # MM/DD/YYYY or M/D/YYYY
        r'(\d{1,2})/(\d{1,2})/(\d{2})',  # MM/DD/YY or M/D/YY
        r'(\d{4})-(\d{1,2})-(\d{1,2})',  # YYYY-MM-DD
        r'(\d{1,2})-(\d{1,2})-(\d{4})',  # MM-DD-YYYY or DD-MM-YYYY
    ]
    
    for pattern in patterns:
        match = re.search(pattern, date_str)
        if match:
            try:
                if len(match.groups()) == 3:
                    part1, part2, part3 = match.groups()
                    
                    # Handle YYYY-MM-DD format
                    if len(part1) == 4:
                        year = int(part1)
                        month = int(part2)
                        day = int(part3)
                    # Handle YY format
                    elif len(part3) == 2:
                        month = int(part1)
                        day = int(part2)
                        year = 2000 + int(part3)
                    # Handle MM/DD/YYYY or MM-DD-YYYY
                    else:
                        month = int(part1)
                        day = int(part2)
                        year = int(part3)
                    
                    # Validate and format
                    if 1 <= month <= 12 and 1 <= day <= 31 and 1900 <= year <= 2100:
                        return f"{month:02d}/{day:02d}/{year:04d}"
            except:
                pass
    
    return date_str  # Return original if can't parse

def find_table_by_header(slide, header_text):
    """Finds a table by looking for header text"""
    for shape in slide.shapes:
        if shape.has_table:
            table = shape.table
            # Check first row for header
            first_row_text = ' '.join([cell.text for cell in table.rows[0].cells])
            if header_text.upper() in first_row_text.upper():
                return table
    return None

def extract_bom_table(slide, doc_id):
    """Extracts BOM/Configuration table from slide"""
    bom_data = []
    
    print(f"    Searching for BOM table...")
    
    # Look for BOM/CONFIGURATION TABLE
    table = find_table_by_header(slide, 'BOM/CONFIGURATION TABLE')
    if not table:
        table = find_table_by_header(slide, 'BOM/CONFIGURATION')
    if not table:
        table = find_table_by_header(slide, 'CONFIGURATION TABLE')
    if not table:
        table = find_table_by_header(slide, 'BOM')
    if not table:
        table = find_table_by_header(slide, 'CONFIGURATION')
    
    if table:
        print(f"    Found BOM table with {len(table.rows)} rows")
        
        # Look for the actual column headers row (Part Number, Description)
        header_row_index = None
        for idx, row in enumerate(table.rows):
            row_text = ' '.join([cell.text for cell in row.cells]).upper()
            if 'PART NUMBER' in row_text or 'DESCRIPTION' in row_text:
                header_row_index = idx
                break
        
        if header_row_index is not None:
            # Extract data rows after the column header row
            data_row_count = 0
            for idx, row in enumerate(list(table.rows)[header_row_index + 1:], start=1):
                if len(row.cells) >= 2:
                    part_num = row.cells[0].text.strip()
                    description = row.cells[1].text.strip()
                    
                    # Only add if both part number and description have content
                    if part_num and description and len(part_num) > 0 and len(description) > 0:
                        bom_data.append({
                            'DocumentID': doc_id,
                            'PartNumber': clean_cell_value(part_num),
                            'Description': clean_cell_value(description),
                            'RowOrder': idx
                        })
                        data_row_count += 1
            
            print(f"    Extracted {data_row_count} BOM entries")
    else:
        print(f"    No BOM/CONFIGURATION table found")
    
    return bom_data

def get_merged_cell_value(table, row_idx, col_idx):
    """
    Gets the actual value from a cell, handling merged cells.
    If a cell is part of a merged region, returns the value from the top-left cell of that region.
    """
    try:
        cell = table.cell(row_idx, col_idx)
        # Try to get text from this cell
        text = cell.text_frame.text.strip()
        
        # If empty, it might be part of a merged cell - look upward for the value
        if not text:
            # Check cells above in the same column
            for check_row in range(row_idx - 1, -1, -1):
                try:
                    check_cell = table.cell(check_row, col_idx)
                    check_text = check_cell.text_frame.text.strip()
                    if check_text:
                        return check_text
                except:
                    pass
        
        return text
    except:
        return ""


def extract_equipment_and_parts(slide, doc_id):
    """Extracts Equipment Required and Parts Required tables from slide 2"""
    equipment_data = []
    parts_data = []
    
    print(f"    Searching for Equipment and Parts tables on slide 2...")
    
    # Look for Equipment Required table
    equipment_table = find_table_by_header(slide, 'EQUIPMENT REQUIRED')
    if not equipment_table:
        equipment_table = find_table_by_header(slide, 'Equipment Required')
    
    if equipment_table:
        print(f"    Found Equipment Required table with {len(equipment_table.rows)} rows")
        
        # Find header row
        header_row_index = None
        for idx, row in enumerate(equipment_table.rows):
            row_text = ' '.join([cell.text for cell in row.cells]).upper()
            if 'QTY' in row_text and ('PART NO' in row_text or 'DESCRIPTION' in row_text):
                header_row_index = idx
                print(f"    Header row found at index {idx}")
                break
        
        if header_row_index is not None:
            data_row_count = 0
            
            # Process each data row
            for row_idx, row in enumerate(list(equipment_table.rows)[header_row_index + 1:], start=header_row_index + 1):
                print(f"    Processing row {row_idx}, cells: {len(row.cells)}")
                
                if len(row.cells) < 3:
                    continue
                
                # Get cell values - handle merged cells by looking up for values
                cell0_text = get_merged_cell_value(equipment_table, row_idx, 0)  # Qty
                cell1_text = get_merged_cell_value(equipment_table, row_idx, 1)  # Part No
                cell2_text = clean_cell_value(row.cells[2].text.strip())  # Description
                
                # Clean the values
                cell0_text = clean_cell_value(cell0_text)
                cell1_text = clean_cell_value(cell1_text)
                
                print(f"      Cell 0 (Qty): '{cell0_text}' (merged-aware)")
                print(f"      Cell 1 (Part): '{cell1_text}' (merged-aware)")
                print(f"      Cell 2 (Desc): '{cell2_text}'")
                
                # Check if Description cell contains multiple items separated by semicolons or newlines
                descriptions = []
                if ';' in cell2_text:
                    descriptions = [d.strip() for d in cell2_text.split(';') if d.strip()]
                elif '\n' in cell2_text or '\r' in cell2_text:
                    descriptions = [d.strip() for d in cell2_text.replace('\r', '\n').split('\n') if d.strip()]
                else:
                    descriptions = [cell2_text] if cell2_text else []
                
                print(f"      Found {len(descriptions)} description(s)")
                
                # If we have multiple descriptions, repeat Qty and Part No for each
                if len(descriptions) > 1:
                    print(f"      MERGED CELL DETECTED - Creating {len(descriptions)} separate rows")
                    for desc in descriptions:
                        equipment_data.append({
                            'DocumentID': doc_id,
                            'Quantity': cell0_text,  # Repeat same Qty
                            'PartNumber': cell1_text,  # Repeat same Part No
                            'Description': desc,
                            'RowOrder': data_row_count + 1
                        })
                        data_row_count += 1
                        print(f"        Row {data_row_count}: Qty='{cell0_text}', Part='{cell1_text}', Desc='{desc}'")
                else:
                    # Normal single row - but still use merged-aware values
                    if cell0_text or cell1_text or (descriptions and descriptions[0]):
                        equipment_data.append({
                            'DocumentID': doc_id,
                            'Quantity': cell0_text,
                            'PartNumber': cell1_text,
                            'Description': descriptions[0] if descriptions else "",
                            'RowOrder': data_row_count + 1
                        })
                        data_row_count += 1
                        print(f"        Row {data_row_count}: Qty='{cell0_text}', Part='{cell1_text}', Desc='{descriptions[0] if descriptions else ''}'")
            
            print(f"    Extracted {data_row_count} equipment entries")
    else:
        print(f"    No Equipment Required table found")
    
    # Parts Required - same logic with merged cell handling
    parts_table = find_table_by_header(slide, 'PARTS REQUIRED')
    if not parts_table:
        parts_table = find_table_by_header(slide, 'Parts Required')
    
    if parts_table:
        print(f"    Found Parts Required table with {len(parts_table.rows)} rows")
        
        header_row_index = None
        for idx, row in enumerate(parts_table.rows):
            row_text = ' '.join([cell.text for cell in row.cells]).upper()
            if 'QTY' in row_text and ('PART NO' in row_text or 'DESCRIPTION' in row_text):
                header_row_index = idx
                break
        
        if header_row_index is not None:
            data_row_count = 0
            
            for row_idx, row in enumerate(list(parts_table.rows)[header_row_index + 1:], start=header_row_index + 1):
                if len(row.cells) < 3:
                    continue
                
                # Get cell values - handle merged cells
                cell0_text = get_merged_cell_value(parts_table, row_idx, 0)  # Qty
                cell1_text = get_merged_cell_value(parts_table, row_idx, 1)  # Part No
                cell2_text = clean_cell_value(row.cells[2].text.strip())  # Description
                
                # Clean the values
                cell0_text = clean_cell_value(cell0_text)
                cell1_text = clean_cell_value(cell1_text)
                
                # Handle multiple descriptions
                descriptions = []
                if ';' in cell2_text:
                    descriptions = [d.strip() for d in cell2_text.split(';') if d.strip()]
                elif '\n' in cell2_text or '\r' in cell2_text:
                    descriptions = [d.strip() for d in cell2_text.replace('\r', '\n').split('\n') if d.strip()]
                else:
                    descriptions = [cell2_text] if cell2_text else []
                
                if len(descriptions) > 1:
                    for desc in descriptions:
                        parts_data.append({
                            'DocumentID': doc_id,
                            'Quantity': cell0_text,  # Repeat same Qty
                            'PartNumber': cell1_text,  # Repeat same Part No
                            'Description': desc,
                            'RowOrder': data_row_count + 1
                        })
                        data_row_count += 1
                else:
                    if cell0_text or cell1_text or (descriptions and descriptions[0]):
                        parts_data.append({
                            'DocumentID': doc_id,
                            'Quantity': cell0_text,
                            'PartNumber': cell1_text,
                            'Description': descriptions[0] if descriptions else "",
                            'RowOrder': data_row_count + 1
                        })
                        data_row_count += 1
            
            print(f"    Extracted {data_row_count} parts entries")
    else:
        print(f"    No Parts Required table found")
    
    return equipment_data, parts_data

def extract_all_other_tables(prs, doc_id, known_table_headers):
    """
    Scans all slides for tables that aren't already identified.
    Creates a separate dataset for each unique table found.
    
    Args:
        prs: PowerPoint presentation object
        doc_id: Document ID
        known_table_headers: List of table headers we already extract (to skip them)
    
    Returns:
        Dictionary where keys are table names and values are lists of row data
    """
    all_tables = {}
    table_counter = 1
    
    print(f"\n  Scanning for additional tables across all slides...")
    
    for slide_idx in range(len(prs.slides)):
        slide = prs.slides[slide_idx]
        slide_num = slide_idx + 1
        
        for shape in slide.shapes:
            if shape.has_table:
                table = shape.table
                
                # Get first row to identify the table
                if len(table.rows) == 0:
                    continue
                
                first_row_text = ' '.join([cell.text for cell in table.rows[0].cells]).upper()
                
                # Skip if this is a known table we already process
                is_known = False
                for known_header in known_table_headers:
                    if known_header.upper() in first_row_text:
                        is_known = True
                        print(f"    Slide {slide_num}: Skipping known table '{known_header}'")
                        break
                
                if is_known:
                    continue
                
                # This is a new table!
                # Determine table name from first row or use generic name
                table_name = first_row_text[:50].strip() if first_row_text else f"Table_{table_counter}"
                
                # Make it a valid sheet name (Excel limit: 31 chars, no special chars)
                table_name = table_name.replace('/', '_').replace('\\', '_').replace('*', '_')
                table_name = table_name.replace('[', '_').replace(']', '_').replace(':', '_')
                table_name = table_name.replace('?', '_').replace('|', '_')
                table_name = table_name[:31]  # Excel sheet name limit
                
                # Make unique if duplicate
                original_name = table_name
                suffix = 1
                while table_name in all_tables:
                    table_name = f"{original_name[:27]}_{suffix}"
                    suffix += 1
                
                print(f"    Slide {slide_num}: Found new table - '{table_name}'")
                print(f"      Rows: {len(table.rows)}, Columns: {len(table.columns)}")
                
                # Extract all rows from this table
                table_data = []
                
                for row_idx in range(len(table.rows)):
                    row_data = {
                        'DocumentID': doc_id,
                        'SlideNumber': slide_num,
                        'RowNumber': row_idx + 1
                    }
                    
                    # Extract each cell in the row
                    for col_idx in range(len(table.columns)):
                        # Use merged-cell-aware extraction
                        cell_value = get_merged_cell_value(table, row_idx, col_idx)
                        cell_value = clean_cell_value(cell_value)
                        
                        # Column name: use first row as headers if it looks like headers,
                        # otherwise use generic Column1, Column2, etc.
                        if row_idx == 0:
                            col_name = f"Column{col_idx + 1}"
                        else:
                            # Try to use first row as header
                            try:
                                header_cell = table.rows[0].cells[col_idx].text.strip()
                                if header_cell and len(header_cell) < 50:
                                    col_name = header_cell.replace(' ', '_').replace('/', '_')
                                    # Make it Excel-friendly
                                    col_name = ''.join(c for c in col_name if c.isalnum() or c == '_')
                                    if not col_name:
                                        col_name = f"Column{col_idx + 1}"
                                else:
                                    col_name = f"Column{col_idx + 1}"
                            except:
                                col_name = f"Column{col_idx + 1}"
                        
                        row_data[col_name] = cell_value
                    
                    table_data.append(row_data)
                
                all_tables[table_name] = table_data
                print(f"      Extracted {len(table_data)} rows")
                
                table_counter += 1
    
    if all_tables:
        print(f"\n  Found {len(all_tables)} additional table(s)")
    else:
        print(f"\n  No additional tables found")
    
    return all_tables

def extract_revision_history(slide, doc_id):
    """Extracts Revision History table from slide"""
    rev_data = []
    
    table = find_table_by_header(slide, 'REVISION HISTORY')
    
    if table:
        # Skip first row (header) and get data
        for idx, row in enumerate(list(table.rows)[1:], start=1):
            if len(row.cells) >= 3:
                rev_num = row.cells[0].text.strip()
                rev_desc = row.cells[1].text.strip()
                rev_date = row.cells[2].text.strip()
                
                # Skip header row and empty rows
                if rev_num and 'Rev' not in rev_num and rev_num != '#' and 'Description' not in rev_desc:
                    # Format date
                    formatted_date = parse_date(rev_date)
                    
                    rev_data.append({
                        'DocumentID': doc_id,
                        'RevNumber': rev_num,
                        'ChangeDescription': rev_desc,
                        'ChangeDate': formatted_date,
                        'RowOrder': idx
                    })
    
    return rev_data

def extract_drafting_and_approvals(slide, doc_id):
    """Extracts both Drafting and Approvals from combined table"""
    drafting_data = []
    approvals_data = []
    
    for shape in slide.shapes:
        if shape.has_table:
            table = shape.table
            
            # Check if this table has both Drafting and Approvals
            all_text = ' '.join([cell.text for row in table.rows for cell in row.cells]).upper()
            
            if 'DRAFTING' in all_text and 'APPROVALS' in all_text:
                # This is the combined table
                in_approvals_section = False
                
                for row_idx, row in enumerate(table.rows):
                    if len(row.cells) >= 3:
                        first_cell = row.cells[0].text.strip()
                        
                        # Check if we've reached Approvals section
                        if 'Approvals' in first_cell:
                            in_approvals_section = True
                            continue
                        
                        # Skip header rows
                        if first_cell in ['Drafting', 'Signatures', 'Date']:
                            continue
                        
                        # Extract data
                        col1 = row.cells[0].text.strip()
                        col2 = row.cells[1].text.strip()
                        col3 = row.cells[2].text.strip()
                        
                        # Format date
                        formatted_date = parse_date(col3)
                        
                        if col1:  # Has data
                            if in_approvals_section:
                                # Approvals section
                                approvals_data.append({
                                    'DocumentID': doc_id,
                                    'Department': col1,
                                    'Signature': col2,
                                    'ApprovalDate': formatted_date
                                })
                            else:
                                # Drafting section
                                drafting_data.append({
                                    'DocumentID': doc_id,
                                    'Role': col1,
                                    'Signature': col2,
                                    'SignatureDate': formatted_date
                                })
                
                break
    
    return drafting_data, approvals_data

def format_excel_sheet(worksheet):
    """Formats Excel sheet with gray headers and auto-fit columns"""
    # Format header row
    gray_fill = PatternFill(start_color="D3D3D3", end_color="D3D3D3", fill_type="solid")
    bold_font = Font(bold=True)
    center_alignment = Alignment(horizontal="center")
    
    for cell in worksheet[1]:
        cell.fill = gray_fill
        cell.font = bold_font
        cell.alignment = center_alignment
    
    # Auto-fit columns
    for column in worksheet.columns:
        max_length = 0
        column_letter = column[0].column_letter
        
        for cell in column:
            try:
                if cell.value:
                    max_length = max(max_length, len(str(cell.value)))
            except:
                pass
        
        adjusted_width = min(max_length + 2, 50)  # Cap at 50 characters
        worksheet.column_dimensions[column_letter].width = adjusted_width

def process_powerpoint_files(folder_path, output_excel):
    """Main function to process PowerPoint files"""
    
    # Initialize data containers
    bom_data_all = []
    equipment_data_all = []
    parts_data_all = []
    rev_history_all = []
    drafting_all = []
    approvals_all = []
    other_tables_all = {}  # Dictionary to hold all other tables
    
    doc_id = 1
    
    # Define known table headers that we already extract
    known_table_headers = [
        'BOM/CONFIGURATION',
        'BOM',
        'CONFIGURATION',
        'EQUIPMENT REQUIRED',
        'PARTS REQUIRED',
        'REVISION HISTORY',
        'DRAFTING',
        'APPROVALS'
    ]
    
    # Process each PowerPoint file
    for filename in os.listdir(folder_path):
        if filename.endswith('.pptx') or filename.endswith('.ppt'):
            if filename.startswith('~$'):  # Skip temp files
                continue
            
            print(f"Processing: {filename}")
            
            filepath = os.path.join(folder_path, filename)
            
            try:
                prs = Presentation(filepath)
                
                # Identify revision type
                rev_type = identify_revision_type(prs)
                print(f"  Revision type: {rev_type}")
                
                # Get first slide
                if len(prs.slides) > 0:
                    first_slide = prs.slides[0]
                    
                    # Extract tables from first slide
                    bom_data_all.extend(extract_bom_table(first_slide, doc_id))
                    
                    rev_history_all.extend(extract_revision_history(first_slide, doc_id))
                    
                    # Extract drafting and approvals (from combined table)
                    drafting, approvals = extract_drafting_and_approvals(first_slide, doc_id)
                    drafting_all.extend(drafting)
                    approvals_all.extend(approvals)
                    
                    print(f"  Extracted from slide 1: {len(drafting)} drafting, {len(approvals)} approvals")
                
                # Get second slide for Equipment and Parts
                if len(prs.slides) > 1:
                    second_slide = prs.slides[1]
                    equipment, parts = extract_equipment_and_parts(second_slide, doc_id)
                    equipment_data_all.extend(equipment)
                    parts_data_all.extend(parts)
                    print(f"  Extracted from slide 2: {len(equipment)} equipment, {len(parts)} parts")
                
                # **NEW: Scan for all other tables across all slides**
                other_tables = extract_all_other_tables(prs, doc_id, known_table_headers)
                
                # Merge other tables data
                for table_name, table_data in other_tables.items():
                    if table_name not in other_tables_all:
                        other_tables_all[table_name] = []
                    other_tables_all[table_name].extend(table_data)
                
                doc_id += 1
                
            except Exception as e:
                print(f"  ERROR processing {filename}: {str(e)}")
                import traceback
                traceback.print_exc()
    
    # Create Excel file
    print(f"\nCreating Excel file: {output_excel}")
    
    with pd.ExcelWriter(output_excel, engine='openpyxl') as writer:
        # BOM sheet
        if bom_data_all:
            df_bom = pd.DataFrame(bom_data_all)
            df_bom.to_excel(writer, sheet_name='BOM', index=False)
        else:
            df_bom = pd.DataFrame(columns=['DocumentID', 'PartNumber', 'Description', 'RowOrder'])
            df_bom.to_excel(writer, sheet_name='BOM', index=False)
        
        # Equipment Required sheet
        if equipment_data_all:
            df_equipment = pd.DataFrame(equipment_data_all)
            df_equipment.to_excel(writer, sheet_name='EquipmentRequired', index=False)
        else:
            df_equipment = pd.DataFrame(columns=['DocumentID', 'Quantity', 'PartNumber', 'Description', 'RowOrder'])
            df_equipment.to_excel(writer, sheet_name='EquipmentRequired', index=False)
        
        # Parts Required sheet
        if parts_data_all:
            df_parts = pd.DataFrame(parts_data_all)
            df_parts.to_excel(writer, sheet_name='PartsRequired', index=False)
        else:
            df_parts = pd.DataFrame(columns=['DocumentID', 'Quantity', 'PartNumber', 'Description', 'RowOrder'])
            df_parts.to_excel(writer, sheet_name='PartsRequired', index=False)
        
        # Revision History sheet
        if rev_history_all:
            df_rev = pd.DataFrame(rev_history_all)
            df_rev.to_excel(writer, sheet_name='RevisionHistory', index=False)
        else:
            df_rev = pd.DataFrame(columns=['DocumentID', 'RevNumber', 'ChangeDescription', 'ChangeDate', 'RowOrder'])
            df_rev.to_excel(writer, sheet_name='RevisionHistory', index=False)
        
        # Drafting sheet
        if drafting_all:
            df_draft = pd.DataFrame(drafting_all)
            df_draft.to_excel(writer, sheet_name='Drafting', index=False)
        else:
            df_draft = pd.DataFrame(columns=['DocumentID', 'Role', 'Signature', 'SignatureDate'])
            df_draft.to_excel(writer, sheet_name='Drafting', index=False)
        
        # Approvals sheet
        if approvals_all:
            df_approve = pd.DataFrame(approvals_all)
            df_approve.to_excel(writer, sheet_name='Approvals', index=False)
        else:
            df_approve = pd.DataFrame(columns=['DocumentID', 'Department', 'Signature', 'ApprovalDate'])
            df_approve.to_excel(writer, sheet_name='Approvals', index=False)
        
        # **NEW: Add sheets for all other discovered tables**
        for table_name, table_data in other_tables_all.items():
            if table_data:
                df_other = pd.DataFrame(table_data)
                # Ensure sheet name is valid
                safe_sheet_name = table_name[:31]
                df_other.to_excel(writer, sheet_name=safe_sheet_name, index=False)
                print(f"  Created sheet: {safe_sheet_name} ({len(table_data)} rows)")
    
    # Apply formatting to all sheets
    print("Applying formatting...")
    workbook = load_workbook(output_excel)
    
    for sheet_name in workbook.sheetnames:
        worksheet = workbook[sheet_name]
        format_excel_sheet(worksheet)
    
    workbook.save(output_excel)
    
    print(f"\nExtraction complete!")
    print(f"Processed {doc_id - 1} documents")
    print(f"Total BOM entries: {len(bom_data_all)}")
    print(f"Total Equipment entries: {len(equipment_data_all)}")
    print(f"Total Parts entries: {len(parts_data_all)}")
    print(f"Total Revision History entries: {len(rev_history_all)}")
    print(f"Total Drafting entries: {len(drafting_all)}")
    print(f"Total Approval entries: {len(approvals_all)}")
    print(f"Total additional tables found: {len(other_tables_all)}")
    for table_name, table_data in other_tables_all.items():
        print(f"  - {table_name}: {len(table_data)} rows")
    print(f"Saved to: {output_excel}")

if __name__ == "__main__":
    # CONFIGURE THESE PATHS
    input_folder = r"C:\Users\U309011\Desktop\New folder"
    output_excel = r"C:\Users\U309011\Desktop\WorkInstructions_Extracted.xlsx"
    
    print("=" * 70)
    print("WORK INSTRUCTION POWERPOINT TABLE EXTRACTOR")
    print("=" * 70)
    print(f"Input folder: {input_folder}")
    print(f"Output Excel: {output_excel}")
    print("=" * 70)
    
    # Run extraction
    process_powerpoint_files(input_folder, output_excel)
    
    print("\n" + "=" * 70)
    print("DONE! Open the Excel file to review extracted data.")
    print("=" * 70)
-------------------------------------
workinstructionextractor.csproj

<Project Sdk="Microsoft.NET.Sdk">
	<PropertyGroup>
		<TargetFramework>net8.0-windows</TargetFramework>
		<UseWindowsForms>true</UseWindowsForms>
		<EnableComHosting>true</EnableComHosting>
		<EnableDefaultCompileItems>true</EnableDefaultCompileItems>
		<OutputType>WinExe</OutputType>
	</PropertyGroup>

	<ItemGroup>
		<COMReference Include="Microsoft.Office.Core">
			<WrapperTool>tlbimp</WrapperTool>
			<VersionMinor>8</VersionMinor>
			<VersionMajor>2</VersionMajor>
			<Guid>2df8d04c-5bfa-101b-bde5-00aa0044de52</Guid>
			<Lcid>0</Lcid>
			<Isolated>false</Isolated>
			<EmbedInteropTypes>true</EmbedInteropTypes>
		</COMReference>
		<COMReference Include="Microsoft.Office.Interop.PowerPoint">
			<WrapperTool>tlbimp</WrapperTool>
			<VersionMinor>12</VersionMinor>
			<VersionMajor>2</VersionMajor>
			<Guid>91493440-5a91-11cf-8700-00aa0060263b</Guid>
			<Lcid>0</Lcid>
			<Isolated>false</Isolated>
			<EmbedInteropTypes>true</EmbedInteropTypes>
		</COMReference>
	</ItemGroup>
	
<ItemGroup>
    <PackageReference Include="EPPlus" Version="8.2.1" />
  </ItemGroup>

  <ItemGroup>
    <None Update="extract_tables.py">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
  </ItemGroup>

</Project>
-------------------------------------------------------------
WorkInstructionlabeler.csproj

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0-windows</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <UseWPF>true</UseWPF>
  </PropertyGroup>

  <ItemGroup>
    <COMReference Include="Microsoft.Office.Core">
      <WrapperTool>tlbimp</WrapperTool>
      <VersionMinor>8</VersionMinor>
      <VersionMajor>2</VersionMajor>
      <Guid>2df8d04c-5bfa-101b-bde5-00aa0044de52</Guid>
      <Lcid>0</Lcid>
      <Isolated>false</Isolated>
      <EmbedInteropTypes>true</EmbedInteropTypes>
    </COMReference>
    <COMReference Include="Microsoft.Office.Interop.PowerPoint">
      <WrapperTool>tlbimp</WrapperTool>
      <VersionMinor>12</VersionMinor>
      <VersionMajor>2</VersionMajor>
      <Guid>91493440-5a91-11cf-8700-00aa0060263b</Guid>
      <Lcid>0</Lcid>
      <Isolated>false</Isolated>
      <EmbedInteropTypes>true</EmbedInteropTypes>
    </COMReference>
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="CsvHelper" Version="33.1.0" />
    <PackageReference Include="Microsoft.ML" Version="4.0.2" />
    <PackageReference Include="Ookii.Dialogs.Wpf" Version="5.0.1" />
  </ItemGroup>

</Project>
--------------------------------------------------
app.xaml

<Application x:Class="WorkInstructionLabeler.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:WorkInstructionLabeler"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
         
    </Application.Resources>
</Application>
_____________________________________________________
app.xaml.cs
using System.Configuration;
using System.Data;
using System.Windows;
using System;
using System.Globalization;
using System.Windows.Data;
using System.Windows.Media;

namespace WorkInstructionLabeler
{ 
    public partial class App : Application
    {
    }

    public class BoolToStatusConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool isCompleted)
            {
                return isCompleted ? "Completed" : "In Progress";
            }
            return "Unknown";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    public class BoolToColorConverter : IMultiValueConverter
    {
        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
        {
            if (values[0] is bool isCompleted)
            {
                return isCompleted
                    ? new SolidColorBrush(Color.FromRgb(76, 175, 80))  // Green
                    : new SolidColorBrush(Color.FromRgb(255, 152, 0)); // Orange
            }
            return new SolidColorBrush(Colors.Gray);
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}
-----------------------------------------------
mainwindow.xaml.cs

using CsvHelper;
using Microsoft.Office.Core;
using Microsoft.Office.Interop.PowerPoint;
using Microsoft.Win32;
using Ookii.Dialogs.Wpf;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Shapes;

namespace WorkInstructionLabeler
{
    public partial class MainWindow : Window
    {
        private List<PowerPointFileInfo> _powerPointFiles = new List<PowerPointFileInfo>();
        private PowerPointFileInfo _currentFile;
        private int _currentSlideIndex = 0;
        private List<LabeledTextBox> _allLabeledBoxes = new List<LabeledTextBox>();
        private LabeledTextBox _selectedTextBox;
        private Dictionary<Border, LabeledTextBox> _borderToTextBoxMap = new Dictionary<Border, LabeledTextBox>();
        private double _zoomLevel = 1.0;

        public MainWindow()
        {
            InitializeComponent();
        }

        private void BtnLoadFolder_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new VistaFolderBrowserDialog
            {
                Description = "Select folder containing PowerPoint work instructions",
                UseDescriptionForTitle = true
            };

            if (dialog.ShowDialog(this) == true)
            {
                LoadPowerPointFiles(dialog.SelectedPath);
            }
        }

        private void LoadPowerPointFiles(string folderPath)
        {
            _powerPointFiles.Clear();
            lstFiles.Items.Clear();

            var files = Directory.GetFiles(folderPath, "*.pptx")
                .Where(f => !System.IO.Path.GetFileName(f).StartsWith("~$"))
                .ToList();

            foreach (var file in files)
            {
                var fileInfo = new PowerPointFileInfo
                {
                    FilePath = file,
                    FileName = System.IO.Path.GetFileName(file),
                    IsLabeled = false,
                    IsCompleted = false
                };

                _powerPointFiles.Add(fileInfo);
                lstFiles.Items.Add(fileInfo);
            }

            UpdateProgress();

            if (_powerPointFiles.Count > 0)
            {
                lstFiles.SelectedIndex = 0;
            }
        }

        private void LstFiles_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (e.RemovedItems.Count > 0 && e.RemovedItems[0] is PowerPointFileInfo previousFile)
            {
                if (!previousFile.IsCompleted)
                {
                    var missingLabels = CheckRequiredLabels();

                    if (missingLabels.Count > 0)
                    {
                        var result = MessageBox.Show(
                            $"You haven't completed labeling the previous file:\n{previousFile.FileName}\n\n" +
                            $"Missing:\n{string.Join("\n", missingLabels)}\n\n" +
                            "Do you want to continue to the next file without completing it?",
                            "Incomplete File",
                            MessageBoxButton.YesNo,
                            MessageBoxImage.Warning);

                        if (result == MessageBoxResult.No)
                        {
                            lstFiles.SelectionChanged -= LstFiles_SelectionChanged;
                            lstFiles.SelectedItem = previousFile;
                            lstFiles.SelectionChanged += LstFiles_SelectionChanged;
                            return;
                        }
                    }
                }
            }

            if (lstFiles.SelectedItem is PowerPointFileInfo fileInfo)
            {
                LoadPowerPointFile(fileInfo);
            }
        }

        private void LoadPowerPointFile(PowerPointFileInfo fileInfo)
        {
            _currentFile = fileInfo;
            _currentSlideIndex = 0;

            txtFileName.Text = fileInfo.FileName;

            ExtractTextBoxesFromPowerPoint(fileInfo.FilePath);

            DisplaySlide(_currentSlideIndex);
        }

        private void ExtractTextBoxesFromPowerPoint(string filePath)
        {
            var pptApp = new Microsoft.Office.Interop.PowerPoint.Application();

            try
            {
                Presentation ppt = pptApp.Presentations.Open(filePath,
                    MsoTriState.msoFalse, MsoTriState.msoFalse, MsoTriState.msoFalse);

                string revType = DetectRevisionType(ppt);

                if (revType == "Unknown")
                {
                    txtRevType.Text = "Template: Unknown";
                    txtRevType.Foreground = new SolidColorBrush(Colors.Orange);
                }
                else
                {
                    txtRevType.Text = $"Template: Rev {revType}";
                    txtRevType.Foreground = new SolidColorBrush(Color.FromRgb(76, 175, 80));
                }

                _allLabeledBoxes.RemoveAll(b => b.SourceFile == filePath);

                _currentFile.TotalSlides = ppt.Slides.Count;

                Console.WriteLine($"\n=== Extracting text boxes from {System.IO.Path.GetFileName(filePath)} ===");
                Console.WriteLine($"Total slides: {ppt.Slides.Count}");

                for (int i = 1; i <= ppt.Slides.Count; i++)
                {
                    Slide slide = ppt.Slides[i];
                    var textBoxes = new List<TextBoxInfo>();

                    Console.WriteLine($"\n--- Slide {i} ---");

                    CollectTextBoxes(slide.Shapes, textBoxes, "Slide");
                    try { CollectTextBoxes(slide.Master.Shapes, textBoxes, "Master"); } catch { }
                    try { CollectTextBoxes(slide.Design.SlideMaster.Shapes, textBoxes, "Design"); } catch { }
                    try { CollectTextBoxes(slide.CustomLayout.Shapes, textBoxes, "CustomLayout"); } catch { }

                    Console.WriteLine($"Slide {i}: Collected {textBoxes.Count} text boxes");

                    var uniqueBoxes = textBoxes
                        .GroupBy(b => new { b.Text, Left = Math.Round(b.Left, 1), Top = Math.Round(b.Top, 1) })
                        .Select(g => g.First())
                        .ToList();

                    Console.WriteLine($"Slide {i}: After deduplication: {uniqueBoxes.Count} unique text boxes");

                    string slideType = _currentFile.SlideTypes.ContainsKey(i)
                        ? _currentFile.SlideTypes[i]
                        : "";

                    foreach (var box in uniqueBoxes)
                    {
                        if (string.IsNullOrWhiteSpace(box.Text))
                            continue;

                        _allLabeledBoxes.Add(new LabeledTextBox
                        {
                            Text = box.Text,
                            Left = box.Left,
                            Top = box.Top,
                            Width = box.Width,
                            Height = box.Height,
                            RevisionType = revType,
                            SourceFile = filePath,
                            SlideNumber = i,
                            AssignedLabel = null,
                            IsHidden = false,
                            SlideType = slideType
                        });
                    }
                }

                txtSlideInfo.Text = $"Slide 1 of {ppt.Slides.Count}";
                UpdateSlideTypeDisplay();

                ppt.Close();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error loading PowerPoint:\n{ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                pptApp.Quit();
            }
        }

        private string DetectRevisionType(Presentation ppt)
        {
            if (ppt.Slides.Count > 0)
            {
                Slide slide = ppt.Slides[1];
                var candidateBoxes = new List<(string text, float left, float top)>();

                void CollectCandidates(Microsoft.Office.Interop.PowerPoint.Shapes shapes, string source)
                {
                    foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in shapes)
                    {
                        try
                        {
                            if (shape.Type == MsoShapeType.msoGroup)
                            {
                                try
                                {
                                    CollectCandidatesFromGroup(shape.GroupItems, source + "-Group");
                                }
                                catch { }
                            }
                            else if (shape.HasTextFrame == MsoTriState.msoTrue)
                            {
                                try
                                {
                                    string text = shape.TextFrame.TextRange.Text.Trim();
                                    if (!string.IsNullOrEmpty(text))
                                    {
                                        candidateBoxes.Add((text, shape.Left, shape.Top));
                                    }
                                }
                                catch { }
                            }
                        }
                        catch { }
                    }
                }

                void CollectCandidatesFromGroup(Microsoft.Office.Interop.PowerPoint.GroupShapes groupShapes, string source)
                {
                    foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in groupShapes)
                    {
                        try
                        {
                            if (shape.Type == MsoShapeType.msoGroup)
                            {
                                try
                                {
                                    CollectCandidatesFromGroup(shape.GroupItems, source + "-Group");
                                }
                                catch { }
                            }
                            else if (shape.HasTextFrame == MsoTriState.msoTrue)
                            {
                                try
                                {
                                    string text = shape.TextFrame.TextRange.Text.Trim();
                                    if (!string.IsNullOrEmpty(text))
                                    {
                                        candidateBoxes.Add((text, shape.Left, shape.Top));
                                    }
                                }
                                catch { }
                            }
                        }
                        catch { }
                    }
                }

                Console.WriteLine("\n=== Searching for Template Revision ===");

                try { CollectCandidates(slide.Shapes, "Slide"); } catch { }
                try { CollectCandidates(slide.Master.Shapes, "Master"); } catch { }
                try { CollectCandidates(slide.Design.SlideMaster.Shapes, "Design"); } catch { }
                try { CollectCandidates(slide.CustomLayout.Shapes, "CustomLayout"); } catch { }

                Console.WriteLine($"\nTotal text boxes found: {candidateBoxes.Count}");

                var bottomRightBoxes = candidateBoxes
                    .Where(b => b.left > 300 && b.top > 450)
                    .OrderByDescending(b => b.left)
                    .ThenByDescending(b => b.top)
                    .ToList();

                var fmmePatterns = new[]
                {
                    @"fm[-_\s]*me[-_\s]*\d+",
                    @"fm[-_\s]*\d+",
                    @"fmme",
                };

                var revPatterns = new[]
                {
                    @"rev\.?\s*(\d+)",
                    @"revision\s*(\d+)",
                    @"r\.?\s*(\d+)",
                    @"-(\d+)$",
                    @"\b(\d{2})\b",
                };

                foreach (var box in bottomRightBoxes)
                {
                    string text = box.text.ToLower();
                    bool hasFMME = fmmePatterns.Any(p => Regex.IsMatch(text, p, RegexOptions.IgnoreCase));


                    if (hasFMME)
                    {
                        foreach (var pattern in revPatterns)
                        {
                            var match = Regex.Match(text, pattern, RegexOptions.IgnoreCase);
                            if (match.Success && match.Groups.Count > 1)
                            {
                                string revNum = match.Groups[1].Value;
                                if (int.TryParse(revNum, out int num) && num >= 10 && num <= 30)
                                {
                                    return revNum;
                                }
                            }
                        }
                    }
                }
            }

            return "Unknown";
        }

        private void CollectTextBoxes(Microsoft.Office.Interop.PowerPoint.Shapes shapes,
            List<TextBoxInfo> textBoxes, string source = "Unknown")
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in shapes)
            {
                try
                {
                    if (shape.Type == MsoShapeType.msoGroup)
                    {
                        CollectTextBoxesFromGroup(shape.GroupItems, textBoxes, source);
                    }
                    else if (shape.HasTextFrame == MsoTriState.msoTrue)
                    {
                        try
                        {
                            string text = shape.TextFrame.TextRange.Text.Trim();
                            if (!string.IsNullOrEmpty(text))
                            {
                                textBoxes.Add(new TextBoxInfo
                                {
                                    Text = text,
                                    Left = shape.Left,
                                    Top = shape.Top,
                                    Width = shape.Width,
                                    Height = shape.Height
                                });
                            }
                        }
                        catch { }
                    }
                }
                catch { }
            }
        }

        private void CollectTextBoxesFromGroup(Microsoft.Office.Interop.PowerPoint.GroupShapes groupShapes,
            List<TextBoxInfo> textBoxes, string source = "Unknown")
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in groupShapes)
            {
                try
                {
                    if (shape.Type == MsoShapeType.msoGroup)
                    {
                        CollectTextBoxesFromGroup(shape.GroupItems, textBoxes, source);
                    }
                    else if (shape.HasTextFrame == MsoTriState.msoTrue)
                    {
                        try
                        {
                            string text = shape.TextFrame.TextRange.Text.Trim();
                            if (!string.IsNullOrEmpty(text))
                            {
                                textBoxes.Add(new TextBoxInfo
                                {
                                    Text = text,
                                    Left = shape.Left,
                                    Top = shape.Top,
                                    Width = shape.Width,
                                    Height = shape.Height
                                });
                            }
                        }
                        catch { }
                    }
                }
                catch { }
            }
        }

        private bool IsLabel(string upperText)
        {
            var labels = new[] {
            "WORK INSTRUCTION TITLE", "WORK INSTRUCTION", "DESCRIPTION", "DESCRIPTION:",
            "W.I. NUMBER", "WI NUMBER", "BOM/ASSY DWG NO", "BOM DWG NO", "ASSY DWG NO",
            "OPS (OPTIONAL)", "OPERATION NO", "OPERATION NO.", "PRODUCT LINE",
            "SUBJECT", "SUBJECT:", "PAGE", "REV", "REV:", "REVISION", "REVISION:"
        };

            return labels.Any(label => upperText == label || (upperText.Contains(label) && upperText.Length < 40)) ||
                   (upperText.EndsWith(":") && upperText.Length < 25);
        }

        private void DisplaySlide(int slideIndex)
        {
            slideCanvas.Children.Clear();
            _borderToTextBoxMap.Clear();

            var slideBoxes = _allLabeledBoxes
                .Where(b => b.SourceFile == _currentFile.FilePath &&
                            b.SlideNumber == slideIndex + 1 &&
                            !b.IsHidden)
                .ToList();

            Console.WriteLine($"\nDisplaying Slide {slideIndex + 1}: {slideBoxes.Count} text boxes");

            float scaleFactor = 1.0f;

            foreach (var box in slideBoxes)
            {
                var border = new Border
                {
                    Width = Math.Max(box.Width * scaleFactor, 50),
                    Height = Math.Max(box.Height * scaleFactor, 20),
                    Cursor = System.Windows.Input.Cursors.Hand,
                    ToolTip = box.Text
                };

                if (slideIndex == 0)
                {
                    border.Style = GetStyleForLabel(box.AssignedLabel);
                }
                else
                {
                    border.Style = (Style)FindResource("UnlabeledBox");
                }

                var textBlock = new TextBlock
                {
                    Text = box.Text,
                    TextWrapping = TextWrapping.Wrap,
                    Padding = new Thickness(3),
                    FontSize = 9,
                    TextTrimming = TextTrimming.CharacterEllipsis,
                    VerticalAlignment = VerticalAlignment.Center
                };

                border.Child = textBlock;

                Canvas.SetLeft(border, box.Left * scaleFactor);
                Canvas.SetTop(border, box.Top * scaleFactor);

                border.MouseDown += (s, e) =>
                {
                    if (slideIndex == 0)
                    {
                        SelectTextBox(box, border);
                    }
                };

                slideCanvas.Children.Add(border);
                _borderToTextBoxMap[border] = box;
            }

            UpdateSlideTypeDisplay();
        }

        private Style GetStyleForLabel(string label)
        {
            if (string.IsNullOrEmpty(label))
                return (Style)FindResource("UnlabeledBox");

            return label switch
            {
                "WI_Number" => (Style)FindResource("WINumberBox"),
                "WI_Title" => (Style)FindResource("TitleBox"),
                "Revision" => (Style)FindResource("RevisionBox"),
                "BOM_ASSY_DWG_NO" => (Style)FindResource("BOMBox"),
                "Operation_No" => (Style)FindResource("OperationBox"),
                "Product_Line" => (Style)FindResource("ProductLineBox"),
                "Subject" => (Style)FindResource("SubjectBox"),
                "Template_Revision" => (Style)FindResource("TemplateRevisionBox"),
                _ => (Style)FindResource("UnlabeledBox")
            };
        }

        private void SelectTextBox(LabeledTextBox box, Border border)
        {
            _selectedTextBox = box;

            foreach (var kvp in _borderToTextBoxMap)
            {
                if (kvp.Value == box)
                    kvp.Key.BorderThickness = new Thickness(4);
                else
                    kvp.Key.BorderThickness = new Thickness(2);
            }

            txtSelectedText.Text = box.Text;
            txtPosition.Text = $"Left: {box.Left:F1}, Top: {box.Top:F1}, W: {box.Width:F1}, H: {box.Height:F1}";
        }

        private void BtnSlideType_Click(object sender, RoutedEventArgs e)
        {
            if (_currentFile == null)
            {
                MessageBox.Show("Please load a file first", "No File",
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            var button = sender as Button;
            string slideType = button.Tag.ToString();

            _currentFile.SlideTypes[_currentSlideIndex + 1] = slideType;

            foreach (var box in _allLabeledBoxes.Where(b =>
                b.SourceFile == _currentFile.FilePath &&
                b.SlideNumber == _currentSlideIndex + 1))
            {
                box.SlideType = slideType;
            }

            _currentFile.IsLabeled = true;

            UpdateSlideTypeDisplay();

            Console.WriteLine($"Slide {_currentSlideIndex + 1} classified as: {slideType}");

            if (_currentSlideIndex < _currentFile.TotalSlides - 1)
            {
                _currentSlideIndex++;
                DisplaySlide(_currentSlideIndex);
                txtSlideInfo.Text = $"Slide {_currentSlideIndex + 1} of {_currentFile.TotalSlides}";
            }
            else
            {
                MessageBox.Show("All slides classified! You can now move to text box labeling on Slide 1, or mark this file as complete.",
                    "Slides Complete", MessageBoxButton.OK, MessageBoxImage.Information);
            }
        }

        private void UpdateSlideTypeDisplay()
        {
            if (_currentFile == null)
            {
                txtCurrentSlideType.Text = "No file loaded";
                txtCurrentSlideType.Foreground = new SolidColorBrush(Colors.Gray);
                return;
            }

            int currentSlide = _currentSlideIndex + 1;

            if (_currentFile.SlideTypes.ContainsKey(currentSlide))
            {
                string slideType = _currentFile.SlideTypes[currentSlide];
                txtCurrentSlideType.Text = $"Slide {currentSlide}: {slideType}";
                txtCurrentSlideType.Foreground = new SolidColorBrush(Color.FromRgb(76, 175, 80));
            }
            else
            {
                txtCurrentSlideType.Text = $"Slide {currentSlide}: Not classified";
                txtCurrentSlideType.Foreground = new SolidColorBrush(Colors.Orange);
            }
        }

        private void BtnLabel_Click(object sender, RoutedEventArgs e)
        {
            if (_currentSlideIndex != 0)
            {
                MessageBox.Show("Text box labeling only works on Slide 1 (Title Page)",
                    "Wrong Slide", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            if (_selectedTextBox == null)
            {
                MessageBox.Show("Please select a text box first", "No Selection",
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            var button = sender as Button;
            string label = button.Tag.ToString();

            _selectedTextBox.AssignedLabel = label;

            DisplaySlide(_currentSlideIndex);

            _currentFile.IsLabeled = true;

            CaptureExtractedValue(label, _selectedTextBox.Text);

            UpdateProgress();
        }

        private void CaptureExtractedValue(string label, string value)
        {
            if (_currentFile == null) return;

            switch (label)
            {
                case "WI_Number":
                    _currentFile.ExtractedWINumber = value;
                    break;
                case "WI_Title":
                    _currentFile.ExtractedTitle = value;
                    break;
                case "Revision":
                    _currentFile.ExtractedRevision = value;
                    break;
                case "BOM_ASSY_DWG_NO":
                    _currentFile.ExtractedBOM = value;
                    break;
                case "Operation_No":
                    _currentFile.ExtractedOperationNo = value;
                    break;
                case "Product_Line":
                    _currentFile.ExtractedProductLine = value;
                    break;
                case "Subject":
                    _currentFile.ExtractedSubject = value;
                    break;
                case "Page_No":
                    _currentFile.ExtractedPageNo = ParsePageNumber(value);
                    break;
                case "Template_Revision":
                    _currentFile.ExtractedTemplateRev = ParseTemplateRevision(value);
                    break;
            }

            Console.WriteLine($"Captured: {label} = '{value}'");
        }

        private string ParseTemplateRevision(string templateText)
        {
            if (string.IsNullOrWhiteSpace(templateText))
                return "";

            var revMatch = Regex.Match(templateText,
                @"fm[-_\s]*me[-_\s]*\d+\s*rev\.?\s*(\d+)",
                RegexOptions.IgnoreCase);

            if (revMatch.Success && revMatch.Groups.Count > 1)
            {
                return revMatch.Groups[1].Value;
            }

            revMatch = Regex.Match(templateText, @"rev\.?\s*(\d{1,2})", RegexOptions.IgnoreCase);
            if (revMatch.Success && revMatch.Groups.Count > 1)
            {
                return revMatch.Groups[1].Value;
            }

            revMatch = Regex.Match(templateText, @"\b(\d{2})\b");
            if (revMatch.Success)
            {
                return revMatch.Groups[1].Value;
            }

            return templateText;
        }

        private string ParsePageNumber(string pageText)
        {
            if (string.IsNullOrWhiteSpace(pageText))
                return "";

            var match = Regex.Match(pageText, @"page\s*(\d+)", RegexOptions.IgnoreCase);
            if (match.Success)
                return match.Groups[1].Value;

            match = Regex.Match(pageText, @"(\d+)\s*(?:of|/)\s*\d+", RegexOptions.IgnoreCase);
            if (match.Success)
                return match.Groups[1].Value;

            return pageText;
        }

        private void BtnClearLabel_Click(object sender, RoutedEventArgs e)
        {
            if (_selectedTextBox == null) return;

            string previousLabel = _selectedTextBox.AssignedLabel;
            _selectedTextBox.AssignedLabel = null;

            if (!string.IsNullOrEmpty(previousLabel))
            {
                ClearExtractedValue(previousLabel);
            }

            DisplaySlide(_currentSlideIndex);
        }

        private void ClearExtractedValue(string label)
        {
            if (_currentFile == null) return;

            switch (label)
            {
                case "WI_Number":
                    _currentFile.ExtractedWINumber = null;
                    break;
                case "WI_Title":
                    _currentFile.ExtractedTitle = null;
                    break;
                case "Revision":
                    _currentFile.ExtractedRevision = null;
                    break;
                case "BOM_ASSY_DWG_NO":
                    _currentFile.ExtractedBOM = null;
                    break;
                case "Operation_No":
                    _currentFile.ExtractedOperationNo = null;
                    break;
                case "Product_Line":
                    _currentFile.ExtractedProductLine = null;
                    break;
                case "Subject":
                    _currentFile.ExtractedSubject = null;
                    break;
                case "Page_No":
                    _currentFile.ExtractedPageNo = null;
                    break;
                case "Template_Revision":
                    _currentFile.ExtractedTemplateRev = null;
                    break;
            }
        }

        private void BtnHideBox_Click(object sender, RoutedEventArgs e)
        {
            if (_selectedTextBox == null)
            {
                MessageBox.Show("Please select a text box first", "No Selection",
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            _selectedTextBox.IsHidden = true;

            DisplaySlide(_currentSlideIndex);

            _selectedTextBox = null;
            txtSelectedText.Text = "Text box hidden";
            txtPosition.Text = "";
        }

        private void BtnPrevSlide_Click(object sender, RoutedEventArgs e)
        {
            if (_currentSlideIndex > 0)
            {
                _currentSlideIndex--;
                DisplaySlide(_currentSlideIndex);
                txtSlideInfo.Text = $"Slide {_currentSlideIndex + 1} of {_currentFile.TotalSlides}";
                UpdateSlideTypeDisplay();
            }
        }

        private void BtnNextSlide_Click(object sender, RoutedEventArgs e)
        {
            if (_currentFile != null && _currentSlideIndex < _currentFile.TotalSlides - 1)
            {
                _currentSlideIndex++;
                DisplaySlide(_currentSlideIndex);
                txtSlideInfo.Text = $"Slide {_currentSlideIndex + 1} of {_currentFile.TotalSlides}";
                UpdateSlideTypeDisplay();
            }
            else
            {
                MessageBox.Show("This is the last slide", "End of Presentation",
                    MessageBoxButton.OK, MessageBoxImage.Information);
            }
        }

        private void BtnZoomIn_Click(object sender, RoutedEventArgs e)
        {
            _zoomLevel = Math.Min(_zoomLevel + 0.25, 3.0);
            ApplyZoom();
        }

        private void BtnZoomOut_Click(object sender, RoutedEventArgs e)
        {
            _zoomLevel = Math.Max(_zoomLevel - 0.25, 0.5);
            ApplyZoom();
        }

        private void BtnZoomFit_Click(object sender, RoutedEventArgs e)
        {
            _zoomLevel = 1.0;
            ApplyZoom();
        }

        private void ApplyZoom()
        {
            var scaleTransform = new ScaleTransform(_zoomLevel, _zoomLevel);
            slideCanvas.LayoutTransform = scaleTransform;
            slideCanvas.Width = 960 * _zoomLevel;
            slideCanvas.Height = 720 * _zoomLevel;
            txtZoom.Text = $"{_zoomLevel * 100:F0}%";
        }

        private void BtnMarkComplete_Click(object sender, RoutedEventArgs e)
        {
            if (_currentFile == null)
            {
                MessageBox.Show("No file is currently loaded.", "No File",
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            var missingLabels = CheckRequiredLabels();

            if (missingLabels.Count > 0)
            {
                var result = MessageBox.Show(
                    $"The following are incomplete:\n\n{string.Join("\n", missingLabels)}\n\n" +
                    "Do you want to mark this file as complete anyway?",
                    "Missing Labels",
                    MessageBoxButton.YesNo,
                    MessageBoxImage.Warning);

                if (result == MessageBoxResult.No)
                    return;
            }

            _currentFile.IsCompleted = true;
            _currentFile.IsLabeled = true;

            UpdateProgress();

            MessageBox.Show(
                $"✓ File marked as complete!\n\n{_currentFile.FileName}\n\n" +
                "You can now move to the next file.",
                "File Completed",
                MessageBoxButton.OK,
                MessageBoxImage.Information);

            int currentIndex = _powerPointFiles.IndexOf(_currentFile);
            if (currentIndex < _powerPointFiles.Count - 1)
            {
                lstFiles.SelectedIndex = currentIndex + 1;
            }
        }

        private List<string> CheckRequiredLabels()
        {
            var missingLabels = new List<string>();

            int unclassifiedSlides = 0;
            for (int i = 1; i <= _currentFile.TotalSlides; i++)
            {
                if (!_currentFile.SlideTypes.ContainsKey(i))
                {
                    unclassifiedSlides++;
                }
            }

            if (unclassifiedSlides > 0)
            {
                missingLabels.Add($"  • {unclassifiedSlides} slide(s) not classified");
            }

            var requiredLabels = new[]
            {
            "WI_Number",
            "WI_Title",
            "Revision",
            "BOM_ASSY_DWG_NO",
            "Operation_No",
            "Product_Line",
            "Subject",
            "Template_Revision"
        };

            var labeledFields = _allLabeledBoxes
                .Where(b => b.SourceFile == _currentFile.FilePath &&
                           b.SlideNumber == 1 &&
                           !b.IsHidden)
                .Select(b => b.AssignedLabel)
                .Where(l => !string.IsNullOrEmpty(l) && l != "Ignore")
                .Distinct()
                .ToList();

            var labelNameMap = new Dictionary<string, string>
        {
            { "WI_Number", "WI Number" },
            { "WI_Title", "WI Title" },
            { "Revision", "Revision" },
            { "BOM_ASSY_DWG_NO", "BOM/ASSY DWG NO" },
            { "Operation_No", "Operation No" },
            { "Product_Line", "Product Line" },
            { "Subject", "Subject" },
            { "Template_Revision", "Template Revision" }
        };

            foreach (var required in requiredLabels)
            {
                if (!labeledFields.Contains(required))
                {
                    missingLabels.Add("  • " + labelNameMap[required]);
                }
            }

            return missingLabels;
        }

        private void BtnLoadTrainingData_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new OpenFileDialog
            {
                Filter = "CSV Files (*.csv)|*.csv",
                Title = "Select Training Data CSV to Load"
            };

            if (dialog.ShowDialog() == true)
            {
                try
                {
                    LoadTrainingDataFromCSV(dialog.FileName);
                    MessageBox.Show(
                        $"Training data loaded successfully!\n\n" +
                        $"Loaded {_allLabeledBoxes.Count} labeled text boxes",
                        "Success",
                        MessageBoxButton.OK,
                        MessageBoxImage.Information);

                    if (_currentFile != null)
                    {
                        DisplaySlide(_currentSlideIndex);
                    }
                }
                catch (Exception ex)
                {
                    MessageBox.Show(
                        $"Error loading training data:\n{ex.Message}",
                        "Error",
                        MessageBoxButton.OK,
                        MessageBoxImage.Error);
                }
            }
        }

        private void LoadTrainingDataFromCSV(string filePath)
        {
            _allLabeledBoxes.Clear();
            _powerPointFiles.Clear();

            var fileInfoDict = new Dictionary<string, PowerPointFileInfo>();

            using (var reader = new StreamReader(filePath))
            using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
            {
                csv.Read();
                csv.ReadHeader();

                while (csv.Read())
                {
                    try
                    {
                        string fileName = csv.GetField<string>("FileName");
                        string wiNumber = csv.GetField<string>("WI_Number");
                        string wiTitle = csv.GetField<string>("WI_Title");
                        string revision = csv.GetField<string>("Revision");
                        string bom = csv.GetField<string>("BOM_ASSY_DWG_NO");
                        string opNo = csv.GetField<string>("Operation_No");
                        string productLine = csv.GetField<string>("Product_Line");
                        string subject = csv.GetField<string>("Subject");
                        string pageNo = csv.GetField<string>("Page_No");
                        string templateRev = csv.GetField<string>("Template_Rev");
                        int slideNumber = csv.GetField<int>("SlideNumber");
                        string slideType = csv.GetField<string>("SlideType");
                        string textBoxText = csv.GetField<string>("TextBoxText");
                        float left = csv.GetField<float>("Left");
                        float top = csv.GetField<float>("Top");
                        float width = csv.GetField<float>("Width");
                        float height = csv.GetField<float>("Height");
                        string revisionType = csv.GetField<string>("RevisionType");
                        string label = csv.GetField<string>("Label");

                        if (!fileInfoDict.ContainsKey(fileName))
                        {
                            fileInfoDict[fileName] = new PowerPointFileInfo
                            {
                                FileName = fileName,
                                FilePath = "",
                                IsLabeled = true,
                                IsCompleted = true,
                                ExtractedWINumber = wiNumber,
                                ExtractedTitle = wiTitle,
                                ExtractedRevision = revision,
                                ExtractedBOM = bom,
                                ExtractedOperationNo = opNo,
                                ExtractedProductLine = productLine,
                                ExtractedSubject = subject,
                                ExtractedPageNo = pageNo,
                                ExtractedTemplateRev = templateRev
                            };
                        }

                        if (!string.IsNullOrEmpty(slideType) && !fileInfoDict[fileName].SlideTypes.ContainsKey(slideNumber))
                        {
                            fileInfoDict[fileName].SlideTypes[slideNumber] = slideType;
                        }

                        _allLabeledBoxes.Add(new LabeledTextBox
                        {
                            Text = textBoxText,
                            Left = left,
                            Top = top,
                            Width = width,
                            Height = height,
                            RevisionType = revisionType,
                            SourceFile = fileName,
                            SlideNumber = slideNumber,
                            SlideType = slideType,
                            AssignedLabel = label,
                            IsHidden = false
                        });
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error reading CSV row: {ex.Message}");
                    }
                }
            }

            _powerPointFiles.AddRange(fileInfoDict.Values);

            lstFiles.Items.Clear();
            foreach (var file in _powerPointFiles)
            {
                lstFiles.Items.Add(file);
            }

            UpdateProgress();

            Console.WriteLine($"Loaded {_allLabeledBoxes.Count} labeled boxes from {_powerPointFiles.Count} files");
        }

        private void BtnSaveTrainingData_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new SaveFileDialog
            {
                Filter = "CSV Files (*.csv)|*.csv",
                FileName = "training_data_with_values.csv"
            };

            if (dialog.ShowDialog() == true)
            {
                SaveTrainingDataToCSV(dialog.FileName);

                int filesWithData = _powerPointFiles.Count(f =>
                    !string.IsNullOrEmpty(f.ExtractedWINumber) ||
                    !string.IsNullOrEmpty(f.ExtractedTitle) ||
                    f.SlideTypes.Count > 0);

                int labeledBoxes = _allLabeledBoxes.Count(b =>
                    !string.IsNullOrEmpty(b.AssignedLabel) &&
                    !b.IsHidden &&
                    b.AssignedLabel != "Ignore");

                int classifiedSlides = _allLabeledBoxes.Count(b =>
                    !string.IsNullOrEmpty(b.SlideType));

                MessageBox.Show(
                    $"Training data saved!\n\n" +
                    $"File: {dialog.FileName}\n\n" +
                    $"Files processed: {filesWithData}\n" +
                    $"Text boxes labeled: {labeledBoxes}\n" +
                    $"Slides classified: {classifiedSlides}\n\n" +
                    $"This file contains:\n" +
                    $"• Extracted values (for review)\n" +
                    $"• Slide classifications\n" +
                    $"• Text box positions (for ML)",
                    "Success",
                    MessageBoxButton.OK,
                    MessageBoxImage.Information);
            }
        }

        private void SaveTrainingDataToCSV(string filePath)
        {
            using (var writer = new StreamWriter(filePath))
            {
                writer.WriteLine("FileName,WI_Number,WI_Title,Revision,BOM_ASSY_DWG_NO,Operation_No,Product_Line,Subject,Page_No,Template_Rev,SlideNumber,SlideType,TextBoxText,Left,Top,Width,Height,TextLength,ContainsNumbers,ContainsHyphen,StartsWithWI,IsAllDigits,RevisionType,Label");

                var fileGroups = _allLabeledBoxes
                    .Where(b => (!string.IsNullOrEmpty(b.AssignedLabel) && !b.IsHidden && b.AssignedLabel != "Ignore")
                             || !string.IsNullOrEmpty(b.SlideType))
                    .GroupBy(b => b.SourceFile);

                foreach (var fileGroup in fileGroups)
                {
                    var fileInfo = _powerPointFiles.FirstOrDefault(f => f.FilePath == fileGroup.Key || f.FileName == fileGroup.Key);

                    string fileName = fileInfo?.FileName ?? fileGroup.Key;
                    string wiNumber = fileInfo?.ExtractedWINumber ?? "";
                    string wiTitle = fileInfo?.ExtractedTitle ?? "";
                    string revision = fileInfo?.ExtractedRevision ?? "";
                    string bom = fileInfo?.ExtractedBOM ?? "";
                    string opNo = fileInfo?.ExtractedOperationNo ?? "";
                    string productLine = fileInfo?.ExtractedProductLine ?? "";
                    string subject = fileInfo?.ExtractedSubject ?? "";
                    string pageNo = fileInfo?.ExtractedPageNo ?? "";
                    string templateRev = fileInfo?.ExtractedTemplateRev ?? "";

                    foreach (var box in fileGroup)
                    {
                        string line = string.Join(",",
                            EscapeCSV(fileName),
                            EscapeCSV(wiNumber),
                            EscapeCSV(wiTitle),
                            EscapeCSV(revision),
                            EscapeCSV(bom),
                            EscapeCSV(opNo),
                            EscapeCSV(productLine),
                            EscapeCSV(subject),
                            EscapeCSV(pageNo),
                            EscapeCSV(templateRev),
                            box.SlideNumber.ToString(),
                            EscapeCSV(box.SlideType ?? ""),
                            EscapeCSV(CleanTextForCSV(box.Text)),
                            box.Left.ToString(CultureInfo.InvariantCulture),
                            box.Top.ToString(CultureInfo.InvariantCulture),
                            box.Width.ToString(CultureInfo.InvariantCulture),
                            box.Height.ToString(CultureInfo.InvariantCulture),
                            box.Text.Length.ToString(),
                            Regex.IsMatch(box.Text, @"\d") ? "true" : "false",
                            box.Text.Contains("-") ? "true" : "false",
                            box.Text.StartsWith("WI", StringComparison.OrdinalIgnoreCase) ? "true" : "false",
                            Regex.IsMatch(box.Text, @"^\d+$") ? "true" : "false",
                            EscapeCSV(box.RevisionType),
                            EscapeCSV(box.AssignedLabel ?? "")
                        );

                        writer.WriteLine(line);


                    }
                }
            }


            Console.WriteLine($"Combined training/verification CSV exported with slide types");
        }

        private string CleanTextForCSV(string text)
        {
            if (string.IsNullOrEmpty(text))
                return "";

            text = text.Replace("\r", " ").Replace("\n", " ");
            text = text.Replace("\t", " ");
            text = new string(text.Where(c => !char.IsControl(c) || c == ' ').ToArray());
            text = Regex.Replace(text, @"\s+", " ");

            return text.Trim();
        }

        private string EscapeCSV(string field)
        {
            if (string.IsNullOrEmpty(field))
                return "";

            if (field.Contains(",") || field.Contains("\"") || field.Contains("\n") || field.Contains("\r"))
            {
                return "\"" + field.Replace("\"", "\"\"") + "\"";
            }

            return field;
        }

        private void BtnTrainModel_Click(object sender, RoutedEventArgs e)
        {
            var result = MessageBox.Show(
                "Do you want to use an existing training CSV file?\n\n" +
                "Click 'Yes' to select an existing CSV\n" +
                "Click 'No' to generate a new one from current labels",
                "Training Data Source",
                MessageBoxButton.YesNoCancel,
                MessageBoxImage.Question);

            if (result == MessageBoxResult.Cancel)
                return;

            string trainingFile;

            if (result == MessageBoxResult.Yes)
            {
                var openDialog = new OpenFileDialog
                {
                    Filter = "CSV Files (*.csv)|*.csv",
                    Title = "Select Training Data CSV"
                };

                if (openDialog.ShowDialog() != true)
                    return;

                trainingFile = openDialog.FileName;

                Console.WriteLine($"Using existing CSV: {trainingFile}");
            }
            else
            {
                trainingFile = System.IO.Path.Combine(System.IO.Path.GetTempPath(), "temp_training.csv");
                SaveTrainingDataToCSV(trainingFile);

                int labeledCount = _allLabeledBoxes.Count(b => !string.IsNullOrEmpty(b.AssignedLabel) &&
                                                               !b.IsHidden &&
                                                               b.AssignedLabel != "Ignore");
                if (labeledCount < 20)
                {
                    MessageBox.Show($"Not enough training data. You have {labeledCount} labeled examples.\n" +
                        "Please label at least 20 text boxes before training.",
                        "Insufficient Data", MessageBoxButton.OK, MessageBoxImage.Warning);

                    try { File.Delete(trainingFile); } catch { }
                    return;
                }

                Console.WriteLine($"Generated new CSV: {trainingFile}");
            }

            var saveDialog = new SaveFileDialog
            {
                Filter = "Model Files (*.zip)|*.zip",
                FileName = "wi_extractor_model.zip"
            };

            if (saveDialog.ShowDialog() == true)
            {
                try
                {
                    Console.WriteLine($"Training model...");

                    var trainer = new ModelTrainer();
                    trainer.TrainModel(trainingFile, saveDialog.FileName);

                    MessageBox.Show($"Model trained successfully!\n\n" +
                        $"Model saved to:\n{saveDialog.FileName}\n\n" +
                        "You can now use this model in your PowerPointExtractor.",
                        "Training Complete",
                        MessageBoxButton.OK,
                        MessageBoxImage.Information);

                    Console.WriteLine($"✓ Model saved successfully");
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Error training model:\n{ex.Message}\n\n" +
                        "Check the Output window for details.",
                        "Training Error",
                        MessageBoxButton.OK,
                        MessageBoxImage.Error);

                    Console.WriteLine($"✗ Training error: {ex.Message}");
                    Console.WriteLine($"Stack trace: {ex.StackTrace}");
                }
                finally
                {
                    if (result == MessageBoxResult.No)
                    {
                        try { File.Delete(trainingFile); } catch { }
                    }
                }
            }
        }

        private void UpdateProgress()
        {
            int completed = _powerPointFiles.Count(f => f.IsCompleted);
            int labeled = _powerPointFiles.Count(f => f.IsLabeled);
            int total = _powerPointFiles.Count;

            txtProgress.Text = $"{completed} completed, {labeled} labeled of {total} files";
            progressBar.Maximum = total;
            progressBar.Value = completed;
        }
    }

    // Helper classes
    public class PowerPointFileInfo
    {
        public string FilePath { get; set; }
        public string FileName { get; set; }
        public bool IsLabeled { get; set; }
        public bool IsCompleted { get; set; }

        // Extracted values from slide 1
        public string ExtractedWINumber { get; set; }
        public string ExtractedTitle { get; set; }
        public string ExtractedRevision { get; set; }
        public string ExtractedBOM { get; set; }
        public string ExtractedOperationNo { get; set; }
        public string ExtractedProductLine { get; set; }
        public string ExtractedSubject { get; set; }
        public string ExtractedPageNo { get; set; }
        public string ExtractedTemplateRev { get; set; }

        // Slide type tracking
        public Dictionary<int, string> SlideTypes { get; set; } = new Dictionary<int, string>();
        public int TotalSlides { get; set; }
    }

    public class TextBoxInfo
    {
        public string Text { get; set; }
        public float Left { get; set; }
        public float Top { get; set; }
        public float Width { get; set; }
        public float Height { get; set; }
    }

    public class LabeledTextBox
    {
        public string Text { get; set; }
        public float Left { get; set; }
        public float Top { get; set; }
        public float Width { get; set; }
        public float Height { get; set; }
        public string AssignedLabel { get; set; }
        public string RevisionType { get; set; }
        public string SourceFile { get; set; }
        public int SlideNumber { get; set; }
        public bool IsHidden { get; set; }
        public string SlideType { get; set; }
    }


}
-----------------------------------------------------

mainwindow.xaml
<Window x:Class="WorkInstructionLabeler.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Work Instruction Labeler" Height="900" Width="1600"
        WindowState="Maximized">
    <Window.Resources>
        <!-- Unlabeled text box style -->
        <Style x:Key="UnlabeledBox" TargetType="Border">
            <Setter Property="Background" Value="#FFF3E0"/>
            <Setter Property="BorderBrush" Value="#FF6F00"/>
            <Setter Property="BorderThickness" Value="2"/>
            <Setter Property="CornerRadius" Value="3"/>
        </Style>

        <!-- WI Number style -->
        <Style x:Key="WINumberBox" TargetType="Border">
            <Setter Property="Background" Value="#C8E6C9"/>
            <Setter Property="BorderBrush" Value="#4CAF50"/>
            <Setter Property="BorderThickness" Value="2"/>
            <Setter Property="CornerRadius" Value="3"/>
        </Style>

        <!-- Title style -->
        <Style x:Key="TitleBox" TargetType="Border">
            <Setter Property="Background" Value="#BBDEFB"/>
            <Setter Property="BorderBrush" Value="#2196F3"/>
            <Setter Property="BorderThickness" Value="2"/>
            <Setter Property="CornerRadius" Value="3"/>
        </Style>

        <!-- Revision style -->
        <Style x:Key="RevisionBox" TargetType="Border">
            <Setter Property="Background" Value="#FFE0B2"/>
            <Setter Property="BorderBrush" Value="#FF9800"/>
            <Setter Property="BorderThickness" Value="2"/>
            <Setter Property="CornerRadius" Value="3"/>
        </Style>

        <!-- BOM style -->
        <Style x:Key="BOMBox" TargetType="Border">
            <Setter Property="Background" Value="#E1BEE7"/>
            <Setter Property="BorderBrush" Value="#9C27B0"/>
            <Setter Property="BorderThickness" Value="2"/>
            <Setter Property="CornerRadius" Value="3"/>
        </Style>

        <!-- Operation style -->
        <Style x:Key="OperationBox" TargetType="Border">
            <Setter Property="Background" Value="#FFCDD2"/>
            <Setter Property="BorderBrush" Value="#F44336"/>
            <Setter Property="BorderThickness" Value="2"/>
            <Setter Property="CornerRadius" Value="3"/>
        </Style>

        <!-- Product Line style -->
        <Style x:Key="ProductLineBox" TargetType="Border">
            <Setter Property="Background" Value="#B2EBF2"/>
            <Setter Property="BorderBrush" Value="#00BCD4"/>
            <Setter Property="BorderThickness" Value="2"/>
            <Setter Property="CornerRadius" Value="3"/>
        </Style>

        <!-- Subject style -->
        <Style x:Key="SubjectBox" TargetType="Border">
            <Setter Property="Background" Value="#DCEDC8"/>
            <Setter Property="BorderBrush" Value="#8BC34A"/>
            <Setter Property="BorderThickness" Value="2"/>
            <Setter Property="CornerRadius" Value="3"/>
        </Style>

        <!-- Template Revision style -->
        <Style x:Key="TemplateRevisionBox" TargetType="Border">
            <Setter Property="Background" Value="#CFD8DC"/>
            <Setter Property="BorderBrush" Value="#607D8B"/>
            <Setter Property="BorderThickness" Value="2"/>
            <Setter Property="CornerRadius" Value="3"/>
        </Style>
    </Window.Resources>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Top Bar -->
        <Border Grid.Row="0" Background="#1976D2" Padding="15">
            <StackPanel>
                <TextBlock Text="Work Instruction Labeler - ML Training Tool" 
                           FontSize="24" FontWeight="Bold" Foreground="White"/>
                <StackPanel Orientation="Horizontal" Margin="0,5,0,0">
                    <Button x:Name="btnLoadFolder" Content="📁 Load Folder" Click="BtnLoadFolder_Click"
                            Width="150" Height="35" Margin="0,0,10,0" FontSize="14" FontWeight="Bold"/>
                    <TextBlock x:Name="txtProgress" Text="No files loaded" 
                               Foreground="White" VerticalAlignment="Center" Margin="20,0,0,0" FontSize="14"/>
                    <ProgressBar x:Name="progressBar" Width="200" Height="20" Margin="20,0,0,0"/>
                    <TextBlock x:Name="txtRevType" Text="Template: Unknown" 
                               Foreground="White" VerticalAlignment="Center" Margin="20,0,0,0" FontSize="14" FontWeight="Bold"/>
                </StackPanel>
            </StackPanel>
        </Border>

        <!-- Main Content -->
        <Grid Grid.Row="1">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="250"/>
                <ColumnDefinition Width="*"/>
                <ColumnDefinition Width="250"/>
            </Grid.ColumnDefinitions>

            <!-- Left Panel - File List -->
            <Border Grid.Column="0" Background="#F5F5F5" BorderBrush="#BDBDBD" BorderThickness="0,0,1,0">
                <Grid>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="*"/>
                    </Grid.RowDefinitions>

                    <TextBlock Text="PowerPoint Files" FontSize="16" FontWeight="Bold" 
                   Margin="10" Grid.Row="0"/>

                    <ListBox x:Name="lstFiles" Grid.Row="1" Margin="10" 
                 SelectionChanged="LstFiles_SelectionChanged" DisplayMemberPath="FileName"/>
                </Grid>
            </Border>

            <!-- Center Panel - Slide Canvas -->
            <Grid Grid.Column="1" Background="#EEEEEE">
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="*"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>

                <!-- File Name -->
                <Border Grid.Row="0" Background="White" Padding="10" Margin="10,10,10,0">
                    <TextBlock x:Name="txtFileName" Text="No file selected" 
                               FontSize="18" FontWeight="Bold"/>
                </Border>

                <!-- Slide Canvas -->
                <ScrollViewer Grid.Row="1" HorizontalScrollBarVisibility="Auto" 
                              VerticalScrollBarVisibility="Auto" Margin="10">
                    <Border Background="White" BorderBrush="#BDBDBD" BorderThickness="1">
                        <Canvas x:Name="slideCanvas" Width="960" Height="720"/>
                    </Border>
                </ScrollViewer>

                <!-- Navigation Controls -->
                <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Center" Margin="10">
                    <Button x:Name="btnPrevSlide" Content="◀ Previous" Click="BtnPrevSlide_Click"
                            Width="120" Height="40" Margin="5" FontSize="14"/>
                    <TextBlock x:Name="txtSlideInfo" Text="Slide 1 of 1" 
                               VerticalAlignment="Center" FontSize="16" FontWeight="Bold" Margin="20,0"/>
                    <Button x:Name="btnNextSlide" Content="Next ▶" Click="BtnNextSlide_Click"
                            Width="120" Height="40" Margin="5" FontSize="14"/>
                </StackPanel>

                <!-- Zoom Controls -->
                <StackPanel Grid.Row="3" Orientation="Horizontal" HorizontalAlignment="Center" Margin="10">
                    <Button x:Name="btnZoomOut" Content="🔍−" Click="BtnZoomOut_Click"
                            Width="50" Height="35" Margin="5" FontSize="14"/>
                    <TextBlock x:Name="txtZoom" Text="100%" VerticalAlignment="Center" 
                               FontSize="14" FontWeight="Bold" Margin="10,0"/>
                    <Button x:Name="btnZoomIn" Content="🔍+" Click="BtnZoomIn_Click"
                            Width="50" Height="35" Margin="5" FontSize="14"/>
                    <Button x:Name="btnZoomFit" Content="Fit" Click="BtnZoomFit_Click"
                            Width="60" Height="35" Margin="5" FontSize="14"/>
                </StackPanel>
            </Grid>

            <!-- Right Panel - Labels and Controls -->
            <ScrollViewer Grid.Column="2" VerticalScrollBarVisibility="Auto">
                <StackPanel Margin="10" Width="230">
                    <TextBlock Text="Slide Classification" FontSize="16" FontWeight="Bold" Margin="0,0,0,10"/>

                    <!-- Slide Type Buttons -->
                    <Border Background="#E3F2FD" Padding="10" Margin="0,0,0,20" CornerRadius="5">
                        <StackPanel>
                            <TextBlock Text="Classify Current Slide:" FontWeight="Bold" Margin="0,0,0,5"/>
                            <TextBlock x:Name="txtCurrentSlideType" Text="Not classified" 
                                       Foreground="Gray" Margin="0,0,0,10" FontStyle="Italic"/>

                            <Button x:Name="btnTypeTitlePage" Content="Title Page" Click="BtnSlideType_Click" Tag="TitlePage"
                                    Height="35" Margin="0,0,0,5" Background="#1976D2" Foreground="White" FontSize="12"/>
                            <Button x:Name="btnTypePartsEquip" Content="Parts Equipment" Click="BtnSlideType_Click" Tag="PartsAndEquipment"
                                    Height="35" Margin="0,0,0,5" Background="#1976D2" Foreground="White" FontSize="12"/>
                            <Button x:Name="btnTypeExplodedView" Content="Exploded View" Click="BtnSlideType_Click" Tag="ExplodedView"
                                    Height="35" Margin="0,0,0,5" Background="#1976D2" Foreground="White" FontSize="12"/>
                            <Button x:Name="btnTypeApprovedSwabs" Content="Approved Swabs" Click="BtnSlideType_Click" Tag="ApprovedSwabs"
                                    Height="35" Margin="0,0,0,5" Background="#1976D2" Foreground="White" FontSize="12"/>
                            <Button x:Name="btnTypeRefImage" Content="Reference Image" Click="BtnSlideType_Click" Tag="ReferenceImage"
                                    Height="35" Margin="0,0,0,5" Background="#1976D2" Foreground="White" FontSize="12"/>
                            <Button x:Name="btnTypeAcceptGood" Content="Accept/Good Checklist" Click="BtnSlideType_Click" Tag="AcceptGoodChecklist"
                                    Height="35" Margin="0,0,0,5" Background="#1976D2" Foreground="White" FontSize="12"/>
                            <Button x:Name="btnTypeProcedure" Content="Procedure" Click="BtnSlideType_Click" Tag="Procedure"
                                    Height="35" Margin="0,0,0,5" Background="#1976D2" Foreground="White" FontSize="12"/>
                            <Button x:Name="btnTypePassGood" Content="Pass/Good Checklist" Click="BtnSlideType_Click" Tag="PassGoodChecklist"
                                    Height="35" Margin="0,0,0,5" Background="#1976D2" Foreground="White" FontSize="12"/>
                            <Button x:Name="btnTypeAppendix" Content="Appendix" Click="BtnSlideType_Click" Tag="Appendix"
                                    Height="35" Margin="0,0,0,5" Background="#1976D2" Foreground="White" FontSize="12"/>
                            <Button x:Name="btnTypeOther" Content="Other" Click="BtnSlideType_Click" Tag="Other"
                                    Height="35" Margin="0,0,0,5" Background="#607D8B" Foreground="White" FontSize="12"/>
                        </StackPanel>
                    </Border>

                    <Separator Margin="0,10,0,10"/>

                    <TextBlock Text="Text Box Labels (Slide 1 Only)" FontSize="16" FontWeight="Bold" Margin="0,0,0,10"/>
                    <TextBlock Text="Note: Text box labeling only works on Slide 1 for header data" 
                               TextWrapping="Wrap" FontSize="10" Foreground="Gray" Margin="0,0,0,10"/>

                    <!-- Selected Text Box Info -->
                    <Border Background="#FFF3E0" Padding="10" Margin="0,0,0,10" CornerRadius="5">
                        <StackPanel>
                            <TextBlock Text="Selected Text Box:" FontWeight="Bold" Margin="0,0,0,5"/>
                            <TextBlock x:Name="txtSelectedText" Text="No selection" TextWrapping="Wrap" 
                                       MaxHeight="60" FontSize="11"/>
                            <TextBlock x:Name="txtPosition" Text="" FontSize="9" Foreground="Gray" Margin="0,5,0,0"/>
                        </StackPanel>
                    </Border>

                    <!-- Text Box Label Buttons -->
                    <Button x:Name="btnLabelWINumber" Content="WI Number" Click="BtnLabel_Click" Tag="WI_Number"
                            Height="50" Margin="0,0,0,10" Background="#4CAF50" Foreground="White" 
                            FontSize="14" FontWeight="Bold"/>

                    <Button x:Name="btnLabelTitle" Content="WI Title" Click="BtnLabel_Click" Tag="WI_Title"
                            Height="50" Margin="0,0,0,10" Background="#2196F3" Foreground="White" 
                            FontSize="14" FontWeight="Bold"/>

                    <Button x:Name="btnLabelRevision" Content="Revision" Click="BtnLabel_Click" Tag="Revision"
                            Height="50" Margin="0,0,0,10" Background="#FF9800" Foreground="White" 
                            FontSize="14" FontWeight="Bold"/>

                    <Button x:Name="btnLabelBOM" Content="BOM/ASSY DWG NO" Click="BtnLabel_Click" Tag="BOM_ASSY_DWG_NO"
                            Height="50" Margin="0,0,0,10" Background="#9C27B0" Foreground="White" 
                            FontSize="14" FontWeight="Bold"/>

                    <Button x:Name="btnLabelOperation" Content="Operation No" Click="BtnLabel_Click" Tag="Operation_No"
                            Height="50" Margin="0,0,0,10" Background="#F44336" Foreground="White" 
                            FontSize="14" FontWeight="Bold"/>

                    <Button x:Name="btnLabelProductLine" Content="Product Line" Click="BtnLabel_Click" Tag="Product_Line"
                            Height="50" Margin="0,0,0,10" Background="#00BCD4" Foreground="White" 
                            FontSize="14" FontWeight="Bold"/>

                    <Button x:Name="btnLabelSubject" Content="Subject" Click="BtnLabel_Click" Tag="Subject"
                            Height="50" Margin="0,0,0,10" Background="#8BC34A" Foreground="White" 
                            FontSize="14" FontWeight="Bold"/>

                    <Button x:Name="btnLabelTemplateRev" Content="Template Revision" Click="BtnLabel_Click" Tag="Template_Revision"
                            Height="50" Margin="0,0,0,10" Background="#607D8B" Foreground="White" 
                            FontSize="14" FontWeight="Bold"/>

                    <Separator Margin="0,10,0,10"/>

                    <!-- Control Buttons -->
                    <Button x:Name="btnClearLabel" Content="Clear Label" Click="BtnClearLabel_Click"
                            Height="40" Margin="0,0,0,10" Background="#FF5252" Foreground="White" 
                            FontSize="14" FontWeight="Bold"/>

                    <Button x:Name="btnHideBox" Content="Hide Text Box" Click="BtnHideBox_Click"
                            Height="40" Margin="0,0,0,10" Background="#757575" Foreground="White" 
                            FontSize="14" FontWeight="Bold"/>
                </StackPanel>
            </ScrollViewer>
        </Grid>

        <!-- Bottom Bar -->
        <Border Grid.Row="2" Background="#F5F5F5" BorderBrush="#BDBDBD" BorderThickness="0,1,0,0" Padding="15">
            <StackPanel Orientation="Horizontal" HorizontalAlignment="Center">
                <Button x:Name="btnMarkComplete" Content="✓ Mark File Complete" Click="BtnMarkComplete_Click"
                        Height="45" Width="200" Margin="5" Background="#4CAF50" Foreground="White" 
                        FontWeight="Bold" FontSize="14"/>

                <Button x:Name="btnLoadTrainingData" Content="📂 Load Training Data" Click="BtnLoadTrainingData_Click"
                        Height="45" Width="200" Margin="5" Background="#673AB7" Foreground="White" 
                        FontWeight="Bold" FontSize="14"/>

                <Button x:Name="btnSaveTrainingData" Content="💾 Save Training Data" Click="BtnSaveTrainingData_Click"
                        Height="45" Width="200" Margin="5" Background="#2196F3" Foreground="White" 
                        FontWeight="Bold" FontSize="14"/>

                <Button x:Name="btnTrainModel" Content="🎓 Train Model" Click="BtnTrainModel_Click"
                        Height="45" Width="200" Margin="5" Background="#FF9800" Foreground="White" 
                        FontWeight="Bold" FontSize="14"/>
            </StackPanel>
        </Border>
    </Grid>
</Window>
-------------------------------------------------
trainingdatamodels.cs

using Microsoft.ML.Data;

namespace WorkInstructionLabeler
{
    /*public class TextBoxFeatures
    {
        // Skip the first 10 columns (FileName through Template_Rev)
        [LoadColumn(10)]  // TextBoxText
        public string TextBoxText { get; set; }

        [LoadColumn(11)]
        public float Left { get; set; }

        [LoadColumn(12)]
        public float Top { get; set; }

        [LoadColumn(13)]
        public float Width { get; set; }

        [LoadColumn(14)]
        public float Height { get; set; }

        [LoadColumn(15)]
        public float TextLength { get; set; }

        [LoadColumn(16)]
        public bool ContainsNumbers { get; set; }

        [LoadColumn(17)]
        public bool ContainsHyphen { get; set; }

        [LoadColumn(18)]
        public bool StartsWithWI { get; set; }

        [LoadColumn(19)]
        public bool IsAllDigits { get; set; }

        [LoadColumn(20)]
        public string RevisionType { get; set; }

        [LoadColumn(21)]
        [ColumnName("Label")]
        public string FieldType { get; set; }
    }
    */
    public class TextBoxPrediction
    {
        [ColumnName("PredictedLabel")]
        public string FieldType { get; set; }

        public float[] Score { get; set; }
    }
}
-------------------------------
modeltrainer.cs

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using CsvHelper;
using Microsoft.ML;
using Microsoft.ML.Data;

namespace WorkInstructionLabeler
{
    public class ModelTrainer
    {
        public void TrainModel(string trainingDataPath, string modelPath)
        {
            var mlContext = new MLContext(seed: 0);

            Console.WriteLine("Loading training data manually...");

            // Load data manually using CsvHelper (more forgiving)
            var trainingData = LoadTrainingDataManually(trainingDataPath);

            if (trainingData.Count == 0)
            {
                throw new Exception("No training data loaded from CSV!");
            }

            Console.WriteLine($"Loaded {trainingData.Count} training samples");

            // Convert to IDataView
            var dataView = mlContext.Data.LoadFromEnumerable(trainingData);

            // Split for training and testing (80/20)
            var split = mlContext.Data.TrainTestSplit(dataView, testFraction: 0.2);

            Console.WriteLine("Building training pipeline...");

            // Define training pipeline
            var pipeline = mlContext.Transforms.Conversion.MapValueToKey("Label", "Label")
                .Append(mlContext.Transforms.Categorical.OneHotEncoding("RevisionTypeEncoded", "RevisionType"))
                .Append(mlContext.Transforms.Concatenate("Features",
                    "Left", "Top", "Width", "Height", "TextLength",
                    "ContainsNumbers", "ContainsHyphen", "StartsWithWI",
                    "IsAllDigits", "RevisionTypeEncoded"))
                .Append(mlContext.MulticlassClassification.Trainers.SdcaMaximumEntropy(
                    labelColumnName: "Label",
                    featureColumnName: "Features"))
                .Append(mlContext.Transforms.Conversion.MapKeyToValue("PredictedLabel"));

            Console.WriteLine("Training model...");
            var model = pipeline.Fit(split.TrainSet);

            Console.WriteLine("Evaluating model...");
            var predictions = model.Transform(split.TestSet);
            var metrics = mlContext.MulticlassClassification.Evaluate(predictions, labelColumnName: "Label");

            Console.WriteLine("\n=== Model Evaluation Metrics ===");
            Console.WriteLine($"Macro Accuracy: {metrics.MacroAccuracy:P2}");
            Console.WriteLine($"Micro Accuracy: {metrics.MicroAccuracy:P2}");
            Console.WriteLine($"Log Loss: {metrics.LogLoss:F4}");
            Console.WriteLine($"Log Loss Reduction: {metrics.LogLossReduction:F4}");

            // Per-class metrics
            Console.WriteLine("\n=== Per-Class Metrics ===");
            for (int i = 0; i < metrics.PerClassLogLoss.Count; i++)
            {
                Console.WriteLine($"Class {i}: Log Loss = {metrics.PerClassLogLoss[i]:F4}");
            }

            // Confusion matrix
            Console.WriteLine("\n=== Confusion Matrix ===");
            try
            {
                string confusionTable = metrics.ConfusionMatrix.GetFormattedConfusionTable();
                Console.WriteLine(confusionTable);
            }
            catch
            {
                Console.WriteLine($"Number of classes: {metrics.ConfusionMatrix.NumberOfClasses}");
            }

            // Save the model
            Console.WriteLine($"\nSaving model to {modelPath}...");
            mlContext.Model.Save(model, dataView.Schema, modelPath);

            Console.WriteLine("Model training complete!");
        }

        private List<TextBoxFeatures> LoadTrainingDataManually(string csvPath)
        {
            var features = new List<TextBoxFeatures>();

            using (var reader = new StreamReader(csvPath))
            using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
            {
                // Configure CsvHelper to be more forgiving
                csv.Context.Configuration.BadDataFound = null;
                csv.Context.Configuration.MissingFieldFound = null;

                csv.Read();
                csv.ReadHeader();

                int lineNumber = 1;
                while (csv.Read())
                {
                    lineNumber++;
                    try
                    {
                        var left = ParseFloat(csv.GetField("Left"));
                        var top = ParseFloat(csv.GetField("Top"));
                        var width = ParseFloat(csv.GetField("Width"));
                        var height = ParseFloat(csv.GetField("Height"));
                        var textLength = ParseFloat(csv.GetField("TextLength"));
                        var containsNumbers = ParseBool(csv.GetField("ContainsNumbers"));
                        var containsHyphen = ParseBool(csv.GetField("ContainsHyphen"));
                        var startsWithWI = ParseBool(csv.GetField("StartsWithWI"));
                        var isAllDigits = ParseBool(csv.GetField("IsAllDigits"));
                        var revisionType = csv.GetField("RevisionType") ?? "Unknown";
                        var label = csv.GetField("Label");

                        if (string.IsNullOrEmpty(label))
                        {
                            Console.WriteLine($"Skipping line {lineNumber}: Empty label");
                            continue;
                        }

                        features.Add(new TextBoxFeatures
                        {
                            Left = left,
                            Top = top,
                            Width = width,
                            Height = height,
                            TextLength = textLength,
                            ContainsNumbers = containsNumbers ? 1f : 0f,  // Convert bool to float
                            ContainsHyphen = containsHyphen ? 1f : 0f,    // Convert bool to float
                            StartsWithWI = startsWithWI ? 1f : 0f,        // Convert bool to float
                            IsAllDigits = isAllDigits ? 1f : 0f,          // Convert bool to float
                            RevisionType = revisionType,
                            Label = label
                        });
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error parsing line {lineNumber}: {ex.Message}");
                    }
                }
            }

            return features;
        }

        private float ParseFloat(string value)
        {
            if (string.IsNullOrWhiteSpace(value))
                return 0f;

            if (float.TryParse(value, NumberStyles.Float, CultureInfo.InvariantCulture, out float result))
                return result;

            return 0f;
        }

        private bool ParseBool(string value)
        {
            if (string.IsNullOrWhiteSpace(value))
                return false;

            value = value.ToLower().Trim();
            return value == "true" || value == "1" || value == "yes";
        }
    }

    // TextBoxFeatures class - booleans changed to floats
    public class TextBoxFeatures
    {
        public float Left { get; set; }
        public float Top { get; set; }
        public float Width { get; set; }
        public float Height { get; set; }
        public float TextLength { get; set; }
        public float ContainsNumbers { get; set; }     // Changed from bool to float
        public float ContainsHyphen { get; set; }      // Changed from bool to float
        public float StartsWithWI { get; set; }        // Changed from bool to float
        public float IsAllDigits { get; set; }         // Changed from bool to float
        public string RevisionType { get; set; }

        [ColumnName("Label")]
        public string Label { get; set; }
    }
}
---------------------------------
assemblyinfo.cs
using System.Windows;

[assembly: ThemeInfo(
    ResourceDictionaryLocation.None,            //where theme specific resource dictionaries are located
                                                //(used if a resource is not found in the page,
                                                // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly   //where the generic resource dictionary is located
                                                //(used if a resource is not found in the page,
                                                // app, or any theme specific resource dictionaries)
)]






