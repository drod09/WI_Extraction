using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using PowerPointApp = Microsoft.Office.Interop.PowerPoint.Application;
using Microsoft.Office.Interop.PowerPoint;
using Microsoft.Office.Core;
using OfficeOpenXml;

namespace WorkInstructionExtractor
{
    public class PowerPointExtractor
    {
        static PowerPointExtractor()
        {
            ExcelPackage.License.SetNonCommercialPersonal("<Diana>");
        }

        public ExtractionResult ExtractWorkInstruction(
            string pptxPath,
            string outputFolder,
            Action<int, string> progressCallback = null)
        {
            progressCallback?.Invoke(0, "Starting extraction...");

            // Create output folders
            string baseImagesFolder = Path.Combine(outputFolder, "BaseImages");
            string composedImagesFolder = Path.Combine(outputFolder, "ComposedImages");
            Directory.CreateDirectory(baseImagesFolder);
            Directory.CreateDirectory(composedImagesFolder);

            string headerExcel = Path.Combine(outputFolder, "HeaderData.xlsx");
            string tablesExcel = Path.Combine(outputFolder, "TablesData.xlsx");
            string finalExcel = Path.Combine(outputFolder, "ExtractedData.xlsx");  // CHANGED THIS LINE

            // Extract header data and images
            progressCallback?.Invoke(10, "Extracting header data and images...");
            var (headerData, tocData) = ExtractHeadersAndImages(pptxPath, headerExcel,
                baseImagesFolder, composedImagesFolder, progressCallback);

            string wiNumber = headerData.FirstOrDefault()?["WI_Number"] ?? "";

            // Run Python script to extract tables
            progressCallback?.Invoke(40, "Extracting table data with Python...");
            bool pythonSuccess = RunPythonScript(pptxPath, tablesExcel, progressCallback);

            if (pythonSuccess)
            {
                progressCallback?.Invoke(80, "Merging data into final Excel file...");
                MergeExcelFiles(headerExcel, tablesExcel, finalExcel);

                try
                {
                    File.Delete(headerExcel);
                    File.Delete(tablesExcel);
                }
                catch { }
            }
            else
            {
                File.Move(headerExcel, finalExcel);
                progressCallback?.Invoke(100, "⚠️ Table extraction failed. Only header data extracted.");
            }

            progressCallback?.Invoke(100, "Extraction complete!");

            return new ExtractionResult
            {
                ExcelPath = finalExcel,
                BaseImagesFolder = baseImagesFolder,
                ComposedImagesFolder = composedImagesFolder,
                WINumber = wiNumber
            };
        }

        private (List<Dictionary<string, string>>, List<Dictionary<string, string>>) ExtractHeadersAndImages(
            string filePath, string excelPath, string baseImagesFolder, string composedImagesFolder,
            Action<int, string> progressCallback)
        {
            var headerData = new List<Dictionary<string, string>>();
            var imageData = new List<Dictionary<string, string>>();
            var textData = new List<Dictionary<string, string>>();
            var tocData = new List<Dictionary<string, string>>();

            PowerPointApp pptApp = new PowerPointApp();
            int docCounter = 1;

            try
            {
                progressCallback?.Invoke(15, "Opening PowerPoint file...");

                Presentation ppt = pptApp.Presentations.Open(filePath,
                    MsoTriState.msoFalse, MsoTriState.msoFalse, MsoTriState.msoFalse);

                if (ppt.Slides.Count > 0)
                {
                    progressCallback?.Invoke(20, "Extracting header data...");

                    Slide firstSlide = ppt.Slides[1];
                    var data = new Dictionary<string, string>
                    {
                        ["DocumentID"] = docCounter.ToString(),
                        ["SourceFileName"] = Path.GetFileName(filePath)
                    };

                    // Collect all text boxes from all sources
                    var allTextBoxes = new List<TextBoxInfo>();
                    CollectTextBoxes(firstSlide.Shapes, allTextBoxes);
                    try { CollectTextBoxes(firstSlide.Master.Shapes, allTextBoxes); } catch { }
                    try { CollectTextBoxes(firstSlide.Design.SlideMaster.Shapes, allTextBoxes); } catch { }
                    try { CollectTextBoxes(firstSlide.CustomLayout.Shapes, allTextBoxes); } catch { }

                    // Extract data using pattern matching
                    ExtractData(allTextBoxes, data);

                    data["TotalPages"] = ppt.Slides.Count.ToString();

                    progressCallback?.Invoke(25, "Extracting images...");
                    var images = ExtractImagesFromPresentation(ppt, docCounter, data["WI_Number"],
                        Path.GetFileName(filePath), baseImagesFolder, composedImagesFolder);
                    imageData.AddRange(images);
                    data["TotalImages"] = images.Count.ToString();

                    progressCallback?.Invoke(30, "Extracting text content...");
                    var slideTexts = ExtractTextFromSlides(ppt, docCounter, data["WI_Number"],
                        Path.GetFileName(filePath));
                    textData.AddRange(slideTexts);

                    progressCallback?.Invoke(33, "Building table of contents...");
                    var tocEntries = ExtractTableOfContents(ppt, docCounter, data["WI_Number"],
                        Path.GetFileName(filePath));
                    tocData.AddRange(tocEntries);

                    // Extract subject from TOC if still empty
                    if (tocEntries.Count > 0 && string.IsNullOrEmpty(data.GetValueOrDefault("Subject")))
                    {
                        data["Subject"] = tocEntries[0]["SlideSubject"];
                    }

                    headerData.Add(data);
                    progressCallback?.Invoke(35, $"Extracted: {data["WI_Number"]}");
                }

                ppt.Close();
            }
            finally
            {
                pptApp.Quit();
            }

            WriteToExcel(headerData, imageData, textData, tocData, excelPath);
            return (headerData, tocData);
        }

        /// <summary>
        /// Extract all header fields using pattern matching only - no position dependencies
        /// </summary>
        private void ExtractData(List<TextBoxInfo> textBoxes, Dictionary<string, string> data)
        {
            // Initialize all fields
            data["WI_Number"] = "";
            data["WI_Title"] = "";
            data["Revision"] = "";
            data["BOM_ASSY_DWG_NO"] = "";
            data["Operation_No"] = "";
            data["Product_Line"] = "";
            data["Subject"] = "";
            data["RevisionType"] = "";

            // First, detect the revision type from FM-ME text
            string revisionType = DetectRevisionType(textBoxes);
            data["RevisionType"] = revisionType;

            Console.WriteLine($"Detected Revision Type: {revisionType}");

            // Extract based on revision type
            if (revisionType == "15" || revisionType == "16")
            {
                ExtractRev15_16(textBoxes, data);
            }
            else if (revisionType == "17" || revisionType == "18" || revisionType == "19")
            {
                ExtractRev17_19(textBoxes, data);
            }
            else
            {
                // Unknown revision - try pattern-based as fallback
                Console.WriteLine("Unknown revision type - using pattern-based extraction");
                ExtractWithPatterns(textBoxes, data);
            }
        }

        /// <summary>
        /// Detect revision type from FM-ME text box
        /// </summary>
        private string DetectRevisionType(List<TextBoxInfo> textBoxes)
        {
            foreach (var box in textBoxes)
            {
                string upper = box.Text.ToUpper();
                if (upper.Contains("FM-ME") || upper.Contains("FM ME") || upper.Contains("FMME"))
                {
                    var match = System.Text.RegularExpressions.Regex.Match(box.Text,
                        @"rev\.?\s*(\d+)",
                        System.Text.RegularExpressions.RegexOptions.IgnoreCase);

                    if (match.Success && match.Groups.Count > 1)
                    {
                        return match.Groups[1].Value;
                    }
                }
            }
            return "Unknown";
        }

        /// <summary>
        /// Extract fields for Rev 15-16 templates (Slide format 5:4, needs conversion to 4:3)
        /// Position ranges are approximate and may need adjustment
        /// </summary>
        private void ExtractRev15_16(List<TextBoxInfo> textBoxes, Dictionary<string, string> data)
        {
            Console.WriteLine("Using Rev 15-16 extraction logic");

            foreach (var box in textBoxes)
            {
                string text = box.Text.Trim();
                string upper = text.ToUpper();

                // Skip labels
                if (IsLabel(upper) || string.IsNullOrWhiteSpace(text)) continue;

                Console.WriteLine($"Rev15-16: Text='{text}', Left={box.Left:F1}, Top={box.Top:F1}");

                // WI Number - pattern based (consistent across all revs)
                if (string.IsNullOrEmpty(data["WI_Number"]))
                {
                    var wiMatch = System.Text.RegularExpressions.Regex.Match(text,
                        @"W\.?\s*I\.?\s*-?\s*\d{2,}",
                        System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                    if (wiMatch.Success)
                    {
                        string wiNum = wiMatch.Value.Replace(" ", "").Replace(".", "").ToUpper();
                        if (!wiNum.Contains("-"))
                            wiNum = wiNum.Replace("WI", "WI-");
                        data["WI_Number"] = wiNum;
                        Console.WriteLine($"  -> WI_Number: {wiNum}");
                        continue;
                    }
                }

                // WI Title - Rev 15/16: Left 20-80, Top 515-525
                if (string.IsNullOrEmpty(data["WI_Title"]))
                {
                    if (box.Left > 20 && box.Left < 80 && box.Top > 510 && box.Top < 530 &&
                        text.Length > 10 && text.Length < 150)
                    {
                        data["WI_Title"] = text;
                        Console.WriteLine($"  -> WI_Title: {text}");
                        continue;
                    }
                }

                // Revision - Rev 15/16: Left 595-620, Top 555-565, 1-2 digits
                if (string.IsNullOrEmpty(data["Revision"]))
                {
                    if (box.Left > 590 && box.Left < 625 && box.Top > 550 && box.Top < 570 &&
                        System.Text.RegularExpressions.Regex.IsMatch(text, @"^\d{1,2}$"))
                    {
                        data["Revision"] = text;
                        Console.WriteLine($"  -> Revision: {text}");
                        continue;
                    }
                }

                // BOM/ASSY DWG NO - Rev 15/16: Left 300-315, Top 558-565
                if (string.IsNullOrEmpty(data["BOM_ASSY_DWG_NO"]))
                {
                    if (box.Left > 295 && box.Left < 320 && box.Top > 555 && box.Top < 568 &&
                        text.Length > 2 && text.Length < 50 &&
                        !text.StartsWith("WI", StringComparison.OrdinalIgnoreCase))
                    {
                        data["BOM_ASSY_DWG_NO"] = text;
                        Console.WriteLine($"  -> BOM_ASSY_DWG_NO: {text}");
                        continue;
                    }
                }

                // Operation No - Rev 15/16: Left 185-195, Top 555-565
                if (string.IsNullOrEmpty(data["Operation_No"]))
                {
                    if (box.Left > 180 && box.Left < 200 && box.Top > 550 && box.Top < 570 &&
                        text.Length > 1 && text.Length < 40)
                    {
                        data["Operation_No"] = text;
                        Console.WriteLine($"  -> Operation_No: {text}");
                        continue;
                    }
                }

                // Product Line - Rev 15/16: Left 460-515, Top 555-565
                if (string.IsNullOrEmpty(data["Product_Line"]))
                {
                    if (box.Left > 455 && box.Left < 520 && box.Top > 550 && box.Top < 570 &&
                        text.Length >= 2 && text.Length < 30 &&
                        !upper.Contains("PAGE"))
                    {
                        data["Product_Line"] = text;
                        Console.WriteLine($"  -> Product_Line: {text}");
                        continue;
                    }
                }

                // Subject - Rev 15/16: Left 420-430, Top 520-525
                if (string.IsNullOrEmpty(data["Subject"]))
                {
                    if (box.Left > 415 && box.Left < 435 && box.Top > 515 && box.Top < 530 &&
                        text.Length > 5 && text.Length < 80 &&
                        !upper.Contains("COMPANY") &&
                        text != data["WI_Title"])
                    {
                        data["Subject"] = text;
                        Console.WriteLine($"  -> Subject: {text}");
                        continue;
                    }
                }
            }

            // Fallback: if Subject is still empty, try pattern-based
            if (string.IsNullOrEmpty(data["Subject"]))
            {
                foreach (var box in textBoxes)
                {
                    string text = box.Text.Trim();
                    string upper = text.ToUpper();

                    if (text.Length > 5 && text.Length < 80 &&
                        !IsLabel(upper) &&
                        !upper.Contains("COMPANY") &&
                        !upper.Contains("PAGE") &&
                        text != data["WI_Title"] &&
                        text != data["WI_Number"] &&
                        text != data["BOM_ASSY_DWG_NO"])
                    {
                        data["Subject"] = text;
                        Console.WriteLine($"  -> Subject (fallback): {text}");
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// Extract fields for Rev 17-19 templates (Slide format 4:3)
        /// </summary>
        private void ExtractRev17_19(List<TextBoxInfo> textBoxes, Dictionary<string, string> data)
        {
            Console.WriteLine("Using Rev 17-19 extraction logic");

            foreach (var box in textBoxes)
            {
                string text = box.Text.Trim();
                string upper = text.ToUpper();

                // Skip labels
                if (IsLabel(upper) || string.IsNullOrWhiteSpace(text)) continue;

                Console.WriteLine($"Rev17-19: Text='{text}', Left={box.Left:F1}, Top={box.Top:F1}");

                // WI Number - pattern based (consistent across all revs)
                if (string.IsNullOrEmpty(data["WI_Number"]))
                {
                    var wiMatch = System.Text.RegularExpressions.Regex.Match(text,
                        @"W\.?\s*I\.?\s*-?\s*\d{2,}",
                        System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                    if (wiMatch.Success)
                    {
                        string wiNum = wiMatch.Value.Replace(" ", "").Replace(".", "").ToUpper();
                        if (!wiNum.Contains("-"))
                            wiNum = wiNum.Replace("WI", "WI-");
                        data["WI_Number"] = wiNum;
                        Console.WriteLine($"  -> WI_Number: {wiNum}");
                        continue;
                    }
                }

                // WI Title - Rev 17/19: Left 100-110, Top 455-470
                if (string.IsNullOrEmpty(data["WI_Title"]))
                {
                    if (box.Left > 95 && box.Left < 115 && box.Top > 450 && box.Top < 475 &&
                        text.Length > 10 && text.Length < 150)
                    {
                        data["WI_Title"] = text;
                        Console.WriteLine($"  -> WI_Title: {text}");
                        continue;
                    }
                }

                // Revision - Rev 17/19: Left 665-680, Top 460-470, 1-2 digits
                if (string.IsNullOrEmpty(data["Revision"]))
                {
                    if (box.Left > 660 && box.Left < 685 && box.Top > 455 && box.Top < 475 &&
                        System.Text.RegularExpressions.Regex.IsMatch(text, @"^\d{1,2}$"))
                    {
                        data["Revision"] = text;
                        Console.WriteLine($"  -> Revision: {text}");
                        continue;
                    }
                }

                // BOM/ASSY DWG NO - Rev 17/19: Left 0-20, Top 498-505
                if (string.IsNullOrEmpty(data["BOM_ASSY_DWG_NO"]))
                {
                    if (box.Left > -5 && box.Left < 25 && box.Top > 493 && box.Top < 510 &&
                        text.Length > 2 && text.Length < 50 &&
                        !text.StartsWith("WI", StringComparison.OrdinalIgnoreCase))
                    {
                        data["BOM_ASSY_DWG_NO"] = text;
                        Console.WriteLine($"  -> BOM_ASSY_DWG_NO: {text}");
                        continue;
                    }
                }

                // Operation No - Rev 17/19: Left 140-155, Top 498-505
                if (string.IsNullOrEmpty(data["Operation_No"]))
                {
                    if (box.Left > 135 && box.Left < 160 && box.Top > 493 && box.Top < 510 &&
                        text.Length > 1 && text.Length < 40)
                    {
                        data["Operation_No"] = text;
                        Console.WriteLine($"  -> Operation_No: {text}");
                        continue;
                    }
                }

                // Product Line - Rev 17/19: Left 210-230, Top 498-505
                if (string.IsNullOrEmpty(data["Product_Line"]))
                {
                    if (box.Left > 205 && box.Left < 235 && box.Top > 493 && box.Top < 510 &&
                        text.Length >= 2 && text.Length < 30 &&
                        !upper.Contains("PAGE"))
                    {
                        data["Product_Line"] = text;
                        Console.WriteLine($"  -> Product_Line: {text}");
                        continue;
                    }
                }

                // Subject - Rev 17/19: Left 315-640, Top 495-510
                if (string.IsNullOrEmpty(data["Subject"]))
                {
                    if (box.Left > 310 && box.Left < 645 && box.Top > 490 && box.Top < 515 &&
                        text.Length > 5 && text.Length < 80 &&
                        !upper.Contains("COMPANY") &&
                        text != data["WI_Title"])
                    {
                        data["Subject"] = text;
                        Console.WriteLine($"  -> Subject: {text}");
                        continue;
                    }
                }
            }

            // Fallback: if Subject is still empty, try pattern-based
            if (string.IsNullOrEmpty(data["Subject"]))
            {
                foreach (var box in textBoxes)
                {
                    string text = box.Text.Trim();
                    string upper = text.ToUpper();

                    if (text.Length > 5 && text.Length < 80 &&
                        !IsLabel(upper) &&
                        !upper.Contains("COMPANY") &&
                        !upper.Contains("PAGE") &&
                        text != data["WI_Title"] &&
                        text != data["WI_Number"] &&
                        text != data["BOM_ASSY_DWG_NO"])
                    {
                        data["Subject"] = text;
                        Console.WriteLine($"  -> Subject (fallback): {text}");
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// Fallback pattern-based extraction for unknown revisions
        /// </summary>
        private void ExtractWithPatterns(List<TextBoxInfo> textBoxes, Dictionary<string, string> data)
        {
            // WI Number
            foreach (var box in textBoxes)
            {
                if (string.IsNullOrEmpty(data["WI_Number"]))
                {
                    var wiMatch = System.Text.RegularExpressions.Regex.Match(box.Text,
                        @"W\.?\s*I\.?\s*-?\s*\d{2,}",
                        System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                    if (wiMatch.Success)
                    {
                        string wiNum = wiMatch.Value.Replace(" ", "").Replace(".", "").ToUpper();
                        if (!wiNum.Contains("-"))
                            wiNum = wiNum.Replace("WI", "WI-");
                        data["WI_Number"] = wiNum;
                    }
                }
            }

            // Simple pattern-based extraction for other fields
            foreach (var box in textBoxes)
            {
                string text = box.Text.Trim();
                string upper = text.ToUpper();

                if (IsLabel(upper) || string.IsNullOrWhiteSpace(text)) continue;

                // Revision
                if (string.IsNullOrEmpty(data["Revision"]) &&
                    System.Text.RegularExpressions.Regex.IsMatch(text, @"^\d{1,2}$"))
                {
                    data["Revision"] = text;
                }

                // Title - longer text
                if (string.IsNullOrEmpty(data["WI_Title"]) &&
                    text.Length > 15 && text.Length < 150)
                {
                    data["WI_Title"] = text;
                }

                // Subject - medium text
                if (string.IsNullOrEmpty(data["Subject"]) &&
                    text.Length > 5 && text.Length < 80 &&
                    text != data["WI_Title"])
                {
                    data["Subject"] = text;
                }
            }
        }

        private bool IsLabel(string upperText)
        {
            var labels = new[] {
                "WORK INSTRUCTION TITLE", "WORK INSTRUCTION", "DESCRIPTION", "DESCRIPTION:",
                "W.I. NUMBER", "WI NUMBER", "BOM/ASSY DWG NO", "BOM DWG NO", "ASSY DWG NO",
                "OPS (OPTIONAL)", "OPERATION NO", "OPERATION NO.", "PRODUCT LINE",
                "SUBJECT", "SUBJECT:", "PAGE", "REV", "REV:", "REVISION", "REVISION:",
                "TRAINING RECORD", "REVISION HISTORY", "NOTICE", "STATEMENT"
            };

            return labels.Any(label => upperText == label || upperText.Contains(label) && upperText.Length < 40) ||
                   (upperText.EndsWith(":") && upperText.Length < 25);
        }

        private List<Dictionary<string, string>> ExtractTextFromSlides(Presentation ppt, int docId,
            string wiNumber, string sourceFileName)
        {
            var textData = new List<Dictionary<string, string>>();

            for (int slideIdx = 2; slideIdx <= ppt.Slides.Count; slideIdx++)
            {
                try
                {
                    Slide slide = ppt.Slides[slideIdx];
                    string slideSubject = ExtractSlideSubject(slide);
                    int textBoxCounter = 1;

                    foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Shapes)
                    {
                        if (shape.HasTable == MsoTriState.msoTrue) continue;

                        string extractedText = ExtractTextFromShape(shape);
                        if (!string.IsNullOrWhiteSpace(extractedText) &&
                            !extractedText.Trim().Equals(slideSubject.Trim(), StringComparison.OrdinalIgnoreCase))
                        {
                            textData.Add(new Dictionary<string, string>
                            {
                                ["DocumentID"] = docId.ToString(),
                                ["WI_Number"] = wiNumber,
                                ["SourceFileName"] = sourceFileName,
                                ["SlideNumber"] = slideIdx.ToString(),
                                ["SlideSubject"] = slideSubject,
                                ["TextBoxNumber"] = textBoxCounter.ToString(),
                                ["TextContent"] = extractedText.Trim()
                            });
                            textBoxCounter++;
                        }
                    }
                }
                catch { }
            }

            return textData;
        }

        private string ExtractSlideSubject(Slide slide)
        {
            try
            {
                // First, collect all text boxes from the slide
                var textBoxes = new List<TextBoxInfo>();
                CollectTextBoxes(slide.Shapes, textBoxes);

                // Detect revision type from the first slide (if we have it cached, use it)
                // For now, we'll detect it from each slide's master/layout
                string revisionType = DetectRevisionTypeFromSlide(slide);

                Console.WriteLine($"Slide {slide.SlideIndex}: Detected revision {revisionType}");

                // Extract subject based on revision type using position
                string subject = "";

                if (revisionType == "15" || revisionType == "16")
                {
                    // Rev 15/16: Subject position - Left 420-430, Top 520-525 (or similar)
                    // But for other slides, subject might be in title position
                    subject = ExtractSubjectRev15_16(textBoxes);
                }
                else if (revisionType == "17" || revisionType == "18" || revisionType == "19")
                {
                    // Rev 17/19: Subject position - Left 315-640, Top 495-510
                    subject = ExtractSubjectRev17_19(textBoxes);
                }
                else
                {
                    // Unknown revision - try standard title placeholder
                    subject = ExtractSubjectFallback(slide);
                }

                if (!string.IsNullOrWhiteSpace(subject))
                {
                    Console.WriteLine($"  Found subject: {subject}");
                    return subject.ToUpper();
                }

                // If still not found, try the standard placeholder method
                subject = ExtractSubjectFallback(slide);

                if (!string.IsNullOrWhiteSpace(subject))
                    return subject.ToUpper();

                return "UNTITLED SLIDE";
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error extracting slide subject: {ex.Message}");
                return "UNTITLED SLIDE";
            }
        }

        private string DetectRevisionTypeFromSlide(Slide slide)
        {
            try
            {
                // Check master shapes for FM-ME text
                var textBoxes = new List<TextBoxInfo>();

                try { CollectTextBoxes(slide.Master.Shapes, textBoxes); } catch { }
                try { CollectTextBoxes(slide.Design.SlideMaster.Shapes, textBoxes); } catch { }
                try { CollectTextBoxes(slide.CustomLayout.Shapes, textBoxes); } catch { }

                return DetectRevisionType(textBoxes);
            }
            catch
            {
                return "Unknown";
            }
        }

        private string ExtractSubjectRev15_16(List<TextBoxInfo> textBoxes)
        {
            // For Rev 15/16, subject is typically in a specific position
            // Check multiple possible positions

            // Position 1: Left 420-430, Top 520-525 (header area)
            foreach (var box in textBoxes)
            {
                string text = box.Text.Trim();
                string upper = text.ToUpper();

                if (IsLabel(upper) || string.IsNullOrWhiteSpace(text)) continue;

                Console.WriteLine($"  Rev15-16 Subject check: Text='{text}', Left={box.Left:F1}, Top={box.Top:F1}");

                // Header position
                if (box.Left > 415 && box.Left < 435 && box.Top > 515 && box.Top < 530 &&
                    text.Length > 3 && text.Length < 80)
                {
                    return text;
                }
            }

            // Position 2: Top of slide (for subsequent slides) - Left 50-500, Top 30-80
            foreach (var box in textBoxes)
            {
                string text = box.Text.Trim();
                string upper = text.ToUpper();

                if (IsLabel(upper) || string.IsNullOrWhiteSpace(text)) continue;

                // Top of slide position
                if (box.Top > 25 && box.Top < 85 &&
                    box.Left > 45 && box.Left < 505 &&
                    text.Length > 3 && text.Length < 100)
                {
                    return text;
                }
            }

            // Position 3: Largest font at top
            var topShapes = textBoxes
                .Where(b => b.Top < 100 && b.Text.Trim().Length > 3 && b.Text.Trim().Length < 100)
                .OrderByDescending(b => b.Height)
                .ThenBy(b => b.Top)
                .FirstOrDefault();

            if (topShapes != null)
                return topShapes.Text.Trim();

            return "";
        }

        private string ExtractSubjectRev17_19(List<TextBoxInfo> textBoxes)
        {
            // For Rev 17/19, subject is typically in a specific position

            // Position 1: Left 315-640, Top 495-510 (header area)
            foreach (var box in textBoxes)
            {
                string text = box.Text.Trim();
                string upper = text.ToUpper();

                if (IsLabel(upper) || string.IsNullOrWhiteSpace(text)) continue;

                Console.WriteLine($"  Rev17-19 Subject check: Text='{text}', Left={box.Left:F1}, Top={box.Top:F1}");

                // Header position
                if (box.Left > 310 && box.Left < 645 && box.Top > 490 && box.Top < 515 &&
                    text.Length > 3 && text.Length < 80)
                {
                    return text;
                }
            }

            // Position 2: Top of slide (for subsequent slides) - Left 50-650, Top 30-100
            foreach (var box in textBoxes)
            {
                string text = box.Text.Trim();
                string upper = text.ToUpper();

                if (IsLabel(upper) || string.IsNullOrWhiteSpace(text)) continue;

                // Top of slide position
                if (box.Top > 25 && box.Top < 105 &&
                    box.Left > 45 && box.Left < 655 &&
                    text.Length > 3 && text.Length < 100)
                {
                    return text;
                }
            }

            // Position 3: Largest font at top
            var topShapes = textBoxes
                .Where(b => b.Top < 120 && b.Text.Trim().Length > 3 && b.Text.Trim().Length < 100)
                .OrderByDescending(b => b.Height)
                .ThenBy(b => b.Top)
                .FirstOrDefault();

            if (topShapes != null)
                return topShapes.Text.Trim();

            return "";
        }

        private string ExtractSubjectFallback(Slide slide)
        {
            try
            {
                // Check for title placeholder
                foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Shapes)
                {
                    try
                    {
                        if (shape.Type == MsoShapeType.msoPlaceholder)
                        {
                            var placeholder = shape.PlaceholderFormat;
                            if (placeholder.Type == PpPlaceholderType.ppPlaceholderTitle ||
                                placeholder.Type == PpPlaceholderType.ppPlaceholderCenterTitle)
                            {
                                if (shape.HasTextFrame == MsoTriState.msoTrue)
                                {
                                    string titleText = shape.TextFrame.TextRange.Text.Trim();
                                    if (!string.IsNullOrWhiteSpace(titleText))
                                        return titleText;
                                }
                            }
                        }
                    }
                    catch { }
                }

                // Find largest font at top of slide
                var topShapes = new List<(string text, float top, float fontSize)>();
                foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Shapes)
                {
                    try
                    {
                        if (shape.HasTextFrame == MsoTriState.msoTrue && shape.Top < 100)
                        {
                            string text = shape.TextFrame.TextRange.Text.Trim();
                            if (!string.IsNullOrWhiteSpace(text) && text.Length < 100)
                            {
                                float fontSize = 12;
                                try { fontSize = shape.TextFrame.TextRange.Font.Size; } catch { }
                                topShapes.Add((text, shape.Top, fontSize));
                            }
                        }
                    }
                    catch { }
                }

                if (topShapes.Count > 0)
                {
                    var largestFont = topShapes.OrderByDescending(s => s.fontSize).ThenBy(s => s.top).First();
                    return largestFont.text;
                }

                return "";
            }
            catch
            {
                return "";
            }
        }

        private string ExtractTextFromShape(Microsoft.Office.Interop.PowerPoint.Shape shape)
        {
            var text = new System.Text.StringBuilder();
            try
            {
                if (shape.Type == MsoShapeType.msoGroup)
                {
                    foreach (Microsoft.Office.Interop.PowerPoint.Shape groupShape in shape.GroupItems)
                    {
                        string groupText = ExtractTextFromShape(groupShape);
                        if (!string.IsNullOrWhiteSpace(groupText))
                            text.AppendLine(groupText);
                    }
                }
                else if (shape.HasTextFrame == MsoTriState.msoTrue)
                {
                    try
                    {
                        string shapeText = shape.TextFrame.TextRange.Text;
                        if (!string.IsNullOrWhiteSpace(shapeText))
                            text.AppendLine(shapeText.Trim());
                    }
                    catch { }
                }
            }
            catch { }
            return text.ToString().Trim();
        }

        private List<Dictionary<string, string>> ExtractTableOfContents(Presentation ppt, int docId,
            string wiNumber, string sourceFileName)
        {
            var tocData = new List<Dictionary<string, string>>();
            string currentSubject = null;
            int subjectStartSlide = 0;
            int slideCount = 0;

            for (int slideIdx = 1; slideIdx <= ppt.Slides.Count; slideIdx++)
            {
                try
                {
                    Slide slide = ppt.Slides[slideIdx];
                    string slideSubject = ExtractSlideSubject(slide);

                    if (currentSubject == null)
                    {
                        currentSubject = slideSubject;
                        subjectStartSlide = slideIdx;
                        slideCount = 1;
                    }
                    else if (slideSubject == currentSubject)
                    {
                        slideCount++;
                    }
                    else
                    {
                        tocData.Add(new Dictionary<string, string>
                        {
                            ["DocumentID"] = docId.ToString(),
                            ["WI_Number"] = wiNumber,
                            ["SourceFileName"] = sourceFileName,
                            ["SlideNumber"] = subjectStartSlide.ToString(),
                            ["SlideSubject"] = currentSubject,
                            ["SlideTotal"] = slideCount.ToString()
                        });

                        currentSubject = slideSubject;
                        subjectStartSlide = slideIdx;
                        slideCount = 1;
                    }
                }
                catch { }
            }

            if (currentSubject != null)
            {
                tocData.Add(new Dictionary<string, string>
                {
                    ["DocumentID"] = docId.ToString(),
                    ["WI_Number"] = wiNumber,
                    ["SourceFileName"] = sourceFileName,
                    ["SlideNumber"] = subjectStartSlide.ToString(),
                    ["SlideSubject"] = currentSubject,
                    ["SlideTotal"] = slideCount.ToString()
                });
            }

            return tocData;
        }

        private List<Dictionary<string, string>> ExtractImagesFromPresentation(Presentation ppt, int docId,
            string wiNumber, string sourceFileName, string baseImagesFolder, string composedImagesFolder)
        {
            var imageData = new List<Dictionary<string, string>>();
            int imageCounter = 1;

            string cleanWiNumber = wiNumber.StartsWith("WI-WI-") ? wiNumber.Substring(3) : wiNumber;
            string docFolderName = !string.IsNullOrEmpty(cleanWiNumber) ? cleanWiNumber : $"Doc-{docId}";
            docFolderName = string.Join("_", docFolderName.Split(Path.GetInvalidFileNameChars()));

            string baseDocFolder = Path.Combine(baseImagesFolder, docFolderName);
            string composedDocFolder = Path.Combine(composedImagesFolder, docFolderName);
            Directory.CreateDirectory(baseDocFolder);
            Directory.CreateDirectory(composedDocFolder);

            for (int slideIdx = 1; slideIdx <= ppt.Slides.Count; slideIdx++)
            {
                Slide slide = ppt.Slides[slideIdx];
                foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in slide.Shapes)
                {
                    try
                    {
                        if (shape.Type == MsoShapeType.msoPicture)
                        {
                            string imageFileName = $"{cleanWiNumber}_Slide{slideIdx:D2}_Img{imageCounter:D2}.png";
                            string imagePath = Path.Combine(baseDocFolder, imageFileName);
                            ExportShape(shape, imagePath);

                            imageData.Add(new Dictionary<string, string>
                            {
                                ["DocumentID"] = docId.ToString(),
                                ["WI_Number"] = cleanWiNumber,
                                ["SourceFileName"] = sourceFileName,
                                ["SlideNumber"] = slideIdx.ToString(),
                                ["ImageNumber"] = imageCounter.ToString(),
                                ["ImageType"] = "Base",
                                ["ImageFileName"] = imageFileName,
                                ["ImagePath"] = Path.Combine(docFolderName, imageFileName),
                                ["IsGrouped"] = "No",
                                ["Width"] = shape.Width.ToString("F2"),
                                ["Height"] = shape.Height.ToString("F2")
                            });
                            imageCounter++;
                        }
                        else if (shape.Type == MsoShapeType.msoGroup && ContainsPictures(shape.GroupItems))
                        {
                            string composedFileName = $"{cleanWiNumber}_Slide{slideIdx:D2}_Composed{imageCounter:D2}.png";
                            string composedPath = Path.Combine(composedDocFolder, composedFileName);
                            ExportShape(shape, composedPath);

                            imageData.Add(new Dictionary<string, string>
                            {
                                ["DocumentID"] = docId.ToString(),
                                ["WI_Number"] = cleanWiNumber,
                                ["SourceFileName"] = sourceFileName,
                                ["SlideNumber"] = slideIdx.ToString(),
                                ["ImageNumber"] = imageCounter.ToString(),
                                ["ImageType"] = "Composed",
                                ["ImageFileName"] = composedFileName,
                                ["ImagePath"] = Path.Combine(docFolderName, composedFileName),
                                ["IsGrouped"] = "Yes",
                                ["Width"] = shape.Width.ToString("F2"),
                                ["Height"] = shape.Height.ToString("F2")
                            });

                            ExtractImagesFromGroup(shape.GroupItems, docId, cleanWiNumber, sourceFileName,
                                slideIdx, ref imageCounter, baseDocFolder, docFolderName, imageData);
                            imageCounter++;
                        }
                    }
                    catch { }
                }
            }

            return imageData;
        }

        private void ExtractImagesFromGroup(Microsoft.Office.Interop.PowerPoint.GroupShapes groupShapes,
            int docId, string wiNumber, string sourceFileName, int slideIdx, ref int imageCounter,
            string baseDocFolder, string docFolderName, List<Dictionary<string, string>> imageData)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in groupShapes)
            {
                try
                {
                    if (shape.Type == MsoShapeType.msoPicture)
                    {
                        string imageFileName = $"{wiNumber}_Slide{slideIdx:D2}_Img{imageCounter:D2}_FromGroup.png";
                        string imagePath = Path.Combine(baseDocFolder, imageFileName);
                        ExportShape(shape, imagePath);

                        imageData.Add(new Dictionary<string, string>
                        {
                            ["DocumentID"] = docId.ToString(),
                            ["WI_Number"] = wiNumber,
                            ["SourceFileName"] = sourceFileName,
                            ["SlideNumber"] = slideIdx.ToString(),
                            ["ImageNumber"] = imageCounter.ToString(),
                            ["ImageType"] = "Base",
                            ["ImageFileName"] = imageFileName,
                            ["ImagePath"] = Path.Combine(docFolderName, imageFileName),
                            ["IsGrouped"] = "Yes (Extracted)",
                            ["Width"] = shape.Width.ToString("F2"),
                            ["Height"] = shape.Height.ToString("F2")
                        });
                        imageCounter++;
                    }
                    else if (shape.Type == MsoShapeType.msoGroup)
                    {
                        ExtractImagesFromGroup(shape.GroupItems, docId, wiNumber, sourceFileName,
                            slideIdx, ref imageCounter, baseDocFolder, docFolderName, imageData);
                    }
                }
                catch { }
            }
        }

        private bool ContainsPictures(Microsoft.Office.Interop.PowerPoint.GroupShapes groupShapes)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in groupShapes)
            {
                if (shape.Type == MsoShapeType.msoPicture) return true;
                if (shape.Type == MsoShapeType.msoGroup && ContainsPictures(shape.GroupItems)) return true;
            }
            return false;
        }

        private void ExportShape(Microsoft.Office.Interop.PowerPoint.Shape shape, string outputPath)
        {
            try
            {
                shape.Export(outputPath, PpShapeFormat.ppShapeFormatPNG);
            }
            catch
            {
                try
                {
                    shape.Copy();
                    var img = System.Windows.Forms.Clipboard.GetImage();
                    if (img != null) img.Save(outputPath, ImageFormat.Png);
                }
                catch { }
            }
        }

        private void CollectTextBoxes(Microsoft.Office.Interop.PowerPoint.Shapes shapes, List<TextBoxInfo> textBoxes)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in shapes)
            {
                try
                {
                    if (shape.Type == MsoShapeType.msoGroup)
                        CollectTextBoxesFromGroup(shape.GroupItems, textBoxes);
                    else if (shape.HasTextFrame == MsoTriState.msoTrue)
                    {
                        string text = shape.TextFrame.TextRange.Text.Trim();
                        if (!string.IsNullOrEmpty(text))
                        {
                            textBoxes.Add(new TextBoxInfo
                            {
                                Text = text,
                                Left = shape.Left,
                                Top = shape.Top,
                                Width = shape.Width,
                                Height = shape.Height
                            });
                        }
                    }
                }
                catch { }
            }
        }

        private void CollectTextBoxesFromGroup(Microsoft.Office.Interop.PowerPoint.GroupShapes groupShapes,
            List<TextBoxInfo> textBoxes)
        {
            foreach (Microsoft.Office.Interop.PowerPoint.Shape shape in groupShapes)
            {
                try
                {
                    if (shape.Type == MsoShapeType.msoGroup)
                        CollectTextBoxesFromGroup(shape.GroupItems, textBoxes);
                    else if (shape.HasTextFrame == MsoTriState.msoTrue)
                    {
                        string text = shape.TextFrame.TextRange.Text.Trim();
                        if (!string.IsNullOrEmpty(text))
                        {
                            textBoxes.Add(new TextBoxInfo
                            {
                                Text = text,
                                Left = shape.Left,
                                Top = shape.Top,
                                Width = shape.Width,
                                Height = shape.Height
                            });
                        }
                    }
                }
                catch { }
            }
        }

        #region Python and Excel Operations

        private bool RunPythonScript(string pptxFilePath, string outputExcel, Action<int, string> progressCallback)
        {
            try
            {
                progressCallback?.Invoke(45, "Looking for Python...");
                string pythonExe = FindPythonExecutable();

                if (string.IsNullOrEmpty(pythonExe))
                {
                    progressCallback?.Invoke(50, "Python not found - skipping table extraction");
                    return false;
                }

                string scriptPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "extract_tables.py");

                if (!File.Exists(scriptPath))
                {
                    progressCallback?.Invoke(50, $"Python script not found at: {scriptPath}");
                    return false;
                }

                // Create temp folder with single file
                string tempFolder = Path.Combine(Path.GetTempPath(), "TempWI_" + Guid.NewGuid());
                Directory.CreateDirectory(tempFolder);

                string tempFilePath = Path.Combine(tempFolder, Path.GetFileName(pptxFilePath));
                File.Copy(pptxFilePath, tempFilePath, true);

                progressCallback?.Invoke(50, "Running Python table extraction...");

                // Run Python directly with arguments
                ProcessStartInfo start = new ProcessStartInfo
                {
                    FileName = pythonExe,
                    Arguments = $"\"{scriptPath}\" \"{tempFolder}\" \"{outputExcel}\"",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true,
                    WorkingDirectory = Path.GetDirectoryName(scriptPath)
                };

                using (Process process = Process.Start(start))
                {
                    // Read output asynchronously to prevent deadlock
                    var outputBuilder = new System.Text.StringBuilder();
                    var errorBuilder = new System.Text.StringBuilder();

                    process.OutputDataReceived += (sender, e) =>
                    {
                        if (e.Data != null)
                        {
                            outputBuilder.AppendLine(e.Data);
                            // Show progress in UI
                            if (e.Data.Contains("Processing:") || e.Data.Contains("Extracted"))
                            {
                                progressCallback?.Invoke(55, e.Data);
                            }
                        }
                    };

                    process.ErrorDataReceived += (sender, e) =>
                    {
                        if (e.Data != null)
                        {
                            errorBuilder.AppendLine(e.Data);
                        }
                    };

                    process.BeginOutputReadLine();
                    process.BeginErrorReadLine();

                    // Wait up to 5 minutes for Python script
                    bool completed = process.WaitForExit(300000); // 5 minutes timeout

                    if (!completed)
                    {
                        progressCallback?.Invoke(60, "Python script timed out - killing process");
                        try { process.Kill(); } catch { }

                        // Cleanup
                        try
                        {
                            File.Delete(tempFilePath);
                            Directory.Delete(tempFolder);
                        }
                        catch { }

                        return false;
                    }

                    // Cleanup temp files
                    try
                    {
                        File.Delete(tempFilePath);
                        Directory.Delete(tempFolder);
                    }
                    catch { }

                    string output = outputBuilder.ToString();
                    string errors = errorBuilder.ToString();

                    if (process.ExitCode != 0)
                    {
                        progressCallback?.Invoke(60, $"Python exit code: {process.ExitCode}");
                        if (!string.IsNullOrEmpty(errors))
                            progressCallback?.Invoke(60, $"Python error: {errors.Substring(0, Math.Min(200, errors.Length))}");
                        return false;
                    }

                    bool success = File.Exists(outputExcel);
                    if (success)
                    {
                        progressCallback?.Invoke(70, "Table extraction complete");
                    }
                    else
                    {
                        progressCallback?.Invoke(70, "No output file created");
                        if (!string.IsNullOrEmpty(output))
                            progressCallback?.Invoke(70, $"Output: {output.Substring(0, Math.Min(200, output.Length))}");
                    }

                    return success;
                }
            }
            catch (Exception ex)
            {
                progressCallback?.Invoke(50, $"Error running Python: {ex.Message}");
                return false;
            }
        }

        private string FindPythonExecutable()
        {
            string[] paths = { "python", "python3",
                @"C:\Python313\python.exe",
                @"C:\Python311\python.exe",
                @"C:\Python310\python.exe"
            };

            foreach (string path in paths)
            {
                try
                {
                    ProcessStartInfo psi = new ProcessStartInfo
                    {
                        FileName = path,
                        Arguments = "--version",
                        UseShellExecute = false,
                        RedirectStandardOutput = true,
                        CreateNoWindow = true
                    };

                    using (Process process = Process.Start(psi))
                    {
                        process.WaitForExit();
                        if (process.ExitCode == 0) return path;
                    }
                }
                catch { continue; }
            }
            return null;
        }

        private void MergeExcelFiles(string headerFile, string tablesFile, string outputFile)
        {
            using (var headerPackage = new ExcelPackage(new FileInfo(headerFile)))
            using (var tablesPackage = new ExcelPackage(new FileInfo(tablesFile)))
            using (var outputPackage = new ExcelPackage())
            {
                // Copy header sheets
                foreach (var sheet in headerPackage.Workbook.Worksheets)
                    outputPackage.Workbook.Worksheets.Add(sheet.Name, sheet);

                // Copy table sheets
                foreach (var sheet in tablesPackage.Workbook.Worksheets)
                    outputPackage.Workbook.Worksheets.Add(sheet.Name, sheet);

                outputPackage.SaveAs(new FileInfo(outputFile));
            }
        }

        private void WriteToExcel(List<Dictionary<string, string>> headerData,
            List<Dictionary<string, string>> imageData,
            List<Dictionary<string, string>> textData,
            List<Dictionary<string, string>> tocData,
            string excelPath)
        {
            if (File.Exists(excelPath)) File.Delete(excelPath);

            using (var package = new ExcelPackage())
            {
                // Header Data sheet
                var ws = package.Workbook.Worksheets.Add("Header Data");
                var headers = new[] { "Document ID", "Source File Name", "WI Number", "WI Title",
                    "Revision", "BOM/ASSY DWG NO", "Operation No", "Product Line", "Subject",
                    "Revision Type", "Total Pages", "Total Images" };

                for (int i = 0; i < headers.Length; i++)
                    ws.Cells[1, i + 1].Value = headers[i];

                FormatHeader(ws, headers.Length);

                int row = 2;
                foreach (var record in headerData)
                {
                    ws.Cells[row, 1].Value = record.GetValueOrDefault("DocumentID");
                    ws.Cells[row, 2].Value = record.GetValueOrDefault("SourceFileName");
                    ws.Cells[row, 3].Value = record.GetValueOrDefault("WI_Number");
                    ws.Cells[row, 4].Value = record.GetValueOrDefault("WI_Title");
                    ws.Cells[row, 5].Value = record.GetValueOrDefault("Revision");
                    ws.Cells[row, 6].Value = record.GetValueOrDefault("BOM_ASSY_DWG_NO");
                    ws.Cells[row, 7].Value = record.GetValueOrDefault("Operation_No");
                    ws.Cells[row, 8].Value = record.GetValueOrDefault("Product_Line");
                    ws.Cells[row, 9].Value = record.GetValueOrDefault("Subject");
                    ws.Cells[row, 10].Value = record.GetValueOrDefault("RevisionType");
                    ws.Cells[row, 11].Value = record.GetValueOrDefault("TotalPages");
                    ws.Cells[row, 12].Value = record.GetValueOrDefault("TotalImages");
                    row++;
                }
                ws.Cells[ws.Dimension.Address].AutoFitColumns();

                // Images sheet
                if (imageData.Count > 0)
                {
                    var imgWs = package.Workbook.Worksheets.Add("Images");
                    var imgHeaders = new[] { "Document ID", "WI Number", "Source File Name",
                        "Slide Number", "Image Number", "Image Type", "Image File Name",
                        "Image Path", "Is Grouped", "Width", "Height" };

                    for (int i = 0; i < imgHeaders.Length; i++)
                        imgWs.Cells[1, i + 1].Value = imgHeaders[i];

                    FormatHeader(imgWs, imgHeaders.Length);

                    row = 2;
                    foreach (var img in imageData)
                    {
                        imgWs.Cells[row, 1].Value = img.GetValueOrDefault("DocumentID");
                        imgWs.Cells[row, 2].Value = img.GetValueOrDefault("WI_Number");
                        imgWs.Cells[row, 3].Value = img.GetValueOrDefault("SourceFileName");
                        imgWs.Cells[row, 4].Value = img.GetValueOrDefault("SlideNumber");
                        imgWs.Cells[row, 5].Value = img.GetValueOrDefault("ImageNumber");
                        imgWs.Cells[row, 6].Value = img.GetValueOrDefault("ImageType");
                        imgWs.Cells[row, 7].Value = img.GetValueOrDefault("ImageFileName");
                        imgWs.Cells[row, 8].Value = img.GetValueOrDefault("ImagePath");
                        imgWs.Cells[row, 9].Value = img.GetValueOrDefault("IsGrouped");
                        imgWs.Cells[row, 10].Value = img.GetValueOrDefault("Width");
                        imgWs.Cells[row, 11].Value = img.GetValueOrDefault("Height");
                        row++;
                    }
                    imgWs.Cells[imgWs.Dimension.Address].AutoFitColumns();
                }

                // Table of Contents sheet
                if (tocData.Count > 0)
                {
                    var tocWs = package.Workbook.Worksheets.Add("Table of Contents");
                    var tocHeaders = new[] { "Document ID", "WI Number", "Source File Name",
                        "Slide Number", "Slide Subject", "Slide Total" };

                    for (int i = 0; i < tocHeaders.Length; i++)
                        tocWs.Cells[1, i + 1].Value = tocHeaders[i];

                    FormatHeader(tocWs, tocHeaders.Length);

                    row = 2;
                    foreach (var toc in tocData)
                    {
                        tocWs.Cells[row, 1].Value = toc.GetValueOrDefault("DocumentID");
                        tocWs.Cells[row, 2].Value = toc.GetValueOrDefault("WI_Number");
                        tocWs.Cells[row, 3].Value = toc.GetValueOrDefault("SourceFileName");
                        tocWs.Cells[row, 4].Value = toc.GetValueOrDefault("SlideNumber");
                        tocWs.Cells[row, 5].Value = toc.GetValueOrDefault("SlideSubject");
                        tocWs.Cells[row, 6].Value = toc.GetValueOrDefault("SlideTotal");
                        row++;
                    }
                    tocWs.Cells[tocWs.Dimension.Address].AutoFitColumns();
                }

                // Text Content sheet
                if (textData.Count > 0)
                {
                    var textWs = package.Workbook.Worksheets.Add("Text Content");
                    var textHeaders = new[] { "Document ID", "WI Number", "Source File Name",
                        "Slide Number", "Slide Subject", "TextBox Number", "Text Content" };

                    for (int i = 0; i < textHeaders.Length; i++)
                        textWs.Cells[1, i + 1].Value = textHeaders[i];

                    FormatHeader(textWs, textHeaders.Length);

                    row = 2;
                    foreach (var txt in textData)
                    {
                        textWs.Cells[row, 1].Value = txt.GetValueOrDefault("DocumentID");
                        textWs.Cells[row, 2].Value = txt.GetValueOrDefault("WI_Number");
                        textWs.Cells[row, 3].Value = txt.GetValueOrDefault("SourceFileName");
                        textWs.Cells[row, 4].Value = txt.GetValueOrDefault("SlideNumber");
                        textWs.Cells[row, 5].Value = txt.GetValueOrDefault("SlideSubject");
                        textWs.Cells[row, 6].Value = txt.GetValueOrDefault("TextBoxNumber");
                        textWs.Cells[row, 7].Value = txt.GetValueOrDefault("TextContent");
                        textWs.Cells[row, 7].Style.WrapText = true;
                        row++;
                    }
                    textWs.Column(7).Width = 80;
                    textWs.Cells[textWs.Dimension.Address].AutoFitColumns();
                }

                package.SaveAs(new FileInfo(excelPath));
            }
        }

        private void FormatHeader(OfficeOpenXml.ExcelWorksheet ws, int columnCount)
        {
            using (var range = ws.Cells[1, 1, 1, columnCount])
            {
                range.Style.Font.Bold = true;
                range.Style.Fill.PatternType = OfficeOpenXml.Style.ExcelFillStyle.Solid;
                range.Style.Fill.BackgroundColor.SetColor(Color.LightGray);
                range.Style.HorizontalAlignment = OfficeOpenXml.Style.ExcelHorizontalAlignment.Center;
            }
        }

        #endregion
    }

    public class ExtractionResult
    {
        public string ExcelPath { get; set; } = string.Empty;
        public string BaseImagesFolder { get; set; } = string.Empty;
        public string ComposedImagesFolder { get; set; } = string.Empty;
        public string WINumber { get; set; } = string.Empty;
    }

    public class TextBoxInfo
    {
        public string Text { get; set; } = string.Empty;
        public float Left { get; set; }
        public float Top { get; set; }
        public float Width { get; set; }
        public float Height { get; set; }
    }
}
