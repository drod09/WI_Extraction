extract_tables.py
"""
Work Instruction PowerPoint Data Extractor
Extracts tables and images from PowerPoint files to Excel
"""

import os
from pptx import Presentation
import pandas as pd
from datetime import datetime
from openpyxl import load_workbook
from openpyxl.styles import Font, PatternFill, Alignment, numbers
import re
from PIL import Image
import io

def identify_revision_type(prs):
    """Identifies revision type from FM-ME-07 text box at bottom right"""
    if len(prs.slides) > 0:
        slide = prs.slides[0]
        
        # Look for FM-ME-07 text in all shapes (including grouped shapes)
        for shape in slide.shapes:
            if shape.has_text_frame:
                text = shape.text.lower()
                if 'fm-me-' in text or 'fm me' in text or 'fmme' in text:
                    # Check for revision numbers
                    if 'rev15' in text or 'rev16' in text or 'rev 15' in text or 'rev 16' in text:
                        return '15-16'
                    elif 'rev17' in text or 'rev18' in text or 'rev19' in text or 'rev 17' in text or 'rev 18' in text or 'rev 19' in text:
                        return '17-19'
    
    return 'Unknown'

def clean_cell_value(value):
    """Cleans cell values to remove illegal characters for Excel"""
    if not value or not isinstance(value, str):
        return value
    
    # Replace newlines with spaces
    value = value.replace('\n', ' ').replace('\r', ' ')
    
    # Replace tabs with spaces
    value = value.replace('\t', ' ')
    
    # Remove other control characters (ASCII 0-31 except tab, newline, carriage return)
    value = ''.join(char for char in value if ord(char) >= 32 or char in '\t\n\r')
    
    # Clean up multiple spaces
    value = ' '.join(value.split())
    
    return value.strip()

def parse_date(date_str):
    """Parses various date formats and returns MM/DD/YYYY format"""
    if not date_str or not isinstance(date_str, str):
        return ""
    
    date_str = date_str.strip()
    
    if not date_str or date_str == '':
        return ""
    
    # Common date patterns
    patterns = [
        r'(\d{1,2})/(\d{1,2})/(\d{4})',  # MM/DD/YYYY or M/D/YYYY
        r'(\d{1,2})/(\d{1,2})/(\d{2})',  # MM/DD/YY or M/D/YY
        r'(\d{4})-(\d{1,2})-(\d{1,2})',  # YYYY-MM-DD
        r'(\d{1,2})-(\d{1,2})-(\d{4})',  # MM-DD-YYYY or DD-MM-YYYY
    ]
    
    for pattern in patterns:
        match = re.search(pattern, date_str)
        if match:
            try:
                if len(match.groups()) == 3:
                    part1, part2, part3 = match.groups()
                    
                    # Handle YYYY-MM-DD format
                    if len(part1) == 4:
                        year = int(part1)
                        month = int(part2)
                        day = int(part3)
                    # Handle YY format
                    elif len(part3) == 2:
                        month = int(part1)
                        day = int(part2)
                        year = 2000 + int(part3)
                    # Handle MM/DD/YYYY or MM-DD-YYYY
                    else:
                        month = int(part1)
                        day = int(part2)
                        year = int(part3)
                    
                    # Validate and format
                    if 1 <= month <= 12 and 1 <= day <= 31 and 1900 <= year <= 2100:
                        return f"{month:02d}/{day:02d}/{year:04d}"
            except:
                pass
    
    return date_str  # Return original if can't parse

def find_table_by_header(slide, header_text):
    """Finds a table by looking for header text"""
    for shape in slide.shapes:
        if shape.has_table:
            table = shape.table
            # Check first row for header
            first_row_text = ' '.join([cell.text for cell in table.rows[0].cells])
            if header_text.upper() in first_row_text.upper():
                return table
    return None

def extract_bom_table(slide, doc_id):
    """Extracts BOM/Configuration table from slide"""
    bom_data = []
    
    print(f"    Searching for BOM table...")
    
    # Look for BOM/CONFIGURATION TABLE
    table = find_table_by_header(slide, 'BOM/CONFIGURATION TABLE')
    if not table:
        table = find_table_by_header(slide, 'BOM/CONFIGURATION')
    if not table:
        table = find_table_by_header(slide, 'CONFIGURATION TABLE')
    if not table:
        table = find_table_by_header(slide, 'BOM')
    if not table:
        table = find_table_by_header(slide, 'CONFIGURATION')
    
    if table:
        print(f"    Found BOM table with {len(table.rows)} rows")
        
        # Look for the actual column headers row (Part Number, Description)
        header_row_index = None
        for idx, row in enumerate(table.rows):
            row_text = ' '.join([cell.text for cell in row.cells]).upper()
            if 'PART NUMBER' in row_text or 'DESCRIPTION' in row_text:
                header_row_index = idx
                break
        
        if header_row_index is not None:
            # Extract data rows after the column header row
            data_row_count = 0
            for idx, row in enumerate(list(table.rows)[header_row_index + 1:], start=1):
                if len(row.cells) >= 2:
                    part_num = row.cells[0].text.strip()
                    description = row.cells[1].text.strip()
                    
                    # Only add if both part number and description have content
                    if part_num and description and len(part_num) > 0 and len(description) > 0:
                        bom_data.append({
                            'DocumentID': doc_id,
                            'PartNumber': clean_cell_value(part_num),
                            'Description': clean_cell_value(description),
                            'RowOrder': idx
                        })
                        data_row_count += 1
            
            print(f"    Extracted {data_row_count} BOM entries")
    else:
        print(f"    No BOM/CONFIGURATION table found")
    
    return bom_data

def get_merged_cell_value(table, row_idx, col_idx):
    """
    Gets the actual value from a cell, handling merged cells.
    If a cell is part of a merged region, returns the value from the top-left cell of that region.
    """
    try:
        cell = table.cell(row_idx, col_idx)
        # Try to get text from this cell
        text = cell.text_frame.text.strip()
        
        # If empty, it might be part of a merged cell - look upward for the value
        if not text:
            # Check cells above in the same column
            for check_row in range(row_idx - 1, -1, -1):
                try:
                    check_cell = table.cell(check_row, col_idx)
                    check_text = check_cell.text_frame.text.strip()
                    if check_text:
                        return check_text
                except:
                    pass
        
        return text
    except:
        return ""


def extract_equipment_and_parts(slide, doc_id):
    """Extracts Equipment Required and Parts Required tables from slide 2"""
    equipment_data = []
    parts_data = []
    
    print(f"    Searching for Equipment and Parts tables on slide 2...")
    
    # Look for Equipment Required table
    equipment_table = find_table_by_header(slide, 'EQUIPMENT REQUIRED')
    if not equipment_table:
        equipment_table = find_table_by_header(slide, 'Equipment Required')
    
    if equipment_table:
        print(f"    Found Equipment Required table with {len(equipment_table.rows)} rows")
        
        # Find header row
        header_row_index = None
        for idx, row in enumerate(equipment_table.rows):
            row_text = ' '.join([cell.text for cell in row.cells]).upper()
            if 'QTY' in row_text and ('PART NO' in row_text or 'DESCRIPTION' in row_text):
                header_row_index = idx
                print(f"    Header row found at index {idx}")
                break
        
        if header_row_index is not None:
            data_row_count = 0
            
            # Process each data row
            for row_idx, row in enumerate(list(equipment_table.rows)[header_row_index + 1:], start=header_row_index + 1):
                print(f"    Processing row {row_idx}, cells: {len(row.cells)}")
                
                if len(row.cells) < 3:
                    continue
                
                # Get cell values - handle merged cells by looking up for values
                cell0_text = get_merged_cell_value(equipment_table, row_idx, 0)  # Qty
                cell1_text = get_merged_cell_value(equipment_table, row_idx, 1)  # Part No
                cell2_text = clean_cell_value(row.cells[2].text.strip())  # Description
                
                # Clean the values
                cell0_text = clean_cell_value(cell0_text)
                cell1_text = clean_cell_value(cell1_text)
                
                print(f"      Cell 0 (Qty): '{cell0_text}' (merged-aware)")
                print(f"      Cell 1 (Part): '{cell1_text}' (merged-aware)")
                print(f"      Cell 2 (Desc): '{cell2_text}'")
                
                # Check if Description cell contains multiple items separated by semicolons or newlines
                descriptions = []
                if ';' in cell2_text:
                    descriptions = [d.strip() for d in cell2_text.split(';') if d.strip()]
                elif '\n' in cell2_text or '\r' in cell2_text:
                    descriptions = [d.strip() for d in cell2_text.replace('\r', '\n').split('\n') if d.strip()]
                else:
                    descriptions = [cell2_text] if cell2_text else []
                
                print(f"      Found {len(descriptions)} description(s)")
                
                # If we have multiple descriptions, repeat Qty and Part No for each
                if len(descriptions) > 1:
                    print(f"      MERGED CELL DETECTED - Creating {len(descriptions)} separate rows")
                    for desc in descriptions:
                        equipment_data.append({
                            'DocumentID': doc_id,
                            'Quantity': cell0_text,  # Repeat same Qty
                            'PartNumber': cell1_text,  # Repeat same Part No
                            'Description': desc,
                            'RowOrder': data_row_count + 1
                        })
                        data_row_count += 1
                        print(f"        Row {data_row_count}: Qty='{cell0_text}', Part='{cell1_text}', Desc='{desc}'")
                else:
                    # Normal single row - but still use merged-aware values
                    if cell0_text or cell1_text or (descriptions and descriptions[0]):
                        equipment_data.append({
                            'DocumentID': doc_id,
                            'Quantity': cell0_text,
                            'PartNumber': cell1_text,
                            'Description': descriptions[0] if descriptions else "",
                            'RowOrder': data_row_count + 1
                        })
                        data_row_count += 1
                        print(f"        Row {data_row_count}: Qty='{cell0_text}', Part='{cell1_text}', Desc='{descriptions[0] if descriptions else ''}'")
            
            print(f"    Extracted {data_row_count} equipment entries")
    else:
        print(f"    No Equipment Required table found")
    
    # Parts Required - same logic with merged cell handling
    parts_table = find_table_by_header(slide, 'PARTS REQUIRED')
    if not parts_table:
        parts_table = find_table_by_header(slide, 'Parts Required')
    
    if parts_table:
        print(f"    Found Parts Required table with {len(parts_table.rows)} rows")
        
        header_row_index = None
        for idx, row in enumerate(parts_table.rows):
            row_text = ' '.join([cell.text for cell in row.cells]).upper()
            if 'QTY' in row_text and ('PART NO' in row_text or 'DESCRIPTION' in row_text):
                header_row_index = idx
                break
        
        if header_row_index is not None:
            data_row_count = 0
            
            for row_idx, row in enumerate(list(parts_table.rows)[header_row_index + 1:], start=header_row_index + 1):
                if len(row.cells) < 3:
                    continue
                
                # Get cell values - handle merged cells
                cell0_text = get_merged_cell_value(parts_table, row_idx, 0)  # Qty
                cell1_text = get_merged_cell_value(parts_table, row_idx, 1)  # Part No
                cell2_text = clean_cell_value(row.cells[2].text.strip())  # Description
                
                # Clean the values
                cell0_text = clean_cell_value(cell0_text)
                cell1_text = clean_cell_value(cell1_text)
                
                # Handle multiple descriptions
                descriptions = []
                if ';' in cell2_text:
                    descriptions = [d.strip() for d in cell2_text.split(';') if d.strip()]
                elif '\n' in cell2_text or '\r' in cell2_text:
                    descriptions = [d.strip() for d in cell2_text.replace('\r', '\n').split('\n') if d.strip()]
                else:
                    descriptions = [cell2_text] if cell2_text else []
                
                if len(descriptions) > 1:
                    for desc in descriptions:
                        parts_data.append({
                            'DocumentID': doc_id,
                            'Quantity': cell0_text,  # Repeat same Qty
                            'PartNumber': cell1_text,  # Repeat same Part No
                            'Description': desc,
                            'RowOrder': data_row_count + 1
                        })
                        data_row_count += 1
                else:
                    if cell0_text or cell1_text or (descriptions and descriptions[0]):
                        parts_data.append({
                            'DocumentID': doc_id,
                            'Quantity': cell0_text,
                            'PartNumber': cell1_text,
                            'Description': descriptions[0] if descriptions else "",
                            'RowOrder': data_row_count + 1
                        })
                        data_row_count += 1
            
            print(f"    Extracted {data_row_count} parts entries")
    else:
        print(f"    No Parts Required table found")
    
    return equipment_data, parts_data

def extract_all_other_tables(prs, doc_id, known_table_headers):
    """
    Scans all slides for tables that aren't already identified.
    Creates a separate dataset for each unique table found.
    
    Args:
        prs: PowerPoint presentation object
        doc_id: Document ID
        known_table_headers: List of table headers we already extract (to skip them)
    
    Returns:
        Dictionary where keys are table names and values are lists of row data
    """
    all_tables = {}
    table_counter = 1
    
    print(f"\n  Scanning for additional tables across all slides...")
    
    for slide_idx in range(len(prs.slides)):
        slide = prs.slides[slide_idx]
        slide_num = slide_idx + 1
        
        for shape in slide.shapes:
            if shape.has_table:
                table = shape.table
                
                # Get first row to identify the table
                if len(table.rows) == 0:
                    continue
                
                first_row_text = ' '.join([cell.text for cell in table.rows[0].cells]).upper()
                
                # Skip if this is a known table we already process
                is_known = False
                for known_header in known_table_headers:
                    if known_header.upper() in first_row_text:
                        is_known = True
                        print(f"    Slide {slide_num}: Skipping known table '{known_header}'")
                        break
                
                if is_known:
                    continue
                
                # This is a new table!
                # Determine table name from first row or use generic name
                table_name = first_row_text[:50].strip() if first_row_text else f"Table_{table_counter}"
                
                # Make it a valid sheet name (Excel limit: 31 chars, no special chars)
                table_name = table_name.replace('/', '_').replace('\\', '_').replace('*', '_')
                table_name = table_name.replace('[', '_').replace(']', '_').replace(':', '_')
                table_name = table_name.replace('?', '_').replace('|', '_')
                table_name = table_name[:31]  # Excel sheet name limit
                
                # Make unique if duplicate
                original_name = table_name
                suffix = 1
                while table_name in all_tables:
                    table_name = f"{original_name[:27]}_{suffix}"
                    suffix += 1
                
                print(f"    Slide {slide_num}: Found new table - '{table_name}'")
                print(f"      Rows: {len(table.rows)}, Columns: {len(table.columns)}")
                
                # Extract all rows from this table
                table_data = []
                
                for row_idx in range(len(table.rows)):
                    row_data = {
                        'DocumentID': doc_id,
                        'SlideNumber': slide_num,
                        'RowNumber': row_idx + 1
                    }
                    
                    # Extract each cell in the row
                    for col_idx in range(len(table.columns)):
                        # Use merged-cell-aware extraction
                        cell_value = get_merged_cell_value(table, row_idx, col_idx)
                        cell_value = clean_cell_value(cell_value)
                        
                        # Column name: use first row as headers if it looks like headers,
                        # otherwise use generic Column1, Column2, etc.
                        if row_idx == 0:
                            col_name = f"Column{col_idx + 1}"
                        else:
                            # Try to use first row as header
                            try:
                                header_cell = table.rows[0].cells[col_idx].text.strip()
                                if header_cell and len(header_cell) < 50:
                                    col_name = header_cell.replace(' ', '_').replace('/', '_')
                                    # Make it Excel-friendly
                                    col_name = ''.join(c for c in col_name if c.isalnum() or c == '_')
                                    if not col_name:
                                        col_name = f"Column{col_idx + 1}"
                                else:
                                    col_name = f"Column{col_idx + 1}"
                            except:
                                col_name = f"Column{col_idx + 1}"
                        
                        row_data[col_name] = cell_value
                    
                    table_data.append(row_data)
                
                all_tables[table_name] = table_data
                print(f"      Extracted {len(table_data)} rows")
                
                table_counter += 1
    
    if all_tables:
        print(f"\n  Found {len(all_tables)} additional table(s)")
    else:
        print(f"\n  No additional tables found")
    
    return all_tables

def extract_revision_history(slide, doc_id):
    """Extracts Revision History table from slide"""
    rev_data = []
    
    table = find_table_by_header(slide, 'REVISION HISTORY')
    
    if table:
        # Skip first row (header) and get data
        for idx, row in enumerate(list(table.rows)[1:], start=1):
            if len(row.cells) >= 3:
                rev_num = row.cells[0].text.strip()
                rev_desc = row.cells[1].text.strip()
                rev_date = row.cells[2].text.strip()
                
                # Skip header row and empty rows
                if rev_num and 'Rev' not in rev_num and rev_num != '#' and 'Description' not in rev_desc:
                    # Format date
                    formatted_date = parse_date(rev_date)
                    
                    rev_data.append({
                        'DocumentID': doc_id,
                        'RevNumber': rev_num,
                        'ChangeDescription': rev_desc,
                        'ChangeDate': formatted_date,
                        'RowOrder': idx
                    })
    
    return rev_data

def extract_drafting_and_approvals(slide, doc_id):
    """Extracts both Drafting and Approvals from combined table"""
    drafting_data = []
    approvals_data = []
    
    for shape in slide.shapes:
        if shape.has_table:
            table = shape.table
            
            # Check if this table has both Drafting and Approvals
            all_text = ' '.join([cell.text for row in table.rows for cell in row.cells]).upper()
            
            if 'DRAFTING' in all_text and 'APPROVALS' in all_text:
                # This is the combined table
                in_approvals_section = False
                
                for row_idx, row in enumerate(table.rows):
                    if len(row.cells) >= 3:
                        first_cell = row.cells[0].text.strip()
                        
                        # Check if we've reached Approvals section
                        if 'Approvals' in first_cell:
                            in_approvals_section = True
                            continue
                        
                        # Skip header rows
                        if first_cell in ['Drafting', 'Signatures', 'Date']:
                            continue
                        
                        # Extract data
                        col1 = row.cells[0].text.strip()
                        col2 = row.cells[1].text.strip()
                        col3 = row.cells[2].text.strip()
                        
                        # Format date
                        formatted_date = parse_date(col3)
                        
                        if col1:  # Has data
                            if in_approvals_section:
                                # Approvals section
                                approvals_data.append({
                                    'DocumentID': doc_id,
                                    'Department': col1,
                                    'Signature': col2,
                                    'ApprovalDate': formatted_date
                                })
                            else:
                                # Drafting section
                                drafting_data.append({
                                    'DocumentID': doc_id,
                                    'Role': col1,
                                    'Signature': col2,
                                    'SignatureDate': formatted_date
                                })
                
                break
    
    return drafting_data, approvals_data

def format_excel_sheet(worksheet):
    """Formats Excel sheet with gray headers and auto-fit columns"""
    # Format header row
    gray_fill = PatternFill(start_color="D3D3D3", end_color="D3D3D3", fill_type="solid")
    bold_font = Font(bold=True)
    center_alignment = Alignment(horizontal="center")
    
    for cell in worksheet[1]:
        cell.fill = gray_fill
        cell.font = bold_font
        cell.alignment = center_alignment
    
    # Auto-fit columns
    for column in worksheet.columns:
        max_length = 0
        column_letter = column[0].column_letter
        
        for cell in column:
            try:
                if cell.value:
                    max_length = max(max_length, len(str(cell.value)))
            except:
                pass
        
        adjusted_width = min(max_length + 2, 50)  # Cap at 50 characters
        worksheet.column_dimensions[column_letter].width = adjusted_width

def process_powerpoint_files(folder_path, output_excel):
    """Main function to process PowerPoint files"""
    
    # Initialize data containers
    bom_data_all = []
    equipment_data_all = []
    parts_data_all = []
    rev_history_all = []
    drafting_all = []
    approvals_all = []
    other_tables_all = {}  # Dictionary to hold all other tables
    
    doc_id = 1
    
    # Define known table headers that we already extract
    known_table_headers = [
        'BOM/CONFIGURATION',
        'BOM',
        'CONFIGURATION',
        'EQUIPMENT REQUIRED',
        'PARTS REQUIRED',
        'REVISION HISTORY',
        'DRAFTING',
        'APPROVALS'
    ]
    
    # Process each PowerPoint file
    for filename in os.listdir(folder_path):
        if filename.endswith('.pptx') or filename.endswith('.ppt'):
            if filename.startswith('~$'):  # Skip temp files
                continue
            
            print(f"Processing: {filename}")
            
            filepath = os.path.join(folder_path, filename)
            
            try:
                prs = Presentation(filepath)
                
                # Identify revision type
                rev_type = identify_revision_type(prs)
                print(f"  Revision type: {rev_type}")
                
                # Get first slide
                if len(prs.slides) > 0:
                    first_slide = prs.slides[0]
                    
                    # Extract tables from first slide
                    bom_data_all.extend(extract_bom_table(first_slide, doc_id))
                    
                    rev_history_all.extend(extract_revision_history(first_slide, doc_id))
                    
                    # Extract drafting and approvals (from combined table)
                    drafting, approvals = extract_drafting_and_approvals(first_slide, doc_id)
                    drafting_all.extend(drafting)
                    approvals_all.extend(approvals)
                    
                    print(f"  Extracted from slide 1: {len(drafting)} drafting, {len(approvals)} approvals")
                
                # Get second slide for Equipment and Parts
                if len(prs.slides) > 1:
                    second_slide = prs.slides[1]
                    equipment, parts = extract_equipment_and_parts(second_slide, doc_id)
                    equipment_data_all.extend(equipment)
                    parts_data_all.extend(parts)
                    print(f"  Extracted from slide 2: {len(equipment)} equipment, {len(parts)} parts")
                
                # **NEW: Scan for all other tables across all slides**
                other_tables = extract_all_other_tables(prs, doc_id, known_table_headers)
                
                # Merge other tables data
                for table_name, table_data in other_tables.items():
                    if table_name not in other_tables_all:
                        other_tables_all[table_name] = []
                    other_tables_all[table_name].extend(table_data)
                
                doc_id += 1
                
            except Exception as e:
                print(f"  ERROR processing {filename}: {str(e)}")
                import traceback
                traceback.print_exc()
    
    # Create Excel file
    print(f"\nCreating Excel file: {output_excel}")
    
    with pd.ExcelWriter(output_excel, engine='openpyxl') as writer:
        # BOM sheet
        if bom_data_all:
            df_bom = pd.DataFrame(bom_data_all)
            df_bom.to_excel(writer, sheet_name='BOM', index=False)
        else:
            df_bom = pd.DataFrame(columns=['DocumentID', 'PartNumber', 'Description', 'RowOrder'])
            df_bom.to_excel(writer, sheet_name='BOM', index=False)
        
        # Equipment Required sheet
        if equipment_data_all:
            df_equipment = pd.DataFrame(equipment_data_all)
            df_equipment.to_excel(writer, sheet_name='EquipmentRequired', index=False)
        else:
            df_equipment = pd.DataFrame(columns=['DocumentID', 'Quantity', 'PartNumber', 'Description', 'RowOrder'])
            df_equipment.to_excel(writer, sheet_name='EquipmentRequired', index=False)
        
        # Parts Required sheet
        if parts_data_all:
            df_parts = pd.DataFrame(parts_data_all)
            df_parts.to_excel(writer, sheet_name='PartsRequired', index=False)
        else:
            df_parts = pd.DataFrame(columns=['DocumentID', 'Quantity', 'PartNumber', 'Description', 'RowOrder'])
            df_parts.to_excel(writer, sheet_name='PartsRequired', index=False)
        
        # Revision History sheet
        if rev_history_all:
            df_rev = pd.DataFrame(rev_history_all)
            df_rev.to_excel(writer, sheet_name='RevisionHistory', index=False)
        else:
            df_rev = pd.DataFrame(columns=['DocumentID', 'RevNumber', 'ChangeDescription', 'ChangeDate', 'RowOrder'])
            df_rev.to_excel(writer, sheet_name='RevisionHistory', index=False)
        
        # Drafting sheet
        if drafting_all:
            df_draft = pd.DataFrame(drafting_all)
            df_draft.to_excel(writer, sheet_name='Drafting', index=False)
        else:
            df_draft = pd.DataFrame(columns=['DocumentID', 'Role', 'Signature', 'SignatureDate'])
            df_draft.to_excel(writer, sheet_name='Drafting', index=False)
        
        # Approvals sheet
        if approvals_all:
            df_approve = pd.DataFrame(approvals_all)
            df_approve.to_excel(writer, sheet_name='Approvals', index=False)
        else:
            df_approve = pd.DataFrame(columns=['DocumentID', 'Department', 'Signature', 'ApprovalDate'])
            df_approve.to_excel(writer, sheet_name='Approvals', index=False)
        
        # **NEW: Add sheets for all other discovered tables**
        for table_name, table_data in other_tables_all.items():
            if table_data:
                df_other = pd.DataFrame(table_data)
                # Ensure sheet name is valid
                safe_sheet_name = table_name[:31]
                df_other.to_excel(writer, sheet_name=safe_sheet_name, index=False)
                print(f"  Created sheet: {safe_sheet_name} ({len(table_data)} rows)")
    
    # Apply formatting to all sheets
    print("Applying formatting...")
    workbook = load_workbook(output_excel)
    
    for sheet_name in workbook.sheetnames:
        worksheet = workbook[sheet_name]
        format_excel_sheet(worksheet)
    
    workbook.save(output_excel)
    
    print(f"\nExtraction complete!")
    print(f"Processed {doc_id - 1} documents")
    print(f"Total BOM entries: {len(bom_data_all)}")
    print(f"Total Equipment entries: {len(equipment_data_all)}")
    print(f"Total Parts entries: {len(parts_data_all)}")
    print(f"Total Revision History entries: {len(rev_history_all)}")
    print(f"Total Drafting entries: {len(drafting_all)}")
    print(f"Total Approval entries: {len(approvals_all)}")
    print(f"Total additional tables found: {len(other_tables_all)}")
    for table_name, table_data in other_tables_all.items():
        print(f"  - {table_name}: {len(table_data)} rows")
    print(f"Saved to: {output_excel}")

if __name__ == "__main__":
    # CONFIGURE THESE PATHS
    input_folder = r"C:\Users\U309011\Desktop\New folder"
    output_excel = r"C:\Users\U309011\Desktop\WorkInstructions_Extracted.xlsx"
    
    print("=" * 70)
    print("WORK INSTRUCTION POWERPOINT TABLE EXTRACTOR")
    print("=" * 70)
    print(f"Input folder: {input_folder}")
    print(f"Output Excel: {output_excel}")
    print("=" * 70)
    
    # Run extraction
    process_powerpoint_files(input_folder, output_excel)
    
    print("\n" + "=" * 70)
    print("DONE! Open the Excel file to review extracted data.")
    print("=" * 70)
